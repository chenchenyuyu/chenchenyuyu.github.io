<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[伪类与伪元素]]></title>
      <url>http://yoursite.com/2017/03/13/%E4%BC%AA%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><blockquote>
<p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>
</blockquote>
<ol>
<li>伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。</li>
</ol>
<ul>
<li>:link 伪类将应用于未被访问过的链接，与:visited互斥。</li>
<li>:hover 伪类将应用于有鼠标指针悬停于其上的元素。</li>
<li>:active 伪类将应用于被激活的元素，如被点击的链接、被按下的按钮等。 </li>
<li>:visited 伪类将应用于已经被访问过的链接，与:link互斥。<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2>与伪类针对特殊状态的元素不同的是，伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。<blockquote>
<p>:first-letter 伪元素的样式将应用于元素文本的第一个字（母）。 :first-line 伪元素的样式将应用于元素文本的第一行。 :before 在元素内容的最前面添加新内容。 :after 在元素内容的最后面添加新内容。</p>
<h2 id="伪类与伪元素区别"><a href="#伪类与伪元素区别" class="headerlink" title="伪类与伪元素区别"></a>伪类与伪元素区别</h2><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。<br><code>注：</code>伪类与伪元素的区别在于：有没有创建一个文档树之外的元素</p>
<h2 id="伪元素是使用单冒号还是双冒号？"><a href="#伪元素是使用单冒号还是双冒号？" class="headerlink" title="伪元素是使用单冒号还是双冒号？"></a>伪元素是使用单冒号还是双冒号？</h2><p>CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。然而，除了少部分伪元素，如::backdrop必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法，比如::after，写成:after也可以正确运行。</p>
<h2 id="伪类与伪元素的具体用法"><a href="#伪类与伪元素的具体用法" class="headerlink" title="伪类与伪元素的具体用法"></a>伪类与伪元素的具体用法</h2><p>下面是根据用途分类的伪类总结图:<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170313/170250786.png" alt="mark"><br>根据冒号分类的伪元素总结图：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170313/170518762.png" alt="mark"></p>
</blockquote>
</li>
</ul>
<p>参考链接：<br><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="external">http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你不知道CSS(二)]]></title>
      <url>http://yoursite.com/2017/03/09/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84CSS(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<ol>
<li><p>浏览器的内核<br>浏览器的核心部分：“rendering engine”渲染引擎，习惯称为“浏览器内核”负责对网页的语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。</p>
<blockquote>
<p>浏览器内核决定了浏览器如何显示网页内容以及页面的格式信息。<br>不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IE: trident内核</div><div class="line">Firefox：gecko内核</div><div class="line">Safari:webkit内核</div><div class="line">Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核</div><div class="line">Chrome:Blink(基于webkit，Google与Opera Software共同开发)</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>doctype是干什么的？<br>&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）</html></p>
</li>
<li><p>逐渐增强与优雅降级</p>
</li>
</ol>
<ul>
<li>渐进增强 progressiveenhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li>优雅降级 gracefuldegradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li>
</ul>
<ol>
<li>如何理解HTML结构的语义化<ul>
<li>去掉或样式失去的时候让页面呈现清晰的结构</li>
<li>屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页</li>
<li>PDA，手机等设备可能无法像电脑浏览器一样渲染网页（通常是因为这些设备对css的支持较弱）</li>
<li>搜素引擎的爬虫也依赖标记来确定上下文和各个关键字的权重</li>
<li>你的页面是否对爬虫容易理解非常重要，因为爬虫很大程度上会忽略用于表现的标记，而只是注重语义标记（SEO主要还是靠网站的内容和外部链接）</li>
<li>便于团队的开发和维护</li>
</ul>
<ol>
<li>谈谈以前端角度出发做好SEO需要考虑什么？</li>
</ol>
</li>
</ol>
<ul>
<li><p>了解搜索引擎如何抓取网页和如何索引网页<br>你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。</p>
</li>
<li><p>Meta标签优化<br>主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。</p>
</li>
<li><p>如何选取关键词并在网页中放置关键词<br>搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</p>
</li>
<li><p>了解主要的搜索引擎<br>虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。</p>
</li>
<li><p>主要的互联网目录<br>Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。</p>
</li>
<li><p>按点击付费的搜索引擎<br>搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。</p>
</li>
<li><p>搜索引擎登录<br>网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。</p>
</li>
<li><p>链接交换和链接广泛度（Link Popularity）<br>网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。</p>
</li>
<li><p>合理的标签使用</p>
</li>
</ul>
<ol>
<li>CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？</li>
</ol>
<ul>
<li><p>最基本的：<br>设置display属性为none，或者设置visibility属性为hidden</p>
</li>
<li><p>技巧性：<br>设置宽高为0，设置透明度为0，设置z-index位置在-1000</p>
</li>
</ul>
<ol>
<li>超链接访问过后hover样式就不出现的问题是什么？如何解决？</li>
</ol>
<p>答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）</p>
<ol>
<li>7.行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？</li>
</ol>
<p>块级元素(block)特性：</p>
<p>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;<br>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;<br>内联元素(inline)特性：</p>
<p>和相邻的内联元素在同一行;<br>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。<br>那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？</p>
<blockquote>
<p>input, img, button, texterea, label</p>
</blockquote>
<ol>
<li>什么是外边距重叠？重叠的结果是什么？<br>但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。<br>答案：</li>
</ol>
<p>外边距重叠就是margin-collapse。</p>
<p>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</p>
<p>折叠结果遵循下列计算规则：</p>
<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>两个外边距一正一负时，折叠结果是两者的相加的和。</p>
<ol>
<li>px和em的区别。</li>
</ol>
<p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p>
<p>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。</p>
<ol>
<li>display:none与visibility:hidden的区别是什么？</li>
</ol>
<p>display : 隐藏对应的元素但不挤占该元素原来的空间。<br>visibility: 隐藏对应的元素并且挤占该元素原来的空间。<br>即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。</p>
<ol>
<li>解决超链接访问之后hover样式不出现的问题<blockquote>
<p>有时候同时设置a:visited和a:hover的样式之后，但一旦超链接访问之后，hover的样式就不再出现<br>原因：a:visited和a:hover的顺序放错<br>a标签的四种状态排序为：“love hate”即：<br>l(link)ov(visited)e h(hover)a(active)te</p>
</blockquote>
</li>
<li>zoom:1触发IE的专有属性haslayout来解决bug</li>
<li>display:inline-block它是行内的块级元素，它拥有块级元素的特点<blockquote>
<p>可以设置宽高，也可以设置margin和padding值，但它不是独占一行的</p>
</blockquote>
</li>
<li>居中</li>
</ol>
<ul>
<li>水平居中<br>（1）文本，图片等行内元素的水平居中<blockquote>
<p>给父元素设置text-align:center可以实现文本，图片的水平居中<br>（2）确定宽度的块级元素的水平居中<br>设置margin-left:auto和margin-right:auto实现</p>
</blockquote>
</li>
<li>竖直居中<br>（1）父元素不确定的文本，图片，块级元素的竖直居中<blockquote>
<p>通过给父容器设置相同上下边距实现<br>（2）父元素高度确定的单行文本的竖直居中<br>通过给父元素设置line-height来实现，line-height值和父元素的高度值相同<br>（3）父元素高度确定的多行文本，图片，块级元素的竖直居中<br>vertical-align:middle;</p>
</blockquote>
</li>
</ul>
<p><a href="http://blog.jobbole.com/78740/" target="_blank" rel="external">参考链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你不知道的CSS(一)]]></title>
      <url>http://yoursite.com/2017/03/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84CSS(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="你不知道的CSS-一"><a href="#你不知道的CSS-一" class="headerlink" title="你不知道的CSS(一)"></a>你不知道的CSS(一)</h2><ol>
<li>在 Firefox 中注释内容中如果包含 ‘-‘ 字符在某些情况下会使该注释解析错误<br><code>据 W3C HTML 4.01 文档中的描述，需注意以下几点：</code></li>
</ol>
<ul>
<li>注释元素的开始标签 “&lt;!” 和 “–” 之间不允许有空白符存在，但是在各浏览器下就算它们之间存在空白符</li>
<li>注释元素的关闭标签 “–” 和 “&gt;” 之间允许有空白符存在。</li>
<li>应避免在注释内容中出现两个或以上的“-”字符，否则可能会出错。<br><code>注意：</code>注释内容含中横线（-）在 Firefox 中可能会使中间内容丢失。</li>
<li>当注释标签中相连连字号数量为2的奇数倍、或2的奇数倍加1时，Firefox(S) 下注释标签出错。</li>
</ul>
<ol>
<li>相对长度：</li>
</ol>
<ul>
<li>in:英寸=2.54.厘米</li>
<li>cm:厘米</li>
<li>mm：毫米</li>
<li>pt:点–1pt=1/72英寸（在css2.1里面）</li>
<li>pc:皮卡–1pc=12pt=1/6英寸</li>
</ul>
<ol>
<li>URL和URI的关系：</li>
</ol>
<ul>
<li>URI(Uniform Resource Identifier, 简称 “URI”):Web 上可用的每种资源 - HTML 文档、图像、视频片段、程序等 - 由一个通用资源标志符（Uniform Resource Identifier, 简称 “URI” ）进行定位 .</li>
<li>URL:URL 是Uniform Resource Location的缩写，译为 “统一资源定位符” 。它是 URI 命名机制的一个子集。<br><code>注意：</code>URI 表示为 <uri>。注意，定义 URI 使用 “url()” 如：background-image’ :    <uri> | none | inherit</uri></uri></li>
</ul>
<ol>
<li>各浏览器对 CSS 代码及 CSS 相关 DOM 操作中长度 <length> 类型的值缺失单位的容错程度存在差异：</length></li>
</ol>
<ul>
<li>所有浏览器的混杂模式均将缺少单位类型的长度类型 CSS 特性理解为以 “px” 为单位。</li>
<li>而所有浏览器的标准模式均将此认为是错误的 CSS 代码而忽略。</li>
</ul>
<ol>
<li>css hack:因为各大厂商对标准的实现不尽相同，所以，不同浏览器对CSS代码的解析标准不同。因此，对相同的 CSS 代码，各浏览器的解析可能会有差异。而在此差异的基础上，写出的只有个别浏览器或某些浏览器识别的 CSS 代码，就形成了 CSS hack 。<br><code>注：</code>CSS hack 是因为现有浏览器对标准的解析不同，为了兼容各浏览器，所采用的一种补救方法。CSS hack 是 一种类似作弊的手段，以欺骗浏览器的方式达到兼容的目的，是用浏览器的兼容性差异来解决浏览器的兼容性问题。</li>
<li>各浏览器对于计算后宽度和高度为含有小数的长度值时，其最终值会不一致：<br><code>注：</code>在 W3C 标准规范中没有明确说明当 <length> 值中包含小数时应该如何处理，也没有明确说明 <percentage> 值是计算是参考包含块尺寸的计算值还是实际使用值</percentage></length></li>
</ol>
<ul>
<li>IE6 IE7 IE8 Firefox：百分比宽度实际使用值 = 四舍五入（计算值）</li>
<li>Chrome Safari Opera：百分比宽度实际使用值 = 取整 （计算值）</li>
</ul>
<ol>
<li>外边距折叠：指毗邻的两个或多个外边距会合并成一个外边距，margin毗邻可以归结为：</li>
</ol>
<ul>
<li>这两个或多个外边距没有被非空内容、padding、border 或 clear 分隔开</li>
<li>这些 margin 都处于普通流中<br><code>注：</code>两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠</li>
<li>参与折叠的 margin 都是正值：<br>在 margin都是正数的情况下，取其中 margin 较大的值为最终 margin 值。</li>
<li>参与折叠的 margin 都是负值：<br>当 margin都是负值的时候，取的是其中绝对值较大的，然后，从 0 位置，负向位移</li>
<li>参与折叠的margin中有正值，有负值：如果，毗邻的 margin 中有正值，同时存在负值会怎样呢？有正有负，先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。</li>
<li><p>相邻的margin要一起参与计算，不得分步计算：要注意，相邻的元素不一定非要是兄弟节点，父子节点也可以，即使不是兄弟父子节点也可以相邻。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;margin:50px 0; background-color:green; width:50px;&quot;&gt;</div><div class="line">    &lt;div style=&quot;margin:-60px 0;&quot;&gt;</div><div class="line">           &lt;div style=&quot;margin:150px 0;&quot;&gt;A&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div style=&quot;margin:-100px 0; background-color:green; width:50px;&quot;&gt;</div><div class="line">    &lt;div style=&quot;margin:-120px 0;&quot;&gt;</div><div class="line">           &lt;div style=&quot;margin:200px 0;&quot;&gt;B&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">-- 错误的计算方式：算 A 和 B 之间的 margin，分别算 A 和其父元素的折叠，然后与其父元素的父元素的折叠，这个值算出来之后，应该是 90px。依此法算出 B 的为 80px；然后，A和B折叠，margin 为 90px。</div><div class="line"></div><div class="line">请注意，多个 margin 相邻折叠成一个 margin，所以计算的时候，应该取所有相关的值一起计算，而不能分开分步来算。</div><div class="line"></div><div class="line">以上例子中，A 和 B 之间的 margin 折叠产生的 margin，是6个相邻 margin 折叠的结果。将其 margin 值分为两组：</div><div class="line"></div><div class="line">* 正值：50px，150px，200px</div><div class="line">* 负值：-60px，-100px，-120px</div><div class="line">根据有正有负时的计算规则，正值的最大值为 200px，负值中绝对值最大的是 -120px，所以，最终折叠后的 margin 应该是 200 + (-120) = 80px。</div></pre></td></tr></table></figure>
</li>
<li><p>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠</p>
</li>
<li>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠</li>
<li>元素自身的 margin-bottom 和 margin-top 相邻时也会折叠:自身 margin-bottom 和 margin-top 相邻，只能是自身内容为空，垂直方向上 border、padding 为 0。</li>
</ul>
<ol>
<li>(Chrome Safari)宽度计算不符合规范:<br>在 WebKit 内核的浏览器中，当元素满足三个条件时，宽度计算不符合规范:</li>
</ol>
<ul>
<li>元素的兄弟元素是浮动元素；</li>
<li>元素的 ‘width’ 特性值为 ‘auto’，’overflow’ 特性值不是 ‘visible’；</li>
<li>元素设置了与浮动同方向的 ‘margin’ 值(如：当 ‘float:left’ 时，设置 ‘margin-left’ 值，当 ‘float:right’ 时，设置 ‘margin-right’)。</li>
</ul>
<ol>
<li>clear:是控制浮动框和常规流的一种位置关系上的平衡:</li>
</ol>
<ul>
<li><code>注意：</code>clear`特性不考虑它自身包含的浮动子元素和不处于同一个块格式化上下文中的浮动元素。<br>对于插入框，该属性适用于插入框所属的最后的块框。</li>
<li><code>注：</code>可以简单的认为设置了 ‘clear’ 特性值的元素，其 top border edge要放在相关的浮动元素的bottom margin edge之下。注意这两种元素接触边界的区别。一个是 border，一个是 margin。（也就是clear元素用border边挨紧浮动元素的margin边，为clear元素设置margin没用，但并不是因为外边距发生重叠产生的，因为浮动元素不会产生外边距重叠）</li>
</ul>
<ol>
<li>Firefox 浏览器对TABLE中绝对定位元素包含块的判定有错误，某些情况下会导致绝对定位元素位置跟其他浏览器中有差异:<br><code>注意：</code>W3C CSS2.1 规范中规定，绝对定位元素的包含块(containing block)，由离它最近的 position 特性值是 “absolute”、”fixed”、”relative” 之一的祖先元素组成；如果这个祖先元素不存在，则包含块由根元素组成。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;Container&quot; style=&quot;width:200px; height:200px; position:absolute; background-color:silver;&quot;&gt;Container</div><div class="line">    &lt;div id=&quot;A&quot; style=&quot;display:table; position:absolute; width:100px; height:100px; top:100px; left:100px;  background-color:green;&quot;&gt;TABLE</div><div class="line">        &lt;div id=&quot;AP&quot; style=&quot; position:absolute; width:50px; height:50px; top:50px; left:50px; background-color: gold;&quot;&gt;</div><div class="line">            TEXT</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">//在Firefox中AP的包含块是container而不是A包含块，</div></pre></td></tr></table></figure>
<p><code>这是 Firefox 的一个 bug，绝对定位元素无法根据 &#39;display&#39; 特性是 &#39;table&#39; 且是绝对定位的祖先元素定位。为达到相同的效果可以改变元素的 containing block 或者改变元素的定位方式。</code></p>
<p>为达到相同的效果，可以采用如下方式替代：</p>
<ul>
<li>改变元素的 containing block：让绝对定位元素相对于 TABLE 元素的单元格定位，即，在 TD 上设置 ‘position:absolute’ ；</li>
<li>改变元素的定位方式：把绝对定位元素的 ‘absolute’ 改为 ‘relative’ ，用相对定位。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你的Promise]]></title>
      <url>http://yoursite.com/2017/03/07/%E4%BD%A0%E7%9A%84Promise/</url>
      <content type="html"><![CDATA[<h1 id="你的Promise"><a href="#你的Promise" class="headerlink" title="你的Promise"></a>你的Promise</h1><p>在JavaScript的世界里，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。<br><code>js中异步编程主要指的是setTimout/setInterval、DOM事件机制、ajax，通过传入回调函数实现控制反转。异步编程为js带来强大灵活性的同时，也带来了嵌套回调的问题。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function callback() &#123;</div><div class="line">    console.log(&apos;Done&apos;);</div><div class="line">&#125;</div><div class="line">console.log(&apos;before setTimeout()&apos;);</div><div class="line">setTimeout(callback, 1000); // 1秒钟后调用callback函数</div><div class="line">console.log(&apos;after setTimeout()&apos;);</div></pre></td></tr></table></figure>
<h2 id="串行执行若干异步"><a href="#串行执行若干异步" class="headerlink" title="串行执行若干异步"></a>串行执行若干异步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function ajax(method,url,data)&#123;</div><div class="line">var request=new XMLHttpRequest();</div><div class="line">return new Promise(function(resolve,reject)&#123;</div><div class="line">		if(request.readyState===4)&#123;</div><div class="line">			if(request.status===200)&#123;</div><div class="line">				resolve(request.responseText);</div><div class="line">			&#125;else&#123;</div><div class="line">			reject(request.status);</div><div class="line">		&#125;</div><div class="line">			&#125;</div><div class="line">		request.open(method,url);</div><div class="line">		request.send(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line">var log=document.getElementById(&quot;div&quot;);</div><div class="line">var p=ajax(&apos;GET&apos;,&apos;/api/categories&apos;);</div><div class="line">p.then(function(text)&#123;</div><div class="line">	log.innerText=text;</div><div class="line">&#125;).catch(function(status)&#123;</div><div class="line">	log.innerText=&apos;ERROR:&apos;+status;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Promise还可以并行执行异步任务"><a href="#Promise还可以并行执行异步任务" class="headerlink" title="Promise还可以并行执行异步任务"></a>Promise还可以并行执行异步任务</h2><ol>
<li>Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例<br>var p=Promise.all([p1,p2,p3]);p1,p2,p3都是Promise对象的实例（Promise.all()参数只要是Iterator接口）分两种状态：</li>
</ol>
<ul>
<li>p1,p2,p3三者都是Fulfilled,p的状态才变成Fulfilled</li>
<li>只要p1,p2,p3中有一个被rejected则p就被rejected</li>
</ul>
<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 500, &apos;P1&apos;);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 600, &apos;P2&apos;);</div><div class="line">&#125;);</div><div class="line">// 同时执行p1和p2，并在它们都完成后执行then:</div><div class="line">Promise.all([p1, p2]).then(function (results) &#123;</div><div class="line">    console.log(results); // 获得一个Array: [&apos;P1&apos;, &apos;P2&apos;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>
</blockquote>
<ol>
<li>Promise.race()方法，<br>var Promise.race([p1,p2,p3]);只要p1，p2,p3有一个实例率先改变状态，p的状态就会跟着改变，并且返回改变的那个实例的返回值就给p的回调函数。(而那些后面的返回值仍在执行，但被丢弃)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 500, &apos;P1&apos;);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 600, &apos;P2&apos;);</div><div class="line">&#125;);</div><div class="line">Promise.race([p1, p2]).then(function (result) &#123;</div><div class="line">    console.log(result); // &apos;P1&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Promise的附加方法"><a href="#Promise的附加方法" class="headerlink" title="Promise的附加方法"></a>Promise的附加方法</h2><ol>
<li>done()<br>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .done();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它的实现代码非常简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</div><div class="line">  this.then(onFulfilled, onRejected)</div><div class="line">    .catch(function (reason) &#123;</div><div class="line">      // 抛出一个全局错误</div><div class="line">      setTimeout(() =&gt; &#123; throw reason &#125;, 0);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li>finally()<br>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。<br>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(0)</div><div class="line">  .then(function () &#123;</div><div class="line">    // run test</div><div class="line">  &#125;)</div><div class="line">  .finally(server.stop);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它的实现也很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = function (callback) &#123;</div><div class="line">  let P = this.constructor;</div><div class="line">  return this.then(</div><div class="line">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS内存泄漏排查方法——Chrome Profiles]]></title>
      <url>http://yoursite.com/2017/03/04/JS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94Chrome%20Profiles/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Google Chrome浏览器提供了非常强大的JS调试工具，Heap Profiling便是其中一个。Heap Profiling可以记录当前的堆内存heap快照，并生成对象的描述文件，该描述文件给出了当时JS运行所用到的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等。这些描述文件为内存泄漏的排查提供了非常有用的信息。</p>
<h2 id="Heap-Profiling"><a href="#Heap-Profiling" class="headerlink" title="Heap Profiling"></a>Heap Profiling</h2><ol>
<li>什么是heap？<br>JS运行的时候，会有栈内存（stack）和堆内存（heap），当我们用new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack里。程序通过stack里的引用找到这个对象。例如var a = [1,2,3];，a是存储在stack里的引用，heap里存储着内容为[1,2,3]的Array对象。</li>
<li>使用<br>打开Chrome浏览器-&gt;按下F12调出调试工具-&gt;点击“Profiles”标签。可以看到下图：<br>[<img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/221623227.jpg" alt="mark">][1]<br>可以看到，该面板可以监控CPU、CSS和内存，选中“Take Heap Snapshot”，点击“Start”按钮，就可以拍下当前JS的heap快照，如下图所示：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/221828288.jpg" alt="mark"><br>右边视图列出了heap里的对象列表。由于游戏大厅使用了Quark游戏库，所以这里可以清楚地看到Quark.XXX之类的类名称（即Function对象的引用名称）。<br>注意：每次拍快照前，都会先自动执行一次GC，所以在视图里的对象都是可及的。<h3 id="视图解释"><a href="#视图解释" class="headerlink" title="视图解释"></a>视图解释</h3></li>
</ol>
<ul>
<li>Constructor — 类名Distance — 估计是对象到根的引用层级距离</li>
<li>Objects Count — 给出了当前有多少个该类的对象</li>
<li>Shallow Size — 对象所占内存（不包含内部引用的其它对象所占的内存）(单位：字节)</li>
<li>Retained Size —对象所占总内存（包含内部引用的其它对象所占的内存）(单位：字节)<br>下面解释一下部分类名称所代表的意思：</li>
<li>(compiled code) — 未知，估计是程序代码区</li>
<li>(closure) — 闭包(array) — 未知</li>
<li>Object — JS对象类型(system) — 未知</li>
<li>(string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里</li>
<li>Array — JS数组类型cls — 游戏大厅特有的继承类</li>
<li>Window — JS的window对象</li>
<li>Quark.DisplayObjectContainer — Quark引擎的显示容器类</li>
<li>Quark.ImageContainer — Quark引擎的图片类</li>
<li>Quark.Text — Quark引擎的文本类</li>
<li>Quark.ToggleButton — Quark引擎的开关按钮类<br>对于cls这个类名，是由于游戏大厅的继承机制里会使用“cls”这个引用名称，指向新建的继承类，所以凡是使用了该继承机制的类实例化出来的对象，都放在这里。例如程序中有一个类ClassA，继承了Quark.Text，则new出来的对象是放在cls里，不是放在Quark.Text里。<h3 id="查看对象内容"><a href="#查看对象内容" class="headerlink" title="查看对象内容"></a>查看对象内容</h3>点击类名左边的三角形，可以看到所有该类的对象。对象后面的“@70035”表示的是该对象的ID（有人会错认为是内存地址，GC执行后，内存地址是会变的，但对象ID不会）。把鼠标停留在某一个对象上，会显示出该对象的内部属性和当时的值。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222202248.jpg" alt="mark"><h3 id="查看对象的引用关系"><a href="#查看对象的引用关系" class="headerlink" title="查看对象的引用关系"></a>查看对象的引用关系</h3>点击其中一个对象，能看到对象的引用层级关系，如下图:<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222307136.jpg" alt="mark"><br>Object’s retaining tree视图显示出了该对象被哪些对象引用了，以及<br>这个引用的名称。图中的这个对象被5个对象引用了，分别是：</li>
<li>一个cls对象的 _txtContent 变量；</li>
<li>一个闭包函数的context变量；</li>
<li>同一个闭包函数的self变量；</li>
<li>一个数组对象的0位置；</li>
<li>一个Quark.Tween对象的target变量。<br>看到context和self这两个引用，可以知道这个Quark.Text对象使用了JS常用的上下文绑定机制，被一个闭包里的变量引用着，相当于该Quark.Text对象多了两个引用，这种情况比较容易出现内存泄漏，如果闭包函数不释放，这个Quark.Text对象也释放不了。<br>展开_textContent，可以看到下一级的引用：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222505619.jpg" alt="mark"><br>把这个树状图反过来看，可以看到，该对象(ID @70035)其中的一条引用链是这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GameListV       _curV       _gameListV    省略...</div><div class="line">                  \         |        /</div><div class="line">                    \       |       /</div><div class="line">                  _noticeWidget</div><div class="line">                           |</div><div class="line">                     _noticeC</div><div class="line">                           |</div><div class="line">                     _noticeV</div><div class="line">                           |</div><div class="line">                  _txtContent</div><div class="line">                           ||</div><div class="line">             Quark.Text @70035</div></pre></td></tr></table></figure>
</li>
</ul>
<p>内存快照的对比通过快照对比的功能，可以知道程序在运行期间哪些对象变更了。<br>刚才已经拍下了一个快照，接下来再拍一次，如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222617807.jpg" alt="mark"><br>点击图中的黑色实心圆圈按钮，即可得到第二个内存快照：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222654359.jpg" alt="mark"><br>然后点击图中的“Snapshot 2”，视图才会切换到第二次拍的快照<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222725528.jpg" alt="mark"><br>点击图中的“Summary”，可弹出一个列表，选择“Comparison”选项，结果如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222840512.jpg" alt="mark"><br>这个视图列出了当前视图与上一个视图的对象差异。列名字段解释：# New — 新建了多少个对象# Deleted — 回收了多少个对象# Delta — 对象变化值，即新建的对象个数减去回收了的对象个数Size Delta — 变化的内存大小(字节)注意Delta字段，尤其是值大于0的对象。下面以Quark.Tween为例子，展开该对象，可看到如下图所示：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222918536.jpg" alt="mark"><br>在“# New”列里，如果有“.”，则表示是新建的对象。<br>在“# Deleted”列里，如果有“.”，则表示是回收了的对象。<br>平时排查问题的时候，应该多拍几次快照进行对比，这样有利于找出其中的规律。</p>
<h2 id="内存泄漏的排查"><a href="#内存泄漏的排查" class="headerlink" title="内存泄漏的排查"></a>内存泄漏的排查</h2><p>JS程序的内存溢出后，会使某一段函数体永远失效（取决于当时的JS代码运行到哪一个函数），通常表现为程序突然卡死或程序出现异常。<br>这时我们就要对该JS程序进行内存泄漏的排查，找出哪些对象所占用的内存没有释放。这些对象通常都是开发者以为释放掉了，但事实上仍被某个闭包引用着，或者放在某个数组里面。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OSI七层网络架构]]></title>
      <url>http://yoursite.com/2017/03/03/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="OSI七层网络架构"><a href="#OSI七层网络架构" class="headerlink" title="OSI七层网络架构"></a>OSI七层网络架构</h2><p>七层模型（OSI，Open System Interconnection参考模型），是参考是国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系。它是一个七层抽象的模型，不仅包括一系列抽象的术语和概念，也包括具体的协议。 经典的描述如下：<br>简述每一层的含义：<br><img src="http://obfnbicau.bkt.clouddn.com/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="Alt text"></p>
<ol>
<li>物理层（Physical Layer）：建立、维护、断开物理连接。</li>
<li>数据链路层 (Link)：逻辑连接、进行硬件地址寻址、差错校验等。</li>
<li>网络层 (Network)：进行逻辑寻址，实现不同网络之间的路径选择。</li>
<li>传输层 (Transport)：定义传输数据的协议端口号，及流控和差错校验。</li>
<li>会话层（Session Layer）：建立、管理、终止会话。</li>
<li>表示层（Presentation Layer）：数据的表示、安全、压缩。</li>
<li>应用层 (Application)：网络服务与最终用户的一个接口<br>每一层利用下一层提供的服务与对等层通信，每一层使用自己的协议。了解了这些，然并卵。但是，这一模型确实是绝大多数网络编程的基础，作为抽象类存在的，而TCP／IP协议栈只是这一模型的一个具体实现。<h2 id="TCP-IP五层网络架构"><a href="#TCP-IP五层网络架构" class="headerlink" title="TCP/IP五层网络架构"></a>TCP/IP五层网络架构</h2>TCP/IP是Internet的基础，是一组协议的代名词，包括许多协议，组成了TCP/IP协议栈。(<strong>里面包括IP协议、ICMP协议、TCP协议。</strong>)TCP／IP 有四层模型和五层模型之说，区别在于数据链路层是否作为独立的一层存在。<br><img src="http://obfnbicau.bkt.clouddn.com/TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88.jpg" alt="Alt text"><br>数据是如何传递呢？这就要了解网络层和传输层的协议，我们熟知的IP包结构是这样的：<br><img src="http://obfnbicau.bkt.clouddn.com/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt="Alt text"><br>IP协议和IP地址是两个不同的概念，这里没有涉及IPV6的。不关注网络安全的话，对这些结构不必耳熟能详的。传输层使用这样的数据包进行传输，传输层又分为面向连接的可靠传输TCP和数据报UDP。TCP的包结构：<br><img src="http://obfnbicau.bkt.clouddn.com/tcp%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt="Alt text"><br>TCP 连接建立的三次握手肯定是必知必会，在系统调优的时候，内核中关于网络的相关参数与这个图息息相关。UDP是一种无连接的传输层协议，提供的是简单不可靠的信息传输。协议结构相对简单，包括源和目标的端口号，长度以及校验和。基于TCP和UDP的数据封装及解析示例如下：<br><img src="http://obfnbicau.bkt.clouddn.com/TCP%E5%92%8CUDP%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85.jpg" alt="Alt text"></li>
</ol>
<h2 id="TCP协议连接、释放过程"><a href="#TCP协议连接、释放过程" class="headerlink" title="TCP协议连接、释放过程"></a>TCP协议连接、释放过程</h2><p>TCP/IP分层：<br><img src="http://obfnbicau.bkt.clouddn.com/tcp-ip%E5%88%86%E5%B1%82.jpg" alt="Alt text"></p>
<ol>
<li>有几个需要注意的知识点：</li>
</ol>
<ul>
<li>互联网地址：也就是IP地址，一般为网络号+子网号+主机号</li>
<li>域名系统：通俗的来说，就是一个数据库，可以将主机名转换成IP地址</li>
<li>RFC：TCP/IP协议的标准文档</li>
<li>端口号：一个逻辑号码，IP包所带有的标记</li>
<li>Socket：应用编程接口</li>
</ul>
<ol>
<li>数据链路层的工作特性：</li>
</ol>
<ul>
<li>为IP模块发送和接收IP数据报</li>
<li>为ARP模块发送ARP请求和接收ARP应答（ARP：地址解析协议，将IP地址转换成MAC地址）</li>
<li>为RARP发送RARP请求和接收RARP应答</li>
</ul>
<ol>
<li>首先我们先来了解TCP报文段<br><img src="http://obfnbicau.bkt.clouddn.com/tcp%E6%8A%A5%E6%96%87%E6%AE%B5.jpg" alt="Alt text"><br>重要的标志我在图中也有标记，重点了解标志位：</li>
</ol>
<ul>
<li>ACK：确认序号有效</li>
<li>RST：重置连接</li>
<li>SYN：发起了一个新连接</li>
<li>FIN：释放一个连接<br><code>三次握手的过程（客户端我们用A表示，服务器端用B表示）</code><br>前提：A主动打开，B被动打开<br><img src="http://obfnbicau.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态</li>
<li>A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态</li>
<li>B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态</li>
<li><p>A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。<br><code>简单来说，</code> 就是:建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认,服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态,客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br><code>四次分手的过程（客户端我们用A表示，服务器端用B表示）</code><br>由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br>前提：A主动关闭，B被动关闭<br><img src="http://obfnbicau.bkt.clouddn.com/%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B.jpg" alt="Alt text"><br>有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？<br>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
</li>
<li><p>A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。</p>
</li>
<li>B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。</li>
<li>B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。</li>
<li>A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序+1，B进入CLOSED状态，完成四次挥手。<br>简单来说就是<br>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。<br>A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？</li>
<li>为了保证A发送的最后一个ACK报文段能够到达B</li>
<li>防止“已失效的连接请求报文段”出现在本连接中<br>OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧<br><code>三次握手流程</code></li>
<li>客户端发个请求“开门呐，我要进来”给服务器</li>
<li>服务器发个“进来吧，我去给你开门”给客户端</li>
<li>客户端有很客气的发个“谢谢，我要进来了”给服务器<br><code>四次挥手流程</code></li>
<li>客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</li>
<li>服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</li>
<li>服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</li>
<li>客户端发个“我知道了，我走了”，之后自己就走了<h2 id="l"><a href="#l" class="headerlink" title="l"></a>l</h2><img src="http://obfnbicau.bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="Alt text"></li>
<li>CLOSED: 表示初始状态。</li>
<li>LISTEN: 表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li>
<li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li>
<li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li>ESTABLISHED:表示连接已经建立了。</li>
<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li>
<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li>
<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>
<li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li>
</ol>
<p>参考链接：<a href="http://blog.jobbole.com/91841/utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="external">http://blog.jobbole.com/91841/utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></p>
<p><a href="http://blog.jobbole.com/110041/" target="_blank" rel="external">http://blog.jobbole.com/110041/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[响应式web设计]]></title>
      <url>http://yoursite.com/2017/03/03/%E5%93%8D%E5%BA%94%E5%BC%8Fweb%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h3 id="什么是响应式web设计"><a href="#什么是响应式web设计" class="headerlink" title="什么是响应式web设计"></a>什么是响应式web设计</h3><p>响应式网页设计（RWD，Responsive Web Design）这个术语，由伊桑·马科特（Ethan<br>Marcotte）提出。将三种已有的开发技巧（弹性网格布局、弹性图片、媒体和媒体查询）整合起来，并命名为响应式网页设计。这个术语还有一堆表示相同意思的其他叫法，如流式设计、弹性布局、塑料布局、流体设计、自适应布局、跨设备设计以及弹性设计<br><img src="http://obfnbicau.bkt.clouddn.com/web%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5.jpg" alt="Alt text"></p>
<h3 id="向下兼容，移动优先"><a href="#向下兼容，移动优先" class="headerlink" title="向下兼容，移动优先"></a>向下兼容，移动优先</h3><p>响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式；我们应当向下兼容、移动优先。<br>首先我们应该遵循移动优先原则，交互&amp;设计应以移动端为主，PC则作为移动端的一个扩展；一个页面需要兼容不同终端，那么有两个关键点是我们需要去做到响应式的：</p>
<ol>
<li>响应式布局</li>
<li>响应式内容（图片、多媒体）</li>
</ol>
<h2 id="桌面浏览器部分"><a href="#桌面浏览器部分" class="headerlink" title="桌面浏览器部分"></a>桌面浏览器部分</h2><ol>
<li>设备像素和CSS像素<br>设备像素其值可以（通常情况下）从screen.width/height属性中读出</li>
</ol>
<ul>
<li>如果你给一个元素设置了width: 128px的属性，并且你的显示器是1024px宽，当你最大化你的浏览器屏幕，这个元素将会在你的显示器上重复显示8次,形式上，元素仍然是128个CSS像素宽，即使它占据了256个设备像素的空间</li>
<li>100%缩放 : 在缩放比例100%的情况下一个CSS像素完全等于一个设备像素。</li>
</ul>
<ol>
<li>屏幕尺寸(screen.width/height)</li>
</ol>
<ul>
<li>意义：用户屏幕的整体大小。</li>
<li>度量单位：设备像素。</li>
<li>浏览器错误：IE8以CSS像素对其进行度量，IE7和IE8模式下都有这个问题。<br><img src="http://obfnbicau.bkt.clouddn.com/screen.width.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>窗口尺寸(window.innerWidth/Height)</li>
</ol>
<ul>
<li>意义：浏览器窗口的整体大小，包括滚动条。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：IE7不支持。Opera以设备像素进行度量<br><img src="http://obfnbicau.bkt.clouddn.com/window.innerWidth.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>滚动距离(window.pageX/YOffset)</li>
</ol>
<ul>
<li>意义：页面滚动的距离。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：无。<br><img src="http://obfnbicau.bkt.clouddn.com/window.pageYOffset.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>度量viewport<br>(document.documentElement.clientWidth/Height)</li>
</ol>
<ul>
<li>意义：Viewport尺寸。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：无。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/viewport.jpg" alt="Alt text"><br>如果你了解DOM，你应该知道document.documentElement实际上指的是<html>元素：即任何HTML文档的根元素。可以说，viewport要比它更高一层；它是包含<html>元素的元素。<br><img src="http://obfnbicau.bkt.clouddn.com/document.documentElement.clientWidth.jpg" alt="Alt text"></html></html></p>
<ol>
<li>度量<html>元素(document.documentElement.offsetWidth/Height)</html></li>
</ol>
<ul>
<li>意义：元素（也就是页面）的尺寸。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：IE度量的是viewport，而不是元素。<br><img src="./document.documentElement.clientWidth.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>事件中的坐标<br>(pageX/Y, clientX/Y, screenX/Y)<br>浏览器错误：IE不支持pageX/Y。IE和Opera以CSS像素为单位计算screenX/Y。</li>
</ol>
<ul>
<li>pageX/Y提供了相对于<html>元素的以CSS像素度量的坐标。<br><img src="http://obfnbicau.bkt.clouddn.com/pageXY.jpg" alt="Alt text"></html></li>
<li>clientX/Y提供了相对于viewport的以CSS像素度量的坐标<br><img src="http://obfnbicau.bkt.clouddn.com/clientXY.jpg" alt="Alt text"></li>
<li>screenX/Y提供了相对于屏幕的以设备像素进行度量的坐标。<br><img src="http://obfnbicau.bkt.clouddn.com/screen.width.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>媒体查询<br>(浏览器错误：IE不支持它们。)</li>
</ol>
<ul>
<li>如果 device-width/height是以CSS像素进行度量的，那么Firefox将会使用screen.width/height的值。</li>
<li>如果width/height是以设备像素进行度量的，那么Safari和Chrome将会使</li>
<li>8.1 documentElement.clientWidth/Height的值。width/height使用和documentElement .clientWidth/Height（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。</li>
<li>8.2 device-width/device-height使用和screen.width/height（换句话说就是屏幕的宽高）一样的值。它工作在设备像素下面。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/media%20query%20width.jpg" alt="Alt text"></p>
<h2 id="移动浏览器部分"><a href="#移动浏览器部分" class="headerlink" title="移动浏览器部分"></a>移动浏览器部分</h2><p>##两个viewport</p>
<h3 id="layout-viewport"><a href="#layout-viewport" class="headerlink" title="layout viewport"></a>layout viewport</h3><p><img src="http://obfnbicau.bkt.clouddn.com/layoutviewport.jpg" alt="Alt text"></p>
<ol>
<li>度量layout viewport<br>我们现在有两个需要度量的viewport。很幸运的是浏览器战争给我们提供了两个属性对。<br>document.documentElement.clientWidth和-Height包含了layout viewport的尺寸。</li>
</ol>
<p>document.documentElement.clientWidth/Height</p>
<ul>
<li>意义：Layout viewport的尺寸</li>
<li>度量单位：CSS像素</li>
<li>完全支持Opera, iPhone, Android, Symbian, Bolt, MicroB, Skyfire, Obigo。</li>
<li>在Iris中Visual viewport有问题</li>
<li>浏览器兼容性问题</li>
</ul>
<p>###visual viewport<br>visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。<br><img src="http://obfnbicau.bkt.clouddn.com/viewport.jpg" alt="Alt text"><br><code>注：</code> 无论怎样，CSS布局，尤其是百分比宽度，是以layout viewport做为参照系来计算的，它被认为要比visual viewport宽。</p>
<ol>
<li>度量visual viewport<br>对于visual viewport，它是通过window.innerWidth/Height来进行度量的。很明显当用户缩小或者放大的时候，度量的尺寸会发生变化，因为屏幕上的CSS像素会增加或者减少。</li>
</ol>
<h3 id="viewport-meta标签（Meta-viewport）"><a href="#viewport-meta标签（Meta-viewport）" class="headerlink" title="viewport meta标签（Meta viewport）"></a>viewport meta标签（Meta viewport）</h3><p><img src="http://obfnbicau.bkt.clouddn.com/Meta%20viewport.jpg" alt="Alt text"></p>
<ul>
<li>意义：设置layout viewport的宽度。</li>
<li>度量单位：CSS像素。</li>
<li>完全支持Opera Mobile，iPhone，Android，Iris，IE，BlackBerry，Obigo。<br>不支持Opera Mini，Symbian，Bolt，Firefox，MicroB，NetFront。</li>
<li>问题：Skyfire不能处理我的测试页面。<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>弹性的栅格布局，不同尺寸下弹性适应，如以下页面中各模块在不同尺寸下的位置：<br><img src="http://obfnbicau.bkt.clouddn.com/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80.jpg" alt="Alt text"></li>
</ul>
<p>栅格框架推荐:</p>
<ul>
<li>Responsive Grid System</li>
<li>Fluid 960 Grid</li>
<li>Simple Grid<h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3></li>
</ul>
<ol>
<li>什么是响应式图片？<br>根据显示器分辨率，提供多个图片源，在页面上图片的尺寸，或者其它参数的一种方法<br>目前最常用的解决方案：</li>
<li><p>css样式<br>此代码使用 max-width:100% 的设置，以确保图像永远不会超越其父容器的宽度。如果父容器的宽度收缩小于图像的宽度，图像将随之缩小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> img &#123;</div><div class="line">    max-width: 100%;</div><div class="line">    height: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>picture是HTML5一个新的元素</p>
</li>
</ol>
<ul>
<li>创建 picture 标签。</li>
<li>在这些标签内创建一个你想用来执行任何一个特性的 source元素。</li>
<li>添加一个 media 属性，用来包含你想要的特性，如视口的当前高度(viewport height)，宽度( width )，方向(orientation)等。</li>
<li>添加一个 srcset 属性与相应的图像文件名相匹配，进行加载。如果你想提供不同的像素密度，例如Retina显示屏，你可以添加额外的文件名到你的 srcset 属性中，</li>
<li>添加一个回退的 img 元素。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/picture.jpg" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">		(function() &#123;</div><div class="line">  var currentSrc, oldSrc, imgEl;</div><div class="line">  var showPicSrc = function() &#123;</div><div class="line">    oldSrc     = currentSrc;</div><div class="line">    imgEl      = document.getElementById(&apos;picimg&apos;);</div><div class="line">    currentSrc = imgEl.currentSrc || imgEl.src;</div><div class="line">    </div><div class="line">    if (typeof oldSrc === &apos;undefined&apos; || oldSrc !== currentSrc) &#123;</div><div class="line">      document.getElementById(&apos;logger&apos;).innerHTML = currentSrc;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // You may wish to debounce resize if you have performance concerns</div><div class="line">  window.addEventListener(&apos;resize&apos;, showPicSrc);</div><div class="line">  window.addEventListener(&apos;load&apos;, showPicSrc);</div><div class="line">&#125;)(window);</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">	&lt;picture&gt;</div><div class="line">  &lt;source media=&quot;(min-width: 650px)&quot; srcset=&quot;images/kitten-large.jpg&quot;&gt;</div><div class="line">  &lt;source media=&quot;(min-width: 465px)&quot; srcset=&quot;images/kitten-medium.jpg&quot;&gt;</div><div class="line">  &lt;!-- img tag for browsers that do not support picture element --&gt;</div><div class="line">  &lt;img src=&quot;images/kitten-small.jpg&quot; id=&quot;picimg&quot;&gt;</div><div class="line"> &lt;/picture&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<ol>
<li>Picturefill<br>其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，例如图片加载失败的替代方案。<br><a href="http://scottjehl.github.io/picturefill/" target="_blank" rel="external">http://scottjehl.github.io/picturefill/</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;picture&gt;</div><div class="line">  &lt;!--[if IE 9]&gt;&lt;video style=&quot;display: none;&quot;&gt;&lt;![endif]--&gt;</div><div class="line">  &lt;source srcset=&quot;images/3.jpg&quot; media=&quot;(min-width: 1000px)&quot;&gt;</div><div class="line">  &lt;source srcset=&quot;images/4.jpg&quot; media=&quot;(min-width: 800px)&quot;&gt;</div><div class="line">  &lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;</div><div class="line">  &lt;img srcset=&quot;images/6.jpg&quot; alt=&quot;…&quot;&gt;</div><div class="line">&lt;/picture&gt;</div><div class="line">显示密度描述:</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot; srcset=&quot;cat.jpg, cat-2X.jpg 2x&quot;&gt;</div><div class="line">宽度描述符:</div><div class="line">当图片开始下载时浏览器知道的只有视窗尺寸</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot;  srcset=&quot;cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w&quot;&gt;</div><div class="line">浏览器如何选择正确的sizes:</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot;</div><div class="line">  srcset=&quot;cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w&quot;</div><div class="line">  sizes=&quot;(max-width: 480px) 100vw, (max-width: 900px) 33vw, 254px&quot;&gt;</div><div class="line">Srcset和sizes ＝ 智能浏览器</div></pre></td></tr></table></figure>
<ol>
<li>在一些场景下单独用img可能就够了：</li>
</ol>
<ul>
<li>固定宽度，单一分辨率网页:如果你没有用响应式设计并且不用担心”retina”屏幕，img元素就够了</li>
<li>文件尺寸差别很小:对于有些图片，最大版本和最小版本的尺寸没有很大区别。常见的有logo，图标和其他不需要根据视窗变化的小图片。如果文件尺寸没什么区别，一张图片可能就够了</li>
<li>使用基于矢量的图片例如SVG:如果使用基于矢量的图片格式例如SVG，图片可以自由缩放并不需要多张图片。在这种情况下，可以直接用SVG做为img的图片源。<h3 id="逐渐增强与优雅降级"><a href="#逐渐增强与优雅降级" class="headerlink" title="逐渐增强与优雅降级"></a>逐渐增强与优雅降级</h3></li>
<li>优雅降级：指的是为现代浏览器制作网站，然后保证为某些老版本浏览器提供基本可用的体验。新特性在老版本浏览器中会降级，且一般会有一个分界点，声明不支持那些老掉牙的浏览器。有些时候用户也仅会被警告他们所使用的浏览器有问题，建议其更换</li>
<li>逐渐增强：渐进增强以恪守 Web标准的标签为基础，意味着它在所有浏览器中均可用。然后通过 CSS 样式和必要的 JavaScript 来为更先进的浏览器提供渐进式的增强体验。<h3 id="JavaScript中的shim与polyfill是？"><a href="#JavaScript中的shim与polyfill是？" class="headerlink" title="JavaScript中的shim与polyfill是？"></a>JavaScript中的shim与polyfill是？</h3></li>
<li>shim是指一个库，它将一个新的API引入到一个旧的环境当中，而且仅靠旧的环境中已有的手段实现</li>
<li>一个polyfill就是一个用浏览器API上的shim</li>
<li>我们通常的做法：先检查当前浏览器是否支持某个API，如果<br>不支持的话，就加载对应的polyfill，然后新旧的浏览器就可以使用这个API了</li>
<li>区别：polyfill是shim的一种，<br>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；polyfill 特指 shim 成的 api是遵循标准的，其典型做法是在IE浏览器中增加window.XMLHttpRequest，内部实现使用ActiveXObject。在实际中为了方便做对比，会特指shim的api不是遵循标准的，而是自己设计的。</li>
<li>使用Modernizr检查HTML5和css3浏览器支持功能。<br>Modernizr是一个用于检测浏览器功能的开源JavaScript库。<br><code>注意：</code>Modernizr并不是试图添加老版本浏览器不支持的功能，而是令你通过创建可选风格配置来修改页面设计。它可以通过加载定制的脚本来模拟老版本浏览器不支持的功能。’</li>
</ul>
<p>参考链接：<br>                    <a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="external">http://www.quirksmode.org/mobile/viewports2.html</a><br>                    <a href="http://isux.tencent.com/responsive-web-design.html" target="_blank" rel="external">http://isux.tencent.com/responsive-web-design.html</a><br>                    <a href="http://www.berkeley.edu/" target="_blank" rel="external">http://www.berkeley.edu/</a><br>参考书籍：《响应式web设计》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSON]]></title>
      <url>http://yoursite.com/2016/09/23/JSON%EF%BC%88JavaScript%20Object%20Notation%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h1><p>JSON是JavaScript的一个严格子集，利用一些JavaScript中的一些模式来表示结构化数据，<br><code>注意：</code></p>
<ol>
<li>它是一种数据格式，不是一种编程语言</li>
<li>它并不属于JavaScript，很多编程语言都有应用到它，有针对Json的解析器和序列化器<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2></li>
<li>简单值：使用与js相同的语法，在json中表示，字符串，数值，布尔值，null，但不支持undefined</li>
<li>对象：复杂数据类型，表示的是一组无序的键值对，键值对中可以使简单值，也可以是复杂数据类型</li>
<li><p>数组：复杂数据类型，表示一组有序值的列表，可以通过数组索引来访问其中的值，数组值，可以是简单值，对象，数组<br><code>注意：</code>json不支持变量，函数，对象实例，它就是一种表示结构化数据的格式</p>
<h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p><code>注意：</code>js字符串与json的最大区别：json字符串必须使用双引号（单引号将导致语法错误）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p> js中对象字面量：<br> var person={</p>
<pre><code>name:&quot;Lili&quot;,
age:29
</code></pre><p> }；<br> 或者<br> var Object={</p>
<pre><code>name:&quot;Lili&quot;,
age:29
</code></pre><p> };<br> json中对象表示：<br> {</p>
<pre><code> &quot;name&quot;:&quot;Lili&quot;,
&quot;age&quot;:29
</code></pre><p> }<br><code>两者的区别：</code></p>
<ol>
<li>json对象中没有声明变量的概念</li>
<li>json对象中没有末尾的分号</li>
<li>对象属性必须加上双引号</li>
<li><p>同一个对象中绝对不应该出现两个同名属性</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>js中数组：<br>var values=[25,”h1”,true];<br>json中的数组：<br>[25,”h1”,true]</p>
</li>
</ol>
</li>
</ol>
<p><code>两者的而区别：</code>json数组没有变量和分号</p>
<h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><ol>
<li>eval()函数可以解析，解释并返回js对象和数组</li>
<li>json对象有两个方法：stringify()和parse()<br>stringify()用于把json对象序列化为json字符串<br>parse()用于把字符串解析为原生的js值<br><code>注意：</code></li>
<li>默认情况下，JSON.stringify()输出的字符串不包括任何空格字符或缩进</li>
<li>如过传给JSON.parse()不是有效的json，该方法会报错<h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3>JSON.stringify(序列化对象，过滤器，选项)<br>过滤器：可以使数组，可以是函数<br>选项：表示是否在json中保留缩进</li>
<li><p>过滤结果<br> 过滤器为数组：</p>
<p> var book={</p>
<pre><code>&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 };
var jsonText=JSON.stringify(book,[&quot;title&quot;,&quot;edition&quot;]);
</code></pre><p>过滤器为函数：</p>
</li>
</ol>
<pre><code>var book={
    &quot;title&quot;:&quot;javaScript&quot;;
    &quot;authors&quot;:
    [
    &quot;Hellen&quot;
    ],
    edition:3,
    year:2011 };
    var jsonText=JSON.stringify(book,function(key,value){
    switch(key){
    case &quot;authors&quot;:
    return value.join(&quot;,&quot;);
    case &quot;year&quot;:
    return 5000;
    case &quot;edition&quot;:
    return undefined;
    default:
    return value;
    }
    });
</code></pre><ol>
<li>字符串缩进<br>JSON.stringify()方法的而第三个参数用于结果中的缩进和空白符，如果这个参数是一个数值，那它表示每个级别缩进的空格数<br>var jsonText=JSON.stringify(book,null,4);<br><code>注意：</code> </li>
</ol>
<ul>
<li>只要传入有效的缩进参数，结果字符串就会包含换行符，</li>
<li>最大缩进的而空格数为10，所有大于10的数值都会自动转换为10<br>缩进参数</li>
<li>缩进参数可以为非数值（制表符，两个短横线等任意字符）</li>
</ul>
<ol>
<li>toJSON()方法<br>可以给任何对象添加 toJSON()方法,返回自身的JSON数据格式</li>
</ol>
<pre><code> var book={
&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 
toJSON:function(){
return this.title;
}
};
var jsonText=JSON.stringify(book);
</code></pre><ol>
<li><p>序列化的内部顺序：<br>假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下：<br>（1）如果存在toJSON()而且能通过它取得有效值，则调用该方法，否则返回对象本身<br>（2）如果提供第二个参数，应用这个函数过滤器。传入函数过滤器的值是第（1）步返回的值<br>（3）对第（2）步返回的每一个值进行相应的序列化<br>（4）如果提供第三个参数，执行相应的格式化</p>
<h2 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h2><p>JSON.stringify()方法接收的函数（称替换或过滤函数）<br>JSON.parse()方法可以接收另一个参数（称还原函数）</p>
<p> var book={</p>
<pre><code>&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 
releaseDate:new Date(2011,11,1)
};
var jsonText=JSON.stringify(book);
var bookCopy=JSON.parse(jsonText,function(key,value){
if(key==&quot;releaseDate&quot;){
return new Date(value);
}else{
return vlaue;
}
});
console.log(bookCopy.releaseDate.getFullYear());
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[this的指向问题]]></title>
      <url>http://yoursite.com/2016/09/22/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h1><ol>
<li>若果一个函数中有this，但是它没有被上级对象所调用，那么this的指向是window<br>(在js不是严格型的情况下)</li>
<li>若一个函数中有this，这个函数有被上一 级对象所调用，那么this的指向就是上一级<br>对象</li>
<li>若一个函数中有this，这个函数中包含多个对象，尽管这个函数是被外层的对象所调用，this的指向也只是它上一级的对象。<blockquote>
<p>知识点补充：</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>在严格版中的默认的this不再是window，而是undefined。</p>
</li>
<li><p>new操作符会改变函数this的指向问题，虽然我们上面讲解过了，但是并没有深入的讨论这个问题，网上也很少说，所以在这里有必要说一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">//this最终指向的是调用它的对象</div><div class="line">function a()&#123;</div><div class="line">	var user=&quot;陈&quot;;</div><div class="line">	console.log(this.user);//undefinded</div><div class="line">	console.log(this);//window</div><div class="line">&#125;</div><div class="line">a();//window对象在调用他</div><div class="line"></div><div class="line">//证明上述观点</div><div class="line">function a()&#123;</div><div class="line">	var user=&quot;陈&quot;;</div><div class="line">	console.log(this.user);//undefined</div><div class="line">	console.log(this);//window</div><div class="line">&#125;</div><div class="line">window.a();</div><div class="line"></div><div class="line">//this的指向在函数创建的时候是决定不了的，在调用的时候才能决定</div><div class="line">var o=&#123;</div><div class="line">	user:&quot;陈&quot;,</div><div class="line">	fn:function()&#123;</div><div class="line">		console.log(this.user);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">o.fn();//陈</div><div class="line"></div><div class="line">//与上面例子作比较</div><div class="line">var o=&#123;</div><div class="line">	user:&quot;陈&quot;,</div><div class="line">	fn:function()&#123;</div><div class="line">		console.log(this.user);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">window.o.fn();//陈</div><div class="line">//this对象的指向问题</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//12</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">o.b.fn();</div><div class="line">//直接调用它的内层对象</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		//a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">o.b.fn();//undefined</div><div class="line">//特殊情况</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//undefined</div><div class="line">			console.log(this);//window</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var j=o.b.fn;</div><div class="line">j();//注意this的指向是最后调用它的 对象，也就是看它执行的时候是谁调用的</div><div class="line">//证明上述观点</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//undefined</div><div class="line">			console.log(this);//window</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var j=o.b.fn;</div><div class="line">window.j();</div><div class="line"></div><div class="line">//构造函数版的this</div><div class="line">function Fn()&#123;</div><div class="line">	this.user=&quot;陈&quot;;</div><div class="line">&#125;</div><div class="line">var a=new Fn();</div><div class="line">//a是new出来的一个对象实例</div><div class="line">console.log(a.user);//陈</div><div class="line"></div><div class="line">//当this碰到return的时候</div><div class="line">function fn()&#123;</div><div class="line">	this.user=&quot;陈&quot;;</div><div class="line">	return &#123;&#125;;</div><div class="line">&#125;</div><div class="line">var a=new fn;</div><div class="line">console.log(a.user);//undefined</div><div class="line">//再看一个</div><div class="line">function fn()&#123;</div><div class="line">	this.user=&apos;陈&apos;;</div><div class="line">	return function()&#123;&#125;;</div><div class="line">&#125;</div><div class="line">var a=new fn;</div><div class="line">console.log(a.user);//undefined</div><div class="line">//返回数字</div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div><div class="line">//返回undefined</div><div class="line"></div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return undefined;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div><div class="line">// 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</div><div class="line">//还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，</div><div class="line">//因为null比较特殊</div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>http://yoursite.com/2016/09/20/jQuery/</url>
      <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.1.0.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			alert(&quot;hello world!&quot;);</div><div class="line">		&#125;);</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			alert(&quot;哇!&quot;);</div><div class="line">		&#125;);</div><div class="line">		$(function()&#123;</div><div class="line">			alert(&quot;哇哦!&quot;);</div><div class="line">		&#125;);</div><div class="line">	&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>##jQuery代码风格</p>
<ol>
<li>链式操作风格</li>
</ol>
<ul>
<li>对于 同一个对象不超过3个操作，可以直接写成一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;li&quot;).show().unbind(&quot;click&quot;);</div></pre></td></tr></table></figure>
<ul>
<li><p>对于同一个对象的较多操作，建议每行写一个操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).removeClass(&quot;mouseout&quot;)</div><div class="line"> .addClass(&quot;mouseover&quot;)</div><div class="line"> .stop()</div><div class="line"> .fadeTo(&quot;fast&quot;.0.6)</div><div class="line"> .fadeTo(&quot;fast&quot;.1)</div></pre></td></tr></table></figure>
</li>
<li><p>对于多个对象的少量操作，每个对象写一行，如果涉及子元素，可以考虑适当缩进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(this).addClass(&quot;highlight&quot;)</div><div class="line">	.children(&quot;li&quot;).show().end()</div><div class="line">.siblings().removeClass(&quot;highlight&quot;)</div><div class="line">	.children(&quot;li&quot;).hide();</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>为代码添加注释<br>##jQuery对象和DOM对象</li>
<li>DOM对象<br>通过js中的getElementsByTagName或者，getElementById来获取元素节点，像这样的到的就是DOM对象</li>
<li>jQuery对象<br>jQuery对象就是通过jQuery包装DOM对象后产生的对象，jQuery对象是jQuery独有的，如果一个对象是jQuery对象，那么就可以使用jQuery里面的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&quot;#foo&quot;).html();</div><div class="line">等价于</div><div class="line">document.getElementById(&quot;foo&quot;).innerHTML</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>`注意：</code></p>
<ul>
<li>在jQuery对象中无法使用DOM对象的任何方法如：$(#id).innerHTML(错误)</li>
<li>DOM对象也不能使用jQuery里面的方法<br>如：document.getElementById(“id”).html()(错误)<br>###jQuery对象和DOM对象的相互转换</li>
</ul>
<ol>
<li>定义变量的风格</li>
</ol>
<ul>
<li>jQuery对象<br>var  $variable=jQuery对象（在变量前面加上$）</li>
<li>DOM对象<br>var variable=DOM对象</li>
</ul>
<ol>
<li>jQuery对象转化成DOM对象<br>（1）jQuery对象那个是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $cr=$(&quot;#cr&quot;);//jQuery对象</div><div class="line">var cr=$cr[0];//DOM对象</div><div class="line">alert(cr.checked);</div><div class="line">//检测这个checkbox是否被选中了</div></pre></td></tr></table></figure>
</li>
</ol>
<p>（2）还可以通过jQuery本身提供的，通过get(index)方法得到相应的DOM对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $cr=$(&quot;#cr&quot;);//jQuery对象</div><div class="line">var cr=$cr.get(0);//DOM对象</div><div class="line">alert(cr.checked);</div><div class="line">//检测这个checkbox是否被选中了</div></pre></td></tr></table></figure></p>
<ol>
<li>DOM对象转成jQuery对象<br>对于一个DOM对象，只要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。方式为：$(DOM对象)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var cr=document.getElementById(&quot;cr&quot;);</div><div class="line">//DOM对象</div><div class="line">var $cr=$(cr);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>注意：</code></p>
<ul>
<li>转换后可以任意使用jQuery中方法</li>
<li>平时用到的jQuery对象都是通过$ ()函数制造出来的，$ ()函数就是一个jQuery对象的制造厂<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;</div><div class="line">			var $cr=$(&quot;#cr&quot;);</div><div class="line">			var cr=$cr[0];</div><div class="line">			$cr.click(function()&#123;</div><div class="line">				if(cr.checked)&#123;</div><div class="line">					alert(&quot;感谢你的支持！你可以继续操作了！&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">//换成jQuery对象完成</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			var $cr=$(&quot;#cr&quot;);</div><div class="line">			$cr.click(function()&#123;</div><div class="line">				if($cr.is(&quot;:checked&quot;))&#123;</div><div class="line">					alert(&quot;感谢你的支持！你可以继续操作了1！&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##解决jQuery与其他库的冲突<br><code>注意：</code>默认情况下，jQuery用$作为自身的快捷方式</p>
<ol>
<li>jQuery库在其他库之后导入<br>在其他库和jQuery库被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权转移给其他js库。</li>
<li>如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作，同时，可以使用$()方法作为其他库的快捷方式。这里无需jQuery.noConflict()函数。<br>##jQuery选择器</li>
<li>css选择器</li>
<li><p>jQuery选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">		$(&quot;.demo&quot;).click(function()&#123;</div><div class="line">			alert(&quot;jQuery选择器&quot;);</div><div class="line">		&#125;)</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;p class=&quot;demo&quot;&gt;jQuery Demo&lt;/p&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>jQuery选择器的优势</p>
</li>
</ol>
<ul>
<li>$()函数在很多js类库中都被作为一个选择器来使用。$(“#ID”)用来代替document.getElementById()函数。</li>
<li>支持css1到css3选择器</li>
<li>完善的处理机制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if(document.getElementById(&quot;tt&quot;))&#123;</div><div class="line">			document.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">------------------</div><div class="line"></div><div class="line">		$(&apos;#tt&apos;).css(&quot;color&quot;,&quot;red&quot;);</div><div class="line">//这里无需判断$(&apos;#tt&apos;)是否存在</div></pre></td></tr></table></figure>
<p><code>注意：</code>$(“#tt”)获取的永远是对象，即使网页没有此元素。因此当要用jQuery检查某个元素在网页上是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if($(&quot;#tt&quot;))&#123;</div><div class="line">//错误</div><div class="line">&#125;</div><div class="line">应该用获取到元素的长度来判断。</div><div class="line">if($(&quot;#tt&quot;).length&gt;0)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">或者转化成DOM对象来判断</div><div class="line">if($(&quot;#tt&quot;)[0])&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>jQuery基本选择器<br>它通过元素id,class和标签名等来查找DOM元素</li>
</ol>
<p><img src="http://obfnbicau.bkt.clouddn.com/jQuery%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8.PNG" alt="Alt text"></p>
<ol>
<li><p>层次选择器<br>通过DOM元素之间的层次关系来获取特定元素。如：后代元素，子元素，相邻元素和同辈元素。<br>可以使用next()方法来替代$(‘prev+next’)选择器<br>$(‘.one+div’)等价于$(“.one”).next(“div”)<br>$(“#prev~siblings”)等价于$(“#prev”).nextAll(“div”)<br><img src="http://obfnbicau.bkt.clouddn.com/jQuery%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8.PNG" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//选取#prev之后的所有同辈div元素</div><div class="line">$(&quot;#prev~div&quot;).css(&quot;background&quot;,&quot;#eee&quot;);</div><div class="line">//同上</div><div class="line">$(&quot;#prev&quot;).nextAll(&quot;div&quot;).css(&quot;background&quot;,&quot;eee&quot;);</div><div class="line">//选取#prev所有的同辈div,无论前后位置</div></pre></td></tr></table></figure>
</li>
<li><p>过滤选择器<br>基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器<br>:has(selector)选取含有选择器所匹配的元素的元素。$(“div:has(p)”)选取含有</p><p>元素的<div>元素</div></p>
</li>
</ol>
<ul>
<li>基本过滤</li>
<li>内容过滤</li>
<li>可见性过滤</li>
<li>属性过滤</li>
<li>子元素过滤</li>
<li>表单对象属性过滤选择器<h2 id="选择器中含有特殊的符号的注意事项"><a href="#选择器中含有特殊的符号的注意事项" class="headerlink" title="选择器中含有特殊的符号的注意事项"></a>选择器中含有特殊的符号的注意事项</h2></li>
</ul>
<ol>
<li><p>选择器中含有”.”  ,”#”  ,”(“ ,”]”等特殊的字符<br>直接使用会出错，应该使用转义符转义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;id#b&quot;&gt;bbb&lt;/div&gt;</div><div class="line">&lt;div id=&quot;id[1]&quot;&gt;ccc&lt;/div&gt;</div><div class="line">普通方式获取：</div><div class="line">$(&quot;#id#b&quot;);</div><div class="line">$(&quot;#id[1]&quot;)</div><div class="line">以上错误</div><div class="line"></div><div class="line">$(&quot;#id\\#b&quot;);</div><div class="line">$(&quot;#id\\[1\\]&quot;);</div><div class="line">以上正确</div></pre></td></tr></table></figure>
</li>
<li><p>属性选择器的@符号问题<br>jQuery在1.3.1版本中彻底放弃了1.1.0版本遗留下来的@符号，如果使用1.3.1以上版本，则不需要在属性签添加@符号<br>如：<br>$(“div[@title=’test’]”);<br>正确写法是去除@符号<br>$(“div[title=’test’]”);</p>
</li>
<li>选择器中含有空格的注意事项<br>多一个空格或者少一个空格也许会得到截然不同的结果。</li>
</ol>
<p>filter(expr):筛选出与指定表达式匹配的元素集合，其中expr可以是多个选择器的组合。<br>与find()的区别：find()会在匀速内寻找匹配的元素，而filter()则是筛选元素。一个是对它的子集操作，一个是对自身集合元素进行筛选。</p>
<p>##jQuery其他选择器</p>
<ol>
<li>jQuery提供的选择器扩展</li>
</ol>
<ul>
<li>MoreSelectors for jQuery</li>
<li>Basic XPath</li>
</ul>
<ol>
<li>其他使用css选择器的方法</li>
</ol>
<ul>
<li>document.getElementBySelector()</li>
<li>cssQuery()</li>
<li>querySelectorAll()<br>##jQuery中的DOM操作</li>
</ul>
<p>DOM是一种与浏览器，平台，语言无关的接口，使用该接口可以轻松的访问页面中所有的而标准组件。</p>
<p>###DOM操作分类</p>
<ol>
<li>DOM Core(核心)<br>它并不专属于js</li>
<li>HTML-DOM</li>
<li>CSS-DOM<h3 id="jQuery中的DOM操作"><a href="#jQuery中的DOM操作" class="headerlink" title="jQuery中的DOM操作"></a>jQuery中的DOM操作</h3>一. 查找节点</li>
<li><p>查找元素节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var $li=$(&quot;ul li:eq(1)&quot;);</div><div class="line">//获取&lt;ul&gt;里面的第2个&lt;li&gt;节点</div><div class="line">var li_txt=$li.text();</div><div class="line">//获取元素节点的文本内容</div><div class="line">console.log(li_txt);</div></pre></td></tr></table></figure>
</li>
<li><p>查找属性节点<br>attr()方法：当参数是一个时，则是要查找的属性的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var $para=$(&quot;p&quot;);</div><div class="line">var p_txt=$para.attr(&quot;title&quot;);</div><div class="line">console.log(p_txt);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>二. 创建节点</p>
<ol>
<li>创建元素节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>注意：</code></p>
<ul>
<li>动态的创建的的新元素节点不会被自动添加到文档中，而是要用方法插入到文档中</li>
<li>可以用 $(“&lt; /p&gt;”)或者 $(“&lt; p&gt; &lt; /p&gt;”)不能使用$(“<p>“)或者$(“&lt;  /P&gt;”)</p></li>
</ul>
<ol>
<li><p>创建文本节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div></pre></td></tr></table></figure>
</li>
<li><p>创建属性节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li title=&quot;标题1&quot;&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li title=&quot;标题2&quot;&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div><div class="line">``` </div><div class="line">三.插入节点</div><div class="line">各种方法</div><div class="line">* append()/appendTo()</div><div class="line">* prepend()/prependTo()</div><div class="line">* after()/insertAfter()</div><div class="line">* before()/insertBefore()</div><div class="line">四. 删除节点</div><div class="line">1. remove()方法</div><div class="line">作用：是从DOM中删除所有匹配的元素，传入的参数是用于根据jQuery表达式来筛选元素</div></pre></td></tr></table></figure>
</li>
</ol>
<p>$(“ul li:eq(1)”).remove();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`注意:`当某个节点用remove()删除后，该节点所包含的所有后代节点将同时被删除，这个方法的``返回值是一个指向已被删除节点的引用`</div></pre></td></tr></table></figure></p>
<p>var $li=$(“ul li:eq(1)”).remove();<br>//将第2个<li>从网页中删除<br>$li.appendTo(“ul”);<br>//把刚才删除的节点又重新添加到<ul>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以使用appendTo()的特性来简化以上代码</div></pre></td></tr></table></figure></ul></li></p>
<p>$(“ul li:eq(1)”).appendTo(“ul”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">remove()方法可以通过传递参数来选择性的删除元素</div></pre></td></tr></table></figure></p>
<p>$(“ul li”).remove(“li[title!=菠萝]”);<br>//删除title不为菠萝的li<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. detach()方法</div><div class="line">与remove()的区别：detach()不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同，所有绑定的事件，附加的数据等都会保留下来</div></pre></td></tr></table></figure></p>
<p>var $li=$(“ul li:eq(1)”).detach();<br>//将第2个<li>从网页中删除<br>$li.appendTo(“ul”);<br>//重新追加此元素，发现它之前的绑定的事件还在，如果使用remove（），那么它之前的绑定事件将失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. empty()方法</div><div class="line">严格来讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点。</div></pre></td></tr></table></figure></li></p>
<p>$(“ul li:eq(1)”).empty();<br>//清空第2个li里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">五.复制节点</div><div class="line">clone()方法</div><div class="line">在其中传入true，它的含义是复制元素的同时复制元素中所绑定的事件。因此该元素的副本也同样具有复制功能</div></pre></td></tr></table></figure></p>
<p>$(“ul li”).click(function(){<br>    $(this).clone().appendTo(“ul”)</p>
<p>});</p>
<p>$(this).clone(true).appendTo(“body”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">六.替换节点</div><div class="line">1. replaceWith()</div><div class="line">作用：是将所有匹配的元素替换成指定的HTML或者DOM元素。</div></pre></td></tr></table></figure>
<p>哈哈</p><br>$(“p”).replaceWith(“<strong>嗯嗯</strong>“);<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. replaceAll()</div><div class="line">作用与replaceWith()一样，只是颠倒了操作</div></pre></td></tr></table></figure><br><br>$(“<strong>嗯嗯</strong>“).replaceAll(“p”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">`注意：`如果在替换之前，已经为元素绑定了事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定事件</div><div class="line">七. 包裹节点</div><div class="line">1. wrap()方法：对于需要在文档中插入额外的结构化标记非常有用，而且它不会破坏原始文档的语义。</div></pre></td></tr></table></figure><br><br>$(“strong”).wrap(“<b></b>“);<br>得到如下：<br><b><strong></strong></b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. wrapAll()方法</div><div class="line">该方法是将所有匹配的元素用一个元素来包裹起来。</div></pre></td></tr></table></figure><br><br>wrap():<br>$(“strong”).wrap(“<b></b>“);<br>得到如下：<br><b><strong>1111</strong></b><br><b><strong>2222</strong></b><br>wrapAll():<br>$(“strong”).wrapAll(“<b></b>“);<br>得到如下：<br><b><br><strong>1111</strong><br><strong>2222</strong><br></b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">`注意：`如果被包裹的多个元素间有其他元素，其他元素会被放在包裹元素之后</div><div class="line">3. wrapInner()方法</div><div class="line">该方法将每一个匹配的元素的子内容（包括文本节点）用其他结构化的标记包裹起来。</div></pre></td></tr></table></figure><br><br>$(“strong”).wrapInner(“<b></b>“);<br>结果如下：<br><strong title="选择你喜欢的水果"><b>你喜欢的水果是？</b></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 属性操作</div><div class="line">1. 获取属性和设置属性</div></pre></td></tr></table></figure><br><br>获取属性：<br>var $para=$(“p”);<br>var p_txt=$para.attr(“title”);<br>设置属性：(注意传递两个参数)<br>$(“p”).attr({“title”:”your title”,”name”:”test”});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`注意：`jQuery中有很多的方法都是一个函数同时实现获取和设置的功能（只是传入的参数不同而已）如：html(),text(),height(),width(),val()和css()方法。</div><div class="line">2. 删除属性</div></pre></td></tr></table></figure><br><br>$(“p”).removeAttr(“title”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(jQuery1.6中新增prop()和removeProp()方法)</div><div class="line">### 样式操作</div><div class="line">1. 获取样式和设置样式</div></pre></td></tr></table></figure><br><br><p class="myClass" title="你最喜欢的水果"></p><br>$(“p”).attr(“class”,”high”);<br>变为：<br><p class="high" title="你最喜欢的水果"></p>

<p>追加class用addCalss()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 追加样式</div><div class="line">addClass()方法</div></pre></td></tr></table></figure></p>
<p>$(“p”).addClass(“another”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 移除样式</div></pre></td></tr></table></figure>
<p>删除class=”high”<br>$(“p”).removeClass(“high”);<br>删除多个class<br>$(“p”).removeClass(“high another”);<br>删除全部class<br>$(“p”).removeClass();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">4. 切换样式</div><div class="line">* toggle()方法主要是控制行为上的重复切换</div><div class="line">* toggleClass()方法控制样式上的重复切换，如果类名存在则删除它，不在，就添加它</div></pre></td></tr></table></figure>
<p>$(“p”).toggleClass(“another”)<br>原样式与另一样式之间进行切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">5. 判断是否含有某个样式</div><div class="line">hasClass()可以用来判断元素中是否含有某个class</div><div class="line">，如果有则返回true，否则返回false</div><div class="line">`注意：`hasClass()是为了增强代码可读性而产生的，在jQuery内部实际上调用is()方法完成的。</div><div class="line"></div><div class="line">###设置和获取HTML，文本和值</div><div class="line">1. html()方法</div><div class="line">类似JavaScript中的innerHTML方法，可以用来读取或者设置某个元素中的HTML内容</div><div class="line">2. text()方法</div><div class="line">类似与JavaScript中的innerText属性，可以用来读取或者设置某个元素中的文本内容。</div><div class="line">3. val()方法</div><div class="line">类似JavaScript中的value属性，可以用来设置和获取元素的值。无论元素是文本框，下拉列表还是单选框。它都可以返回元素的值。如果元素为多选，则返回一个包含所有选择的值的数组。</div><div class="line">this指向当前的“文本框”，this.defaultValue就是当前“文本框”的默认值</div><div class="line">还有一种用法：</div><div class="line">它能使select，checkbox，radio相应的选项被选中。</div></pre></td></tr></table></figure></p>
<p>$(“single”).val(“选择2号”);<br>$(“#multiple”).val([“选择2号”,”选择3号”);<br>$(“:checkbox”).val([“check2”,”check3”]);<br>$(“:radio”).val([“radio”]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">###遍历节点</div><div class="line">1. children()方法，只考虑子元素而不考虑其他后代元素</div><div class="line">2. next()方法</div><div class="line">用于取得匹配元素后面紧邻的同辈元素</div><div class="line">3. prev()方法</div><div class="line">用于取得匹配元素前面紧邻的同辈元素</div><div class="line">4. siblings()方法</div><div class="line">该方法用于取得匹配元素前后所有的同辈元素</div><div class="line">5. closest()</div><div class="line">该方法用于取得最近的匹配的元素，首先检查当前元素是否匹配，如果匹配则返回元素本身。如果不匹配则向上查找父级，逐级向上直到找到匹配的选择器的元素，若什么都没找到，则返回一个jQuery空对象。</div><div class="line">6. parent(),parents(),closest()的区别</div><div class="line">## CSS-DOM操作</div><div class="line">css()方法设置和获取样式</div><div class="line">`注意：`</div><div class="line">* 如果值是数字，将会被自动转化为像素值</div><div class="line">* 在css()方法中，如果属相中带有&quot;-&quot;符号，</div><div class="line">例如：font-size和background-color属性</div><div class="line">如果在设置这些属性的值的时候不带引号，那么就要用驼峰式写法，例如：</div><div class="line">$(&quot;p&quot;).css(&#123;fontSize:&quot;30px&quot;,backgroundColor:&quot;#888&quot;&#125;)</div><div class="line">1. height()方法</div><div class="line">2. width()方法</div></pre></td></tr></table></figure></p>
<p>$(“p”).width();<br>//获取</p><p>元素的宽度值<br>$(“p”).width(“400px”);<br>//设置</p><p>元素的宽度值为400px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. offset()方法</div><div class="line">获取元素在当前视窗的相对偏移，其中返回的对象包含两个属性，即top和left，它只对可见元素有效。</div></pre></td></tr></table></figure></p>
<p>var offset=$(“p”).offset();<br>var left=offset.left;<br>vat top=offset.top;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2. position()方法</div><div class="line">它的作用是获取元素相对于最近一个position样式属性设置为relative或者absolute的祖父节点的相对偏移。与offset()一样，它返回的对象（top和left）</div><div class="line">3. scrollTop()方法和scrollLeft()方法</div><div class="line">可以为这两个方法指定一个参数，控制元素的滚动到指定的位置。</div></pre></td></tr></table></figure></p>
<p>var $p=$(“p”);<br>var scrollTop=$p.scrollTop();<br>var scrollLeft=$p.scrollLeft();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">##jQuery中的事件和动画</div><div class="line">###jQuery中的事件</div><div class="line">1. 加载DOM</div><div class="line">$(document).ready()方法来代替window.onload方法，使用该方法可以在DOM载入就绪时就对其进行操作并执行它所绑定的函数。</div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/$%28document%29.ready%28%29%E4%B8%8Ewindow.onload%E6%96%B9%E6%B3%95.PNG)</div><div class="line">2. 事件绑定</div><div class="line">bind()方法来对匹配元素进行特定事件的绑定。</div><div class="line">bind(type [. data] . fn);</div><div class="line">第一参数：blur,focus,load,resize……等，也可以自定义名称。</div><div class="line">第二参数：为可选参数，作为event.data属性值传递给事件对象的额外数据对象。</div><div class="line">第三参数：用来绑定的处理函数。</div><div class="line"></div><div class="line">3. 合成事件</div><div class="line">jQuery有两个合成事件----hover()方法和toggle()方法</div><div class="line">* hover()方法</div><div class="line">hover(enter,leave)方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的`第一个函数(enter)`;当鼠标移出这个元素时，会触发指定的`第二个函数(leave)`。</div><div class="line">* toggle()方法</div><div class="line">toggle(fn1,fn2,fn3,fn4……,fnN)</div><div class="line">用于模拟鼠标连续单击事件。</div><div class="line">toggle()方法在jQuery中还有另一个作用：切换元素的可见状态。如果元素是可见的，单击切换后则为隐藏。如果元素是隐藏的，单击切换后则为可见的。</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>    $(“#panel h5.head”).toggle(function(){<br>$(this).addClass(“highlight”);<br>$(this).next().show();</p>
<p>},function(){<br>$(this).removeClass(“highlight”);<br>$(this).next().hide();<br>});<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">###事件冒泡</div><div class="line">1. 什么是事件冒泡</div><div class="line">在页面上可以有多个事件，也可以多个元素响应同一个事件。假设网页上有两个元素，其中一个元素嵌套在另一个元素里，并且都被绑定了click是事件，同时&lt;body&gt;元素上也绑定了click事件。</div><div class="line">2. 事件对象</div><div class="line">事件对象就被创建了，这个事件对象只有事件处理函数才能访问到，事件处理函数执行后，事件对象就被销毁。</div><div class="line">3. 停止事件冒泡</div><div class="line">停止事件冒泡可以阻止事件中其他的事件函数被执行。jQuery中提供了stopPropagation()方法来停止事件冒泡。</div></pre></td></tr></table></figure></p>
<p>$(‘span’).bind(“click”,function(event){<br>                var txt=$(‘#msg’).html()+”</p><p>内层span元素被单击</p>“;<br>                $(“#msg”).html(txt);<br>    event.stopPropagation();<br>    //停止事件冒泡<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 阻止默认行为</div><div class="line">网页中的元素有自己的默认行为。如：单击超链接后会跳转，单击提交按钮后表单会提交，有时需要阻止这些默认行为。用preventDefault()方法来阻止元素的默认行为。</div></pre></td></tr></table></figure><p></p>
<p>event.preventDefault();<br>//阻止默认行为                event.stopPropagation();<br>//停止事件的冒泡<br>// return false;(对上述阻止行为的简写)<br>//同时阻止默认行为,停止事件的冒泡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5. 事件捕获</div><div class="line">与事件冒泡相反，jQuery不支持事件捕获</div><div class="line">6. 事件对象的属性</div><div class="line">* event.type</div></pre></td></tr></table></figure></p>
<pre><code>$(&quot;a&quot;).click(function(event){
        alert(event.type);
        return false;
    });
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* event.preventDefault()方法</div><div class="line">* event.stopPropagation()方法</div><div class="line">* event.target</div><div class="line">作用：是获取到触发事件的元素</div></pre></td></tr></table></figure>
<p>$(“a[href=’<a href="http://google.com&#39;]).click(function(event){" target="_blank" rel="external">http://google.com&#39;]).click(function(event){</a><br>    var tg=event.target;<br>    alert(tg.href);<br>    //<a href="http://google.com" target="_blank" rel="external">http://google.com</a><br>    return false;<br>});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*  event.relatedTarget</div><div class="line">*  event.pageX和event.pageY</div><div class="line">作用：获取到光标相对于页面的x坐标，y坐标。</div><div class="line">* event.which</div><div class="line">该方法的作用是在鼠标单击事件中获取到鼠标左，中，右键；在键盘事件中获取键盘的按键。</div></pre></td></tr></table></figure>
<p>$(“a”).mousedown(function(e){<br>                console.log(e.which);<br>                return false;<br>        });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* event.metaKey</div><div class="line">jQuery规定event.metaKey为键盘事件中获取&lt;ctrl&gt;按键</div><div class="line">###移除事件</div><div class="line">1. 移除按钮元素上以前注册的事件</div><div class="line">`unbind([type],[data]);方法`</div><div class="line">第一个参数事件类型，第二个参数是将要移除的函数。</div><div class="line">（1）如果没有参数，则删除所有的绑定事件</div><div class="line">（2）如果提供了事件类型作为参数，则只删除该类型的绑定事件</div><div class="line">（3）如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。</div></pre></td></tr></table></figure></p>
<p>$(“#delAll”).click(function(){<br>                $(“#btn”).unbind(“click”);<br>            });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 移除&lt;button&gt;元素的其中一个事件</div><div class="line">（首先需要为这些匿名函数指定一个变量）</div></pre></td></tr></table></figure>
<p>$(‘#btn’).bind(“click”,myFun1=function(){<br>$(‘#test’).append(“</p><p>我的绑定函数1</p>“);<br>            }).bind(“click”,myFun2=function(){<br>$(‘#test’).append(“<p>我的绑定函数2</p>“);            }).bind(“click”,myFun3=function(){<br>$(‘#test’).append(“<p>我的绑定函数3</p>“);<br>    });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">`one()方法`</div><div class="line">one()对于只需要触发一次，随后就要立即解除绑定情况。one()方法可以为元素绑定处理函数。当处理函数触发一次后，立即 被删除，即每个对象上，事件处理函数只会被执行一次。</div><div class="line">one(type,[data],fn)</div><div class="line">###模拟操作</div><div class="line">如：当用户进入页面后，就会触发click事件，而非不需要用户去主动单击；</div><div class="line">1. 常用模拟</div><div class="line">* $(&apos;#btn&apos;).trigger(&quot;click&quot;);</div><div class="line">* $(&apos;#btn&apos;).click();</div><div class="line">2. 触发自定义事件</div><div class="line">trigger()方法不仅能触发浏览器支持的具有相同名称的事件，也可以触发自定义名称事件。</div></pre></td></tr></table></figure><p></p>
<p>$(function(){                $(‘#btn’).bind(“myClick”,function(){<br>$(‘#test’).append(“</p><p>我的自定义事件</p>“);<br>    });<br>                $(‘#btn’).trigger(“myClick”);<br>});<p></p>
<p><button id="btn">单击我</button></p>
<p><div id="test"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 传递数据</div><div class="line">trigger(type,[data])方法有两个参数，第一个参数是要触发的事件类型，第二个参数是要传递给事件处理函数的附加数据，以数组的形式传递，通常可以通过传递一个参数给回调函数来区别这次事件是代码触发的还是用户触发的。。</div></pre></td></tr></table></figure></p>
<p>$(function(){        $(‘#btn’).bind(“myClick”,function(event,message1,message2){<br>$(‘#test’).append(“</p><p>“+message1+message2+”</p>“);<br>});<br>            $(‘#btn’).trigger(“myClick”,[“我的”,”梦想”]);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 执行默认操作</div><div class="line">trigger()方法触发事件后，会执行浏览器默认操作。</div></pre></td></tr></table></figure><p></p>
<p>$(“input”).trigger(“focus”);<br>//以上代码不仅会触发<input>元素绑定的focus事件，也会使<input>元素本身得到焦点（这是浏览器的默认操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如果只想触发绑定的focus是事件，而不想执行浏览器默认操作，可以使用jQuery的triggerHandler(&quot;focus&quot;);</div><div class="line">* 使用triggerHandler()只是触发元素上绑定的事件，不会得到焦点。</div><div class="line">###其他用法</div><div class="line">1. 绑定多个事件类型</div><div class="line">bind()方法绑定多个事件。</div></pre></td></tr></table></figure></p>
<pre><code>$(function(){
</code></pre><p>$(“.bg”).bind(“mouseover mouseout”,function(){<br>        $(this).toggleClass(“over”);<br>            });<br>        });<br>        相当与下面代码：<br>$(function(){<br>            $(“.bg”).bind(“mouseover”,function(){<br>                $(this).toggleClass(“over”);<br>            }).bind(“mouseout”,function(){<br>                $(this).toggleClass(“over”);<br>            });<br>        });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 添加事件命名空间，便于管理</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>            $(“div”).bind(“click.plugin”,function(){<br>                $(“body”).append(“</p><p>click事件</p>“);<br>            });<br>            $(“div”).bind(“mouseover.plugin”,function(){<br>                $(“body”).append(“<p>mouseover事件</p>“);<br>            });<br>            $(“div”).bind(“dbclick.plugin”,function(){<br>                $(“body”).append(“<p>dbclick事件</p>“);<br>            });<br>            $(“button”).click(function(){<br>                $(“div”).unbind(“.plugin”);<br>            });<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 相同事件名称，不同命名空间执行方法</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“div”).bind(“click”,function(){<br>                $(“body”).append(“</p><p>click事件</p>“);<br>            });<br>            $(“div”).bind(“click.plugin”,function(){<br>                $(“body”).append(“<p>click.plugin事件</p>“);<br>            });<br>            $(“button”).click(function(){<br>                $(“div”).trigger(“click!”);<br>            })<br>        });<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`注意：`trigger(&quot;click&quot;)后面的！感叹号的作用是匹配所有不包含在命名空间中的click方法</div><div class="line">## jQuery中的动画</div><div class="line">###show()方法和hide()方法</div><div class="line">1. show()方法和hide()方法</div><div class="line">在HTML文档里，为一个元素调用hide()方法，会将该元素的display样式改为&quot;none&quot;</div></pre></td></tr></table></figure>
<p>$(“element”).hide();<br>等价于：<br>$(“element”).css(“display”,”none”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">`注意：`用jQuery做动画效果要求在`标准模式`下，否则可能会引起动画抖动。</div><div class="line">2. show()方法和hide()方法让元素动起来</div><div class="line">上述两个方法在不带任何参数的情况下，相当于</div><div class="line">css(&quot;display&quot;,&quot;none/block/inline&quot;),不会有任何动画。</div><div class="line">&gt;可以为指定一个速度参数（&quot;slow&quot;表示速度为600毫秒，&quot;normal&quot;表示400毫秒，&quot;fast&quot;表示200毫秒），$ (&quot;element&quot;).show(&quot;fast&quot;)&gt;也可以显示速度为一个数字，单位为毫秒，$ (&quot;element&quot;).show(1000);</div><div class="line"></div><div class="line">&gt;hide()方法会同时减少“内容”的高，宽，和不透明度，直至这3个属性的值都为0</div><div class="line">###fadeIn()方法和fadeOut()方法</div><div class="line">只改变元素的不透明度</div><div class="line">###slideUp方法和slideDown()方法</div><div class="line">只改变元素的高度，如果一个元素的display属性值为&quot;none&quot;，当调用slideDown()方法时，这个元素将由上至下延伸。</div><div class="line">###自定义动画方法</div><div class="line">animate(params,speed,callback);</div><div class="line">* params:一个包含样式属性及值的映射，如：</div><div class="line">&#123;property1:&quot;value1&quot;,property2:&quot;value2&quot;..........&#125;</div><div class="line">* speed:速度参数，可选</div><div class="line">* callback:在动画完成时执行的函数，可选</div><div class="line">1. 自定义简单动画</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>            $(“#panel”).mouseover(function(){<br>                $(this).animate({left:”500px”},3000);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 累加，累减动画</div><div class="line">在value值前面加上&quot;+=&quot;或&quot;-=&quot;符号表示在当前位置累加或者累减。</div></pre></td></tr></table></figure>
<p>$(this).animate({left:”+=500px”},3000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 多重动画</div><div class="line">* 同时执行多个动画</div></pre></td></tr></table></figure></p>
<p>$(“div”).click(function(){<br> $(this).animate({left:”500px”,height:”200px”},3000);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 按顺序执行多个动画(动画队列)</div></pre></td></tr></table></figure></p>
<p>$(this).animate({left:”500px”},3000);<br>$(this).animate({height:”500px”},3000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 动画回调函数</div><div class="line">`注意：`callback回调函数适合用于jQuery的所有动画效果</div></pre></td></tr></table></figure></p>
<p>$(“#panel”).css(“opacity”,”0.5”);<br>            $(“#panel”).click(function(){<br>                $(this).animate({left:”400px”,height:”200px”,opacity:”1”},3000)<br>                    .animate({top:”200px”,width:”200px”},3000,function(){<br>                        $(this).css(“border”,”5px solid green”);<br>                    })<br>                    // .fadeOut(“slow”);<br>                    //让元素最后隐藏消失<br>                    // .css(“border”,”5px solid green”);<br>                    //一开始动画就执行了，需要用回调函数，将css()放在动画队列里面</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">###停止动画和判断是否处于动画状态</div><div class="line">1. 停止元素的动画</div><div class="line">stop()方法，stop([clearQueue],[gotoEnd]);</div><div class="line">clearQueue和gotoEnd都是可选的参数，为Boolean值（true或false）</div><div class="line">2. 判断元素是否处于动画状态</div></pre></td></tr></table></figure>
<p>if(!$(element).is(“:animated”)){<br>//判断元素是否处于动画状态<br>//如果当前没有进行动画，则添加新动画<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">3. 延迟动画</div><div class="line">delay()方法</div><div class="line">4.其他动画方法</div><div class="line">* toggle(speed,[callback])</div><div class="line">* slideToggle(speed,[easing],[callback])</div><div class="line">* fadeTo(speed,opacity,[callback])</div><div class="line">* fadeToggle(speed,[easing],[callback])</div><div class="line"></div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/%E5%8A%A8%E7%94%BB%E6%96%B9%E6%B3%95.PNG)</div><div class="line">5. 动画队列</div><div class="line">（1）一组元素上的动画效果</div><div class="line">* 当在一个animate()方法中应用多个属性时，动画是同时发生的</div><div class="line">* 当以链式的写法应用动画方法时，动画是按照顺序发生的</div><div class="line">（2）多组元素上的动画效果</div><div class="line">* 默认情况下，动画都是同时发生的</div><div class="line">* 当以回调的形式应用动画时，动画是按照回调顺序的发生的</div><div class="line">`注意：`在动画方法中，要注意其他非动画方法会插队，如：css()方法要使非动画方法也按照顺序执行，需要把这些方法写在动画方法的回调函数。</div><div class="line">##jQuery对表单，表格的操作及其更多的应用</div><div class="line">###表单的应用</div><div class="line">（1）表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法</div><div class="line">（2）表单域：包含文本框，密码框，隐藏域，复选框，单选框，下拉选择框和文件上传框等</div><div class="line">（3）表单按钮：包括提交按钮，复位按钮和一般按钮，用于数据传送到服务器上或者取消传送，还可以用来控制其他处理脚本的处理工作</div><div class="line">1. 单行文本框的应用</div><div class="line">* 获取和失去焦点改变样式</div></pre></td></tr></table></figure></p>
<p>/*input:focus,textarea:focus{<br>            border: 2px solid #f00;<br>            background: #fcc;</p>
<pre><code>}*/
</code></pre><hr>
<pre><code>/*解决IE6不支持:focus伪类情况*/
.focus{
    border: 2px solid #f00;
    background: #fcc;
}
</code></pre><p>$(function(){<br>            $(“:input”).focus(function(){<br>                $(this).addClass(“focus”);<br>            }).blur(function(){<br>                $(this).removeClass(“focus”);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 多行文本框的应用</div></pre></td></tr></table></figure>
<p>// $(function(){<br>        //     var $comment=$(“#comment”);<br>        //     $(“.bigger”).click(function(){<br>        //         if($comment.height()<500){ $comment.height($comment.height()+50);="" }="" });="" $(".smaller").click(function(){="" if($comment.height()="">50){<br>        //             $comment.height($comment.height()-50);<br>        //         }<br>        //     });</500){></p>
<pre><code>// });
//使用animate()有一种缓冲效果比起height()

$(function(){
    var $comment=$(&quot;#comment&quot;);
    $(&quot;.bigger&quot;).click(function(){
        if(!$comment.is(&quot;:animated&quot;)){
            if($comment.height()&lt;500){
                $comment.animate({height:&quot;+=50&quot;},400);
            }
        }
    });
    $(&quot;.smaller&quot;).click(function(){
        if(!$comment.is(&quot;:animated&quot;)){
            if($comment.height()&gt;50){
                $comment.animate({height:&quot;-=50&quot;},400);
            }
        }
    });
});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 复选框的应用</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“#checkAll”).click(function(){<br>                $(‘[name=items]:checkbox’).attr(‘checked’,true);<br>            });<br>            $(“#checkNo”).click(function(){<br>                $(‘[name=items]:checkbox’).attr(‘checked’,false);<br>            });<br>            $(“#checkRev”).click(function(){<br>                $(‘[name=items]:checkbox’).each(function(){<br>                    // $(this).attr(“checked”,!$(this).attr(“checked”));<br>                    this.checked=!this.checked;<br>                });<br>            });<br>            $(“#send”).click(function(){<br>                var str=”你选中的是：\r\n”;<br>                $(‘[name=items]:checkbox:checked’).each(function(){<br>                    str+=$(this).val()+”\r\n”;<br>                });<br>                alert(str);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">把全选和不全选改为复选框：</div></pre></td></tr></table></figure>
<p>$(function(){<br>        //     $(‘[name=items]:checkbox’).click(function(){<br>        //     var flag=true;<br>        //     $(‘[name=items]:checkbox’).each(function(){<br>        //         if(!this.checked){<br>        //             flag=false;<br>        //         }<br>        //     });<br>        //     $(‘#checkedAll’).attr(‘checked’,flag);<br>        // });<br>//另一种方法：判断复选框的总数是否与选中的复选框数量相等</p>
<p>$(‘[name=items]:checkbox’).click(function(){<br>    //定义一个临时变量，避免重复使用同一个选择器选择页面中的元素，提高程序效率<br>    var $tmp=$(‘[name=items]:checkbox’);<br>    //用filter()方法选出选中的复选框，直接给checkedAll赋值<br>    $(‘#checkedAll’).attr(‘checked’,$tmp.length==$tmp.filter(‘:checked’).length);<br>});</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`注意：`哪些属性该用attr()访问，哪些应该用prop()访问？</div><div class="line">第一个原则：只添加属性名称该属性就会生效应该使用prop()</div><div class="line">第二个原则：只存在true/false的属性应该使用prop()</div><div class="line">按照官方的说明：如果是设置disabled和checked这些属性，应该使用prop()方法，而不是使用attr()方法。</div><div class="line">4. 下拉框的应用</div></pre></td></tr></table></figure>
<p>$(function(){<br>            //从左到右<br>            $(‘#add’).click(function(){<br>                var $options=$(‘#select1 option:selected’);<br>                // var $remove=$options.remove();<br>                // $remove.appendTo(‘#select2’);<br>                //删除和追加可以直接用appendTo()方法完成<br>                $options.appendTo(‘#select2’);<br>            });<br>            $(‘#add_all’).click(function(){<br>                var $options=$(‘#select1 option’);<br>                $options.appendTo(‘#select2’);<br>            });<br>            $(‘#select1’).dblclick(function(){<br>                var $options=$(“option:selected”,this);<br>                $options.appendTo(‘#select2’);<br>            });<br>            //右到左<br>            $(‘#remove’).click(function(){<br>                var $options=$(‘#select2 option:selected’);<br>                // var $remove=$options.remove();<br>                // $remove.appendTo(‘#select2’);<br>                //删除和追加可以直接用appendTo()方法完成<br>                $options.appendTo(‘#select1’);<br>            });<br>            $(‘#remove_all’).click(function(){<br>                var $options=$(‘#select2 option’);<br>                $options.appendTo(‘#select1’);<br>            });<br>            $(‘#select2’).dblclick(function(){<br>                var $options=$(“option:selected”,this);<br>                $options.appendTo(‘#select1’);<br>            });</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">5. 表单验证</div><div class="line">###表格的应用</div><div class="line">（1）普通的隔行变色</div></pre></td></tr></table></figure>
<p><style><br>        .even{<br>            background: red;<br>            /<em>偶数行样式
</em>/<br>        }<br>        .odd{<br>            background: green;<br>            /<em>奇数行样式</em>/<br>        }<br>    </style></p>
<script>
        $(function(){
            $("tr:odd").addClass("odd");
            $("tr:even").addClass("even");
        });
    </script>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`注意：`$(&quot;tr:odd&quot;)和$(&quot;tr:even&quot;)选择器中索引是从0开始，因此第一行是偶数。</div><div class="line">&gt;单选按钮控制表格变色：</div></pre></td></tr></table></figure>
<p>$(function(){<br>            // $(“tr:odd”).addClass(“odd”);<br>            // $(“tr:even”).addClass(“even”);<br>            // 除去表头的隔行变色<br>            $(“tbody&gt;tr:odd”).addClass(“odd”);<br>            $(“tbody&gt;tr:even”).addClass(“even”);<br>            //某一行高亮显示<br>            // $(“tr:contains(‘张珊5’)”).addClass(‘selected’);<br>            //单击单选按钮，进行高亮显示<br>        $(‘tbody&gt;tr’).click(function(){<br>            $(this)<br>                .addClass(‘selected’)<br>                .siblings().removeClass(‘selected’)<br>                .end()<br>                //使用end()后.find(‘:radio’)就是$(this).find(‘:radio’)<br>                .find(‘:radio’).attr(‘checked’,true);<br>        });<br>        $(‘table :radio:checked’).parent().parent().addClass(‘selected’);<br>        //注意$(‘table :radio:checked’)中table与:radio间一定要有空格</p>
<pre><code>//用parents()方法简化
$(&apos;table :radio:checked&apos;).parents(&quot;tr&quot;)addClass(&apos;selected&apos;);
//has()方法进一步简化代码
$(&apos;tbody&gt;tr:has(:checked)&apos;).addClass(&quot;selected&quot;);
});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#jQuery与Ajax的应用</div><div class="line">1. Ajax的优势</div><div class="line">* 不需要插件支持</div><div class="line">* 优秀的用户体验</div><div class="line">* 提高Web程序的性能</div><div class="line">* 减轻服务器和宽带的负担</div><div class="line">2. Ajax的不足</div><div class="line">* 浏览器对XMLHttpRequest对象的支持度不足</div><div class="line">* 破坏浏览器前进，“后退”按钮的正常功能</div><div class="line">* 对搜索引擎的支持不足</div><div class="line">* 开发和调试工具缺乏</div><div class="line">3. Ajax的XMLHttpRequest对象</div><div class="line">XMLHttpRequest对象是AJAX的核心——发送异步请求，接受响应及执行回调都是通过 它来完成的</div><div class="line">4. 安装Web环境——AppServ</div><div class="line">&gt;下载地址http://www.appservnetwork.com</div><div class="line">5. load()方法</div><div class="line">(1)载入HTML文档</div><div class="line">load(url [,data] [,callback])</div><div class="line"></div><div class="line">![Alt text](./load方法.PNG)</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“#send”).click(function(){<br>                $(“#resText”).load(“test.html”);<br>            });<br>        });</p>
<p><input type="button" id="send" value="Ajax获取"><br>    <div class="comment">已有评论</div><br>    <div id="resText"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（2）筛选载入的HTML文档</div></pre></td></tr></table></figure></p>
<p>//只加载test.html页面中的class为para的内容<br>                $(“#resText”).load(“test.html .para”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（3）传递方式</div><div class="line">load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，则会自动转换为post方式</div></pre></td></tr></table></figure></p>
<p>//无参数传递，则是get方式<br>$(“$resText”).load(“test.php”,function(){<br>});<br>//有参数传递，则是；post方式<br>$(“#resText”).load(“test.php”,{name:”rain”,age:”22” },function(){<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（4）回调参数</div><div class="line">对于 必须在加载完成后才能继续的操作，load()方法提供了回调函数（callback），该函数有3个参数分别代表请求返回的内容，请求状态，和XMLHttpRequeat对象。</div></pre></td></tr></table></figure></p>
<p>$(“#resText”).load(“test.php”,function(responseText,textStatus,XMLHttpRequest){<br>//responseText请求返回的内容<br>//textStatus请求返回的状态<br>//XMLHttpRequest：XMLHttpRequest对象<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">6.  $.get()方法和 $ . post()方法</div><div class="line">（1）$.get()方法</div><div class="line">使用get方式来进行异步请求</div><div class="line">$.get(url [,data] [,callback][,type])</div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/$get%28%29%E6%96%B9%E6%B3%95.PNG)</div><div class="line">（2）$.post()方法</div><div class="line">&gt;GET与POST方式的区别</div><div class="line">* get请求会将参数跟在URL后进行传递，而post请求则是作为http消息的实体内容发送Web服务器，当然在ajax请求中，这种区别是对用户不可见的</div><div class="line">* get方式对传输的数据有大小限制（一般不大于2kb）而使用post方式传递的数据量比get大（一般不受限制）</div><div class="line">* get方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据（账号，密码等），而post方式不会</div><div class="line">* get方式和post方式传递的数据在服务器端的获取也不相同。在PHP中get的数据可以用 $_ GET[]获取，而post方式可以用$_post[]获取,两种可以用$_REQUEST[]来获取</div><div class="line">7. $.getScript()方法和$.getJson()方法</div><div class="line">&gt;JSONP(JavaScript with Padding )是一个</div><div class="line">8. $.ajax(options)该方法只有一个参数</div><div class="line">###序列化元素</div><div class="line">1. serialize()方法</div><div class="line">2. serializeArray()方法</div><div class="line">该方法不是返回字符串，而是将，DOM元素序列化之后，返回json格式的数据</div><div class="line">3. $.param()方法</div><div class="line">它是serialize()方法的hexin，用来对一个数组或者一个对象按照key/value进行序列化。</div><div class="line">```var obj=&#123;a:1,b:2,c:3&#125;;</div><div class="line">	var k=$.param(obj);</div><div class="line">   console.log(k);</div><div class="line">   //a=1&amp;b=2&amp;c=3</div></pre></td></tr></table></figure></p>
<p>###禁用缓存<br>问题：数据已经更新了，但传递的还是以前的数据<br>解决：应该禁用缓存<br>如果是$.post方法获取的数据，那么默认就是禁用缓存的，如果是$.get()方法，可以设置时间戳来避免缓存，可以在URL的后面加上+(+new Date)<br>(+new Date)的等价于new Date().getTime()<br>不用随机数的原因：因为随机数对于一台电脑来说，在大量使用之后出现重复的概率会很大，而时间戳不会。<br>如果是使用了$.ajax()方法来获取数据，只需要设置cache:false即可，<code>注意：</code>false是布尔值，而不是字符串。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的基础知识]]></title>
      <url>http://yoursite.com/2016/09/18/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript实现继承"><a href="#JavaScript实现继承" class="headerlink" title="JavaScript实现继承"></a>JavaScript实现继承</h1><ol>
<li>原型链</li>
</ol>
<ul>
<li>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>构造函数，原型和实例三者之间的关系：每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor属性，这个属性包含一个指向prototype属性所在的函数指针，而实例都包含一个指向原型对象的内部指针）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//原型链</div><div class="line">	function SuperType()&#123;</div><div class="line">		this.property=true;</div><div class="line">	&#125;</div><div class="line">	SuperType.prototype.getSuperValue=function()&#123;</div><div class="line">		return this.property;</div><div class="line">	&#125;;</div><div class="line">	function SubType()&#123;</div><div class="line">		this.subproperty=false;</div><div class="line">	&#125;</div><div class="line">	SubType.prototype=new SuperType();</div><div class="line">	SubType.prototype.getSubValue=function()&#123;</div><div class="line">		return this.subproperty;</div><div class="line">	&#125;</div><div class="line">	var instance=new SubType();</div><div class="line">	console.log(instance.getSuperValue());</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>借用构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">借用构造函数</div><div class="line">	function SuperType()&#123;</div><div class="line">		this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">	&#125;</div><div class="line">	function Subtype()&#123;</div><div class="line">		SuperType.call(this);</div><div class="line">		//实现继承</div><div class="line">	&#125;</div><div class="line">	var instance1=new Subtype();</div><div class="line">	instance1.colors.push(&quot;black&quot;);</div><div class="line">	console.log(instance1.colors);</div><div class="line">	//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line">	var instance2=new Subtype();</div><div class="line">	console.log(instance2.colors);</div><div class="line">	[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</div></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数传递参数的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">传递参数</div><div class="line">function SuperType(name)&#123;</div><div class="line"> this.name=name;	</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">	SuperType.call(this,&quot;chenyu&quot;);</div><div class="line">	this.age=29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance=new SubType();</div><div class="line">console.log(instance.name);</div><div class="line">//chenyu</div><div class="line">console.log(instance.age);</div><div class="line">29</div></pre></td></tr></table></figure>
</li>
<li><p>组合继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">组合继承</div><div class="line">function SuperType(name)&#123;</div><div class="line">	this.name=name;</div><div class="line">	this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name,age)&#123;</div><div class="line">	SuperType.call(this,name);</div><div class="line">	this.age=age;</div><div class="line">&#125;</div><div class="line">//继承方法</div><div class="line">SubType.prototype=new SuperType();</div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=function()&#123;</div><div class="line">	console.log(this.age);</div><div class="line">&#125;</div><div class="line">var instance1=new SubType(&quot;chenyu&quot;,20);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1.colors);</div><div class="line">//&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line">instance1.sayName();</div><div class="line">//chenyu</div><div class="line">instance1.sayAge();</div><div class="line">//20</div></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">寄生式继承</div><div class="line">function object(o)&#123;</div><div class="line">	function F()&#123;&#125;//临时性的构造函数</div><div class="line">	F.prototype=o;//吧传入的参数给构造函数的原型</div><div class="line">	return new F();//返回函数创造的新实例</div><div class="line"></div><div class="line">&#125;</div><div class="line">var person=&#123;</div><div class="line">	name:&quot;chenyu&quot;,</div><div class="line">	friends:[&quot;haha&quot;,&quot;enen&quot;,&quot;yeye&quot;]</div><div class="line">&#125;</div><div class="line">//创建两个person的副本对其对象进行修改</div><div class="line">var anotherPerson=object(person);</div><div class="line">anotherPerson.name=&quot;chenyu&quot;;</div><div class="line">anotherPerson.friends.push(&quot;bob&quot;);</div><div class="line">var anotherPerson1=object(person);</div><div class="line">anotherPerson1.name=&quot;chenqian&quot;;</div><div class="line">anotherPerson1.friends.push(&quot;fighting&quot;);</div><div class="line">console.log(person.friends);</div><div class="line">//[&quot;haha&quot;, &quot;enen&quot;, &quot;yeye&quot;, &quot;bob&quot;, &quot;fighting&quot;]</div><div class="line"></div><div class="line">&gt; //es5的Object.creat()方法实现寄生式继承。原理与object()方法的效果一样</div><div class="line">var person=&#123;</div><div class="line">	name:&quot;chenyu&quot;,</div><div class="line">	friends:[&quot;yulin&quot;,&quot;langxiaoju&quot;,&quot;wnagju&quot;,&quot;chenzihan&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson=Object.create(person);</div><div class="line">anotherPerson.name=&quot;a&quot;;</div><div class="line">anotherPerson.friends.push(&quot;zeze&quot;);</div><div class="line">console.log(person.friends);</div><div class="line"></div><div class="line">var anotherPerson1=Object.create(person);</div><div class="line">anotherPerson1.name=&quot;b&quot;;</div><div class="line">anotherPerson1.friends.push(&quot;enen&quot;);</div><div class="line">console.log(person.friends);</div><div class="line">console.log(person.name);</div><div class="line">console.log(anotherPerson1.name);</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解http知识总结]]></title>
      <url>http://yoursite.com/2016/09/10/%E5%9B%BE%E8%A7%A3http%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="图解http知识总结"><a href="#图解http知识总结" class="headerlink" title="图解http知识总结"></a>图解http知识总结</h1><p>[TOC]</p>
<h2 id="HTTP-1-1虽然是无状态协议，"><a href="#HTTP-1-1虽然是无状态协议，" class="headerlink" title="HTTP/1.1虽然是无状态协议，"></a>HTTP/1.1虽然是无状态协议，</h2><p>但为了实现期望的保持状态功能，于是引入了Cookie技术。有cookie再用http协议通信，就可以管理状态了。</p>
<h2 id="HTTP-1-1的使用方法："><a href="#HTTP-1-1的使用方法：" class="headerlink" title="HTTP/1.1的使用方法："></a>HTTP/1.1的使用方法：</h2><ul>
<li>GET:获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是如果是请求的资源的是文本，那就保持原样返回。如果是CGI（通用网关接口）那样的程序，那返回经过执行后的输出结果。</li>
<li>POST：传输实体主体<br>post方法用来传输实体的主体<br>虽然用get方法也可以传输实体的主体。但一般不用get方法进行传输。而是用post方法，虽说post的功能与get很相似，但post的主要目的并不是获取响应的主体内容。</li>
</ul>
<blockquote>
<p>GET与POST方式的区别：<br>ＧＥＴ与ＰＯＳＴ请求提交方式<br>从性能上来讲post请求比get请求消耗更多一些，用相同数据比较，get最多比post快两倍</p>
<ol>
<li>在web程序上，get一般是URL提交请求如：demo.php?name=lee&amp;age=100<br>post 一般是web表单提交 如：<form method="post"><input type="text" name="name" value="bob"><input type="password" name="passqord"></form><br>两种头信息：查看方式：firebug-》网络</li>
<li>响应头信息：服务器返回的信息，客户端可以获取，但不可以设置</li>
<li>请求头信息：客户端发送的信息，客户端可以设置，但不可以获取<br>1-1解决中文乱码问题，ajax返回的数据其实是utf-8的，最简单解决措施，全部设置为utf-8<br>1-2特殊字符，需要通过encodeURLComponent来编码解决</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//get方式</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="line"> addEvent(document,&apos;click&apos;,function()&#123;</div><div class="line">      var xhr=creatXHR();</div><div class="line">      var url=&apos;demo.php?rand=&apos;+Math.random();</div><div class="line">      url=params(url,&apos;name&apos;,&apos;lee&apos;);</div><div class="line">        url=params(url,&apos;age&apos;,100);</div><div class="line">        alert(url);</div><div class="line">      xhr.onreadystatechange=function()&#123;</div><div class="line">         if(xhr.readyState==4)&#123;</div><div class="line">       if(xhr.status==200)&#123;</div><div class="line">       //alert(xhr.getAllResponseHeaders()) ;//获取全部响应头信息</div><div class="line">       //alert(xhr.getResponseHeader(&apos;Content-Type&apos;));//获取单个响应头信息       </div><div class="line">               alert(xhr.responseText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;else&#123;</div><div class="line">   alert(&apos;获取数据错误！错误代号：&apos;+xhr.status+&apos;,错误信息：&apos;+xhr.statusText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line"></div><div class="line">      &#125;;</div><div class="line">    xhr.open(&apos;get&apos;,url+Math.random(),true);</div><div class="line">    xhr.send(null);</div><div class="line">    xhr.about();//取消异步请求，放在send（）之前会报错，放在responseText（）之前会得到一个空值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">   function params(url,name,value)&#123;</div><div class="line">     url+=url.indexOf==-1?&apos;?&apos;:&apos;&amp;&apos;;</div><div class="line">     url+=encodeURLComponent(name)+&apos;=&apos;+encodeURLComponent(value);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line"></div><div class="line">//post方式</div><div class="line"></div><div class="line">addEvent(document,&apos;click&apos;,function()&#123;</div><div class="line">      var xhr=creatXHR();</div><div class="line">      var url=&apos;demo.php?rand=&apos;+Math.random();</div><div class="line">      url=params(url,&apos;name&apos;,&apos;lee&apos;);</div><div class="line">        url=params(url,&apos;age&apos;,100);</div><div class="line">        alert(url);</div><div class="line">      xhr.onreadystatechange=function()&#123;</div><div class="line">         if(xhr.readyState==4)&#123;</div><div class="line">       if(xhr.status==200)&#123;</div><div class="line">       //alert(xhr.getAllResponseHeaders()) ;//获取全部响应头信息</div><div class="line">       //alert(xhr.getResponseHeader(&apos;Content-Type&apos;));//获取单个响应头信息       </div><div class="line">               alert(xhr.responseText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;else&#123;</div><div class="line">   alert(&apos;获取数据错误！错误代号：&apos;+xhr.status+&apos;,错误信息：&apos;+xhr.statusText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line"></div><div class="line">      &#125;;</div><div class="line">    xhr.open(&apos;post&apos;,url,true);//第一步改为post</div><div class="line">    xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);//第三步模仿表单提交</div><div class="line">    xhr.send(&apos;name=Lee&amp;age=100&apos;);//第二步将名值放入send（）方法里</div><div class="line">    xhr.about();//取消异步请求，放在send（）之前会报错，放在responseText（）之前会得到一个空值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">   function params(url,name,value)&#123;</div><div class="line">     url+=url.indexOf==-1?&apos;?&apos;:&apos;&amp;&apos;;</div><div class="line">     url+=encodeURLComponent(name)+&apos;=&apos;+encodeURLComponent(value);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PUT:传输文件</li>
<li>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在URI指定的位置。（存在安全性）</li>
<li>HEAD:获取报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性以及资源的更新的日期时间等。</li>
<li>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</li>
<li>OPTIONS:询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</li>
<li>TRACE:追踪路径<br>TRACE方法是让WEB服务器端将之前的请求通信环回给客户端的方法</li>
<li>CONNECT:要求用隧道协议链接代理<br>CONNECT方法要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络隧道进行传输。<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2>HTTP是无状态的协议，它不对之前发生过得请求和响应的状态进行管理，也就是说，无法根据之前的状态进行本次的请求处理。<br>（假设要求登录认证的Web页面本身无法进行状态的管理即不记录已登录的状态，那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态）<br>Cookie会根据从服务器端发送的响应报文中写入Cookie信息来控制客户端的状态。</li>
</ul>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>缓存是指代理服务器或客服端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p>
<ol>
<li>缓存的有效时期</li>
<li>客户端的缓存<br>##为Cookie服务的首部字段<br>Cookie的工作机制用户识别以及状态管理。</li>
<li>为Cookie服务的首部字段 </li>
</ol>
<ul>
<li>Set-Cookie（响应首部字段 ）:开始状态管理所使用的Cookie信息</li>
<li>Cookie（请求首部字段）:服务器接受到的Cookie信息</li>
</ul>
<ol>
<li>Set-Cookie字段的属性</li>
</ol>
<ul>
<li>expires属性（=DATE）Cookie的有效日期（若不明确指定则默认为浏览器关闭前为止）<br><code>注意：</code>一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显示删除Cookie的方法。但可以通过覆盖已过期的Cookie，实现对客户端的Cookie的实质性的删除操作。<br>＊path属性（=PATH）将服务器上的文件目录作为Cookie的适用对象（若不能指定则默认为文档所在的而文件目录）</li>
<li>domain（=域名）作为Cookie适用对象的域名，（若不指定则默认为常见Cookie的服务器的域名）<br>（不指定域名显得更加安全）</li>
<li><p>secure属性（只写上secure即可）仅在HTTPS安全通信时才会发送Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=value;secure</div></pre></td></tr></table></figure>
</li>
<li><p>HttpOnly属性，其主要目的是为防止跨站脚本攻击（XSS）对Cookie的信息窃取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=value;HttpOnly</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭到篡改</li>
<li>窃听：对于收集互联网上的流动数据包（帧）解析工作，可交给抓包（Packet Capture）或者嗅探器（Sniffer）工具，如常见的：Wireshark</li>
</ul>
<ol>
<li>通信加密：HTTP协议没有加密机制，但可以通过SSL（安全套接层）或者TLS（安全层传输协议）的组合使用，加密HTTP的通信内容。（HTTP与SSL的组合使用被称为HTTPS（HTTP Secure），超文本传输安全协议）</li>
<li>HTTP+加密+认证+完整性保护=HTTPS<h2 id="为什么不一直使用HTTPS"><a href="#为什么不一直使用HTTPS" class="headerlink" title="为什么不一直使用HTTPS"></a>为什么不一直使用HTTPS</h2>原因：与纯文本通信相比，加密通信会消耗更多的资源（购买证书等）<h2 id="基于HTTP的功能的追加协议"><a href="#基于HTTP的功能的追加协议" class="headerlink" title="基于HTTP的功能的追加协议"></a>基于HTTP的功能的追加协议</h2></li>
<li>Ajax的解决办法<br>是一种有效利用js和DOM的操作，以达到Web页面替换加载的异步通信手段。只更新页面的部分内容。</li>
<li>Comet的解决办法<br>一旦服务器端有内容更新，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客服端推送的功能。</li>
<li>使用浏览器进行全双工通信的WebSocket<h2 id="与Web服务器及程序协作的CGI"><a href="#与Web服务器及程序协作的CGI" class="headerlink" title="与Web服务器及程序协作的CGI"></a>与Web服务器及程序协作的CGI</h2>CGI（通用网关接口）是指Web服务器在接受到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出相应的动作，使用CGI的程序叫做CGI程序，通常用Perl,php,ruby和c等编程语言编写而成。<h2 id="因Java而普及的Servlet"><a href="#因Java而普及的Servlet" class="headerlink" title="因Java而普及的Servlet"></a>因Java而普及的Servlet</h2>（Servlet=Server+Applet）表示轻量服务程序<br>Servlet是一种能子服务器上创建动态内容的程序。Servlet是用Java语言实现的一个接口，属于企业级Java（JavaEE，JavaEnterprise Edition）的一部分<br>（Servlet常驻内存，因此每次请求的时，可启动相对进程级别更为轻量的Servlet，程序的执行效率从而变的更高）<h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2>对Web应用的攻击模式有两种：主动攻击，被动攻击</li>
<li>以服务器为目标的主动攻击<br>主动攻击：是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。</li>
<li>以服务器为目标的被动攻击<br>被动攻击：指利用圈套策略执行攻击代码的攻击模式。在被动攻击的过程中，攻击者不直接对目标Web应用访问发起攻击。</li>
<li>因输出值转义不完全引发的安全漏洞<br>实施Web应用的安全对策课分为两个部分。</li>
</ol>
<ul>
<li>客户端的验证</li>
<li>Web应用端（服务器端）的验证</li>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
<ol>
<li>跨站脚本攻击（XSS）指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或js进行的一种攻击。<br>影响：</li>
</ol>
<ul>
<li>利用虚假输入表单骗取用户的个人信息</li>
<li>利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片</li>
</ul>
<ol>
<li>对用户Cookie的窃取攻击</li>
<li>SOL注入攻击<br>（1）会执行非法SQL的SQL注入攻击<br>影响:</li>
</ol>
<ul>
<li>非法查看或篡改数据库内的数据</li>
<li>规避认证</li>
<li>执行和数据库服务器业务关联的程序等</li>
<li>SQL注入攻击破坏SQL语句结构的案例</li>
</ul>
<ol>
<li>OS命令注入攻击<br>指通过Web应用，执行非法的操作系统命令达到攻击目的。只要在能调用Shell函数的地方就有存在被攻击的风险。</li>
<li>HTTP首部注入攻击<br>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或者主体的一种攻击。属于被动攻击模式。 向首部主题内添加内容的攻击称为HTTP响应截断攻击。<br>影响：</li>
</ol>
<ul>
<li>设置任何Cookie信息</li>
<li>重定向至任意URL</li>
<li>显示任意的主体（HTTP响应截断攻击）</li>
</ul>
<ol>
<li>HTTP响应截断攻击</li>
<li>邮件首部注入攻击</li>
<li>目录遍历攻击</li>
<li>远程文件包含漏洞</li>
<li>因设置或设计上的缺陷引发的安全漏洞</li>
<li>不正确的错误消息处理</li>
<li>开放重定向</li>
<li>因会话管理疏忽引发的安全漏洞</li>
<li>会话固定攻击</li>
<li>跨站点请求伪造（CSRF）</li>
<li>其他安全漏洞</li>
</ol>
<ul>
<li>密码破解（穷举法/暴力破解法，字典攻击）</li>
<li>点击劫持</li>
</ul>
<ol>
<li>DoS攻击<br>DoS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫做服务停止攻击或者拒绝服务攻击。<br>DoS攻击方式：</li>
</ol>
<ul>
<li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也呈停止状态。</li>
<li>通过攻击安全漏洞使服务停止</li>
</ul>
<ol>
<li>后台程序</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[清除浮动]]></title>
      <url>http://yoursite.com/2016/09/02/%E8%B0%88%E8%B0%88%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>##浮动的原理<br>css样式中的浮动（float）属性主要有none，left<br>   和right 这三个属性值：</p>
<ul>
<li><blockquote>
<p>float：none；设置页面中的元素对象不浮动，主要是将已经设置为浮动的元素改变为非浮动的元素</p>
</blockquote>
</li>
<li><blockquote>
<p>float:left将页面中的元素对象设置为左浮动。如果多个元素同时设置了该属性，那么将会形成一个从右到左的页面布局形式</p>
</blockquote>
</li>
<li><blockquote>
<p>float:right将页面中元素设置为右浮动，如果多个元素同时设置了该属性，那么将会形成一个从右到左的页面布局形式</p>
<h2 id="清除浮动的方式："><a href="#清除浮动的方式：" class="headerlink" title="清除浮动的方式："></a>清除浮动的方式：</h2><ol>
<li>利用br标签中的clear属性清除浮动<br><code>&lt;div class=&quot;float_box&quot;&gt;
&lt;div class=&quot;float_left&quot;&gt;左浮动元素&lt;/div&gt;
&lt;div class=&quot;float_right&quot;&gt;右浮动元素&lt;/div&gt;
&lt;/div&gt;
&lt;br clear=&quot;all&quot;/&gt;
&lt;div class=&quot;no_float&quot;&gt;测试因为浮动导致该容器所处的位置&lt;/div&gt;</code><br>（出现问题：在FF浏览器中我们看到类名为float_box的div标签已经有背景色了，在IE浏览器中并非如此）<br>解决办法：<br><code>.float_box{
background-color:#AAA;
**zoom:1;**</code> <em>解决IE浏览器中haslayout的问题</em><br>}</li>
<li>利用cs样式中的clear属性清除浮动<br>即把前面代码:<br class="clear_float"><br>改为<br class="clear_float"><br>对应css代码为：.clear_float{<br><strong>clear:both;</strong><br>}<br>可能出现问题与前面一样，解决办法相同设置：<strong>zoom：1</strong></li>
<li>利用css样式中的overflow属性清除浮动<br><code>.float_box{
overflow:hidden;
background:#AAA;
zoom:1;
}</code></li>
</ol>
<ul>
<li>overflow：visible；时，清除浮动只对IE有效</li>
<li>overflow：hidden;虽然能解决清除浮动问题，<br>但可能会因为hidden的属性值将溢出的部分隐藏</li>
<li>overflow：auto</li>
</ul>
<ol>
<li>利用css样式中的display：table清除浮动<br><code>.float_box{
display:table;
background-color:#666;
}</code><br>(不推荐使用)</li>
<li>采用伪类：after后续控制的高度为0的为伪类层清除浮动<br><code>.float_box:after{
clear:both;*清除伪类层以上的浮动*
display:block;
visibility:hidden;*设置伪类层内容为块元素且可见*
height:0；
line-height:0;*设置伪类层中的高度和行高为0*
content:&quot;&quot;;*将伪类层中的内容清空*
}</code></li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[作用域，作用域链，域解析]]></title>
      <url>http://yoursite.com/2016/08/18/%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E5%9F%9F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="作用域，作用域链，域解析"><a href="#作用域，作用域链，域解析" class="headerlink" title="作用域，作用域链，域解析"></a>作用域，作用域链，域解析</h1><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>JavaScript执行环境，也叫作JavaScript执行上下文（我百度翻译的(＾－＾)，英文名叫做execution context）<br><code>执行环境：</code>JavaScript代码都是在执行环境中被执行的。执行环境是一个概念，一种机制，用来完成JavaScript运行时在作用域、生命周期等方面的处理，<code>它定义了变量或函数是否有权访问其他数据，决定各自行为。</code></p>
<blockquote>
<p>而且每个执行环境都会有一个就是变量对象VO（variable object），环境中<code>变量和函数声明保存在VO中。</code><br><code>注意</code>，函数表达式（与函数声明相对）不包含在变量对象之中。，在代码执行开始，会进入不同的执行环境，这些执行环境共同构成了一个执行环境栈。<br>如果这个环境是函数，则将其活动对象AO(activation object)作为变量对象,活动对象最开始的两个属性是arguments和this<br><img src="http://obfnbicau.bkt.clouddn.com/ec-stack.png" alt="Alt text"></p>
</blockquote>
<p>在下个图中，拥有一些函数上下文EC1和全局上下文Global EC，当EC1进入和退出全局上下文的时候下面的栈将会发生变化：<br><img src="http://obfnbicau.bkt.clouddn.com/ec-stack-changes.png" alt="Alt text"></p>
<p>JS中一共有三种执行环境：</p>
<ol>
<li><p>全局执行环境（Global code）   JS代码开始运行时默认的<br>即全局的、不在任何函数里面的代码，例如：一个js文件、嵌入在HTML页面中的js代码等<br><code>注意：</code></p>
<ul>
<li>保存在全局执行环境中的所有变量和函数，当其应用程序退出，如：关闭网页或浏览器时被销毁</li>
</ul>
<ul>
<li>全局执行环境是window的对象（所有全局函数和变量都是作为window的属性和方法创建的）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">         var a=2;</div><div class="line">function setB()&#123;</div><div class="line">	return 123;</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line">console.log(setB());</div><div class="line">console.log(window.a);</div><div class="line">console.log(window.setB());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数执行环境（Function code） 代码进入了一个函数<br>每个函数有自己的执行环境，有相应的执行栈</p>
</li>
</ol>
<ul>
<li><p>函数里的局部作用域里的变量替换全局变量，但作用域仅限在函数体内的这个环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">            var a=&apos;哈哈哈~&apos;;</div><div class="line">function setB()&#123;</div><div class="line">	a=&apos;啧啧&apos;;</div><div class="line">&#125;</div><div class="line">setB();</div><div class="line">console.log(a);</div></pre></td></tr></table></figure>
</li>
<li><p>通过传参，可以替换函数体内的局部变量，但作用域仅限在函数体内的这个环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">           var a=&apos;哈哈哈~&apos;;</div><div class="line">function setB(a)&#123;</div><div class="line">	console.log(a);</div><div class="line">&#125;</div><div class="line">setB(&apos;嗯嗯&apos;);</div><div class="line">console.log(a);</div></pre></td></tr></table></figure>
</li>
<li><p>函数体内还包含有函数，只有通过外层函数，才能访问内层函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">      var a=1;</div><div class="line">function setA()&#123;</div><div class="line">	function setB()&#123;</div><div class="line">		var b=2;</div><div class="line">		console.log(a);</div><div class="line">		console.log(b);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	setB()</div><div class="line">&#125;</div><div class="line">setA();</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>eval()方法执行代码<br>eval()就像是一个完整的ECMAScript解析器，只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval(&quot;console.log(&apos;哈哈&apos;)&quot;);</div><div class="line">等价于</div><div class="line">console.log(&apos;哈哈&apos;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eval(&quot;function sayHi()&#123;console.log(&apos;hi&apos;);&#125;&quot;);</div><div class="line">sayHi();</div></pre></td></tr></table></figure></p>
<p>严格模式下，访问不到eval()中创建的任何变量和函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">eval(&quot;function sayHi()&#123;console.log(&apos;hi&apos;);&#125;&quot;);</div><div class="line">sayHi();</div></pre></td></tr></table></figure></p>
<p>应用：JSON解析器<br>危险：代码注入！！！（用户输入数据）</p>
<p>[TOC]</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>域：</code>空间，范围，区域…<br><code>作用：</code>读，写<br>作用域（scope）。在很多语言中（C++，C#，Java），作用域都是通过代码块（由{}包起来的代码）来决定的，但是，在JavaScript作用域是跟函数相关的，也可以说成是function-based。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">      function test(o)&#123;</div><div class="line">	var i=0;</div><div class="line">	if(typeof o==&quot;object&quot;)&#123;</div><div class="line"></div><div class="line">		var j=0;</div><div class="line">		for(var k=0;k&lt;10;k++)&#123;</div><div class="line">			console.log(k);</div><div class="line">		&#125;</div><div class="line">		console.log(k);		</div><div class="line">	&#125;</div><div class="line">	console.log(j);</div><div class="line">&#125;</div><div class="line">var obj=new Object();</div><div class="line">	test(obj);</div></pre></td></tr></table></figure></p>
<ol>
<li>全局作用域中的对象可以在代码的任何地方访问，一般来说，下面情况的对象会在全局作用域中： <ul>
<li>最外层函数和在最外层函数外面定义的变量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 最外层函数和在最外层函数外面定义的变量  </div><div class="line">  		var a = &quot;out&quot;; //最外层变量</div><div class="line">		function outFn() &#123; //最外层函数</div><div class="line">      	var b = &quot;in&quot;;</div><div class="line">    	function inFn() &#123; //内层函数</div><div class="line">        console.log(b);</div><div class="line">    	&#125;</div><div class="line">   		 inFn();</div><div class="line">		&#125;</div><div class="line">		console.log(a); //我是最外层变量</div><div class="line">		outFn(); </div><div class="line">		console.log(b); //in is not defined</div><div class="line">		inFn(); //inFn is not defined</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>没有通过关键字”var”声明的变量 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outFn2() &#123;</div><div class="line">   		a = &quot;未定义&quot;;</div><div class="line">    	var  a1 = &quot;内层变量2&quot;;</div><div class="line">		&#125;</div><div class="line">		outFn2();</div><div class="line">		//要先执行这个函数，否则根本不知道里面是啥</div><div class="line">		console.log(a); //未定义直接赋值的变量</div><div class="line">		console.log(a1); //inVariable2 is not defined</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>浏览器中，window对象的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window对象的内置属性都拥有全局作用域，</div><div class="line">如: window.name、window.location、window.top 等</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>局部作用域(函数作用域)所有的变量和函数只能在作用域内部使用。函数在声明它们的函数体以及这个函数体嵌套的任意函数内都是有定义的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo = 1; </div><div class="line">window.bar = 2;</div><div class="line">function baz()&#123; a = 3; var b = 4; &#125; </div><div class="line">// Global scope: foo, bar, baz, a</div><div class="line">// Local scope: b</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>函数声明提前：<br>js的函数作用域是指在函数内声明的所有变量在函数内始终都是可以见，意味着变量在声明之前就可以使用了，这个特性被非正式命名为<code>声明提前</code>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">         var a=1;</div><div class="line">function fn1()&#123;</div><div class="line">	console.log(a);//???</div><div class="line">	var a=2;</div><div class="line">	console.log(a);</div><div class="line">&#125;</div><div class="line">fn1();</div><div class="line">console.log(a);</div><div class="line">-------------------------------------------------</div><div class="line">         var a=1</div><div class="line">function fn1()&#123;</div><div class="line">var a;//在函数顶部声明了局部变量</div><div class="line">console.log(a);//变量存在，但其值是&quot;undefined&quot;</div><div class="line">a=2;</div><div class="line">console.log(a);</div><div class="line">&#125;</div><div class="line">fn1();</div><div class="line">console.log(a);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>[TOC]</p>
<h2 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="headerlink" title="作用域链(scope chain)"></a>作用域链(scope chain)</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（是保证对执行环境有权访问的的所有变量和函数的<code>有序访问</code>），<code>这个作用域链是一个对象列表或者链表，这组对象定义了代码“作用域”中的变量</code><br><code>创建规则：</code><br>作用域链的前端，始终都是当前执行的代码<br>作用域链中的下一个变量对象，来自包含（外部环境）<br>而再下一个对象来自下一个包含环境<br>一直延续到全局执行环境（全局执行坏境的对象始终都是作用域链中的最后一个对象）</p>
<p> 一个函数创建时，javascript后台(引擎)会默认创建一个仅供后台使用的内部属性[[Scope]]，此属性存储函数的作用域链，如果是全局函数，此时则包含一个变量对象(全局变量)，如果是嵌套函数(闭包)，作用域链还加上了父函数的变量对象。例如下面的这个全局函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add(num1,num2)&#123;</div><div class="line">   var sum = num1 + num2;</div><div class="line">   return sum;</div><div class="line">&#125;</div><div class="line">var total=add(5,10);</div><div class="line">console.log(total);</div></pre></td></tr></table></figure></p>
<p><img src="http://obfnbicau.bkt.clouddn.com/r_%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" alt="Alt text"></p>
<p>b) 函数被调用时–add(5,10)，javascript后台会创建一个内部对象(execution context)–“执行环境”或“运行期上下文”，活动对象作为函数执行期的一个变量对象，包含所有局部变量(在函数内定义的)、命名参数、arguments、this，它会被推入到执行环境作用域链的前端(如下图)。每执行一次函数都会创建一个新的执行环境，当函数执行完毕执行环境就会被销毁。</p>
<p><img src="http://obfnbicau.bkt.clouddn.com/2012061700395832.jpg" alt="Alt text"></p>
<p>图中矩形表示特定的环境。其中内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部变量环境中的任何变量和函数。这些环境之间的联系是线性的，有次序的。每个环境变量都可以向上搜索作用域链，以查询变量和函数名；反之则是不行。<code>注意:</code>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<p><img src="http://obfnbicau.bkt.clouddn.com/scope_chain.jpg" alt="Alt text"></p>
<blockquote>
<p>查询标识符(标识符指的是：变量名称，函数声明，形参，等等。)：标示符的解析是沿着作用域链一级一级的搜索标示符的过程，搜索过程都是从作用域链的前端开始，然后逐级向后回溯，直到找到标识符为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var color=&quot;blue&quot;;</div><div class="line">function getColor()&#123;</div><div class="line">return color;</div><div class="line">&#125;</div><div class="line">console.log(getColor());//&quot;blue&quot;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://obfnbicau.bkt.clouddn.com/%E6%A0%87%E7%A4%BA%E7%AC%A6.jpg" alt="Alt text"></p>
<p>[TOC]</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>try-catch语句的catch块<br>with语句<br>  这两个语句都会在原本的作用域链的前端添加一个变量对象。对于with语句来说，新添加的变量对象包含着with括号中指定对象的所有属性和方法所作的变量声明。对于catch来说，当try块发生错误时，代码执行流程自动转入到catch块，并将异常对象推入到作用域链的前端。catch块执行完毕后，作用域链就会返回原来的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function initUI()&#123;</div><div class="line">   with(document)&#123;</div><div class="line">        var bd = body,</div><div class="line">        links =  getElementsByTagName(&quot;a&quot;),</div><div class="line">        i = 0,</div><div class="line">        len = links.length;</div><div class="line">        while(i&lt;len)&#123;</div><div class="line">              update(links[i++]);</div><div class="line">        &#125;</div><div class="line">        getElementById(&quot;go-btn&quot;).onclick = function()&#123;</div><div class="line">              start();</div><div class="line">        &#125;;</div><div class="line">        bd.className = &quot;active&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当代码流执行到一个with表达式时，执行环境的作用域链会被临时改变，此时with的变量对象会被创建添加到作用域链的前端，这就意味着此时函数的所有局部变量都被推入到第二个作用域链中的变量对象，如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/2012061812093041.gif" alt="Alt text"></p>
<p><code>注意：</code>在执行with语句时，访问局部变量的代价更高了。所以尽可能避免使用with语句，可以使用局部变量代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var doc = document; // 代替with(document)&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>[TOC]</p>
<p>##域解析<br>浏览器：</p>
<ol>
<li><p>预解析：<br>“js解析器”<br>“找一些东西”：var， function<br>，参数<br>a=未定义<br>所有的变量，在正式运行代码之前，都提前赋了一个值（未定义）<br>fn1=function fn1(){console.log(1);}<br>所有的函数，在正式运行代码之前，都是<code>整个函数块</code><br><code>注意：</code>遇到重名，变量和函数重名，就留下函数，与上下文没有关系，注只先找var ，function声明的，函数重名，则采用覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(a);</div><div class="line">var a=2;</div><div class="line">function fn1()&#123;</div><div class="line">console.log(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>逐行解读代码<br>表达式：= + -* / ++ –！ 参数</p>
</li>
</ol>
<ul>
<li>表达式可以修改预解析的值！</li>
<li>函数调用：<br>同理函数作用域也发生：<br>1.预解析和2.逐行解读代码<br>函数：由里到外（作用域链）<br>如：var a=1;改预解析里面的<br>a=function fn1(){console.log(a);}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log(a);//不会从下面取值，直接从预解析的仓库里取出undefined</div><div class="line">var a=2;</div><div class="line">console.log(a);</div><div class="line">function fn1()&#123;</div><div class="line">console.log(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考链接：<br><a href="http://www.cnblogs.com/leolai/archive/2012/06/17/2552326.html" target="_blank" rel="external">https://gaohaoyang.github.io/2015/05/20/scope/</a></p>
<p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context" target="_blank" rel="external">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context</a></p>
<p>参考资料：<br>javaScript高级程序设计<br>javaScript权威指南</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是盒子模型]]></title>
      <url>http://yoursite.com/2015/09/03/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h1><p>盒模型就是指css布局中的每个元素，在浏览器的解释中，都会被当做一个盒模型，浏览器通过这些盒状物的大小和浮动方式来判断下一个盒状物的贴近显示，还是下一行显示，还是其他方式显示，任何一个css布局的网页，都是由许多不同大小盒子构成。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。<br>对盒模型的形象化表述盒模型形象化表述：<br>将页面中的任何一个元素形容成邮局的每一个邮包 </p>
<ul>
<li>邮寄的物品—-页面中的元素内容 </li>
<li>塞入的海绵—-内边距padding </li>
<li>邮局的纸盒邮包—-边框border </li>
<li>邮包堆积之间的间距—–外边距margin<br><code>注意：</code> 盒模型类似于邮局纸盒邮包情况，却又不等同于，<br>但IE在某种情况下，却又完全等同于纸盒邮包情形（邮局的纸盒中无论塞入多少海绵保护邮寄物品，邮局的纸盒邮包的大小是不会变的，而页面中元素不同，padding属性值越大，那么所占用的空间也就越大）<br>DOCTYPE类型声明影响IE浏览器对标准的理解：<br>IE浏览器存在两种渲染方式： </li>
</ul>
<ol>
<li>Quirks(怪异模式)：以一种比较宽松的向后兼容的方式显示<br>触发怪异模式使IE浏览器计算盒模型的方式有所变化（至于怎么触发怪异模式：如：在DOCTYPE类型前加一个字符，或者将它直接删除了）<br>计算方式的改变就是：<br>将盒模型的border和padding的数值归入到<br>盒模型的宽度width及高度height<br>盒模型宽=margin-left+width+margin-right<br>盒模型高=margin-top+height+margin-bottom </li>
<li>Standard(标准模式)：浏览器根据规范表现页面<br>cmd-markdown-logo<br>盒模型的细节：<br>盒模型差异<br>IE6/IE7/Firefox的最终宽度=左外边距+左边框宽+左内边距+宽度+右外边距+右边框宽+右内边距<br>IE5的最终宽度=左外边距+宽度+右外边距<br>（1）上下margin叠加问题<br>.a{<br>Width:100px;<br>Height:100px;<br>Background-color:#eeffee;<br>Border:1px solid #bbb;<br>Margin:10px;<br>}<br>.b{<br>Width:100px;<br>Height:100px;<br>Background-color:#ccc;<br>Border:1px solid #ddd;<br>Margin:10px;<br>}<br>空白边叠加时，结果以最大者为准<br>解决办法：把相应元素设为float属性，它们将不会发生空白叠加问题了<br>（2）左右margin叠加问题<br>当盒对象为浮动状态时，IE6中，盒模型的左右margin会加倍<br>解决办法：display:inline;</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ps的基础知识]]></title>
      <url>http://yoursite.com/2015/09/02/%E5%85%B3%E4%BA%8Eps%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>##前端ps基础技能需求：<strong>切图</strong>，<strong>修图</strong>，<strong>测量</strong></p>
<p> <strong>前端常用 ps工具：</strong><br> 移动工具，矩形选框工具，裁切工具，吸管工具，横排文字工具，手抓，缩放，标尺，自由变换<br> <strong>ps快捷键：</strong><br>窗口（历史记录，信息（F8），图层（F7））<br>视图（参考线设置）<br>图像（图像大小（alt+ctrl+i），画布大小（alt+ctrl+c），剪裁，剪切）<br>文件（存储为web和设备所用格式（alt+shift+ctrl+c））<br>左侧工具栏的使用（移动工具，矩形选框工具，吸管工具，横排文字工具，抓手工具，放大/缩小工具）<br>Ctrl+/ctrl-放大、缩小  Ctrl+R标尺 shift+tab调板  Ctrl+h 参考线</p>
<blockquote>
<p>图片的导出格式：<br>保存文件格式:</p>
<ol>
<li>psd（源文件：没办法直接使用）</li>
<li>JPG：不支持透明半透明，所有空白区域填充白色（应用：网页中的大图，高清图（体积大））</li>
<li>GIF（png8：小图标）：支持透明，不支持半透明（小图标（动画图片）</li>
<li>png24：支持透明，也支持半透明（图像中存在半透明效果的图片）</li>
</ol>
</blockquote>
<p>  <em>psd测量注意事项：</em><br>文字右方和下方会有1像素的默认间隙 </p>
<p>ps一些基本操作：</p>
<ul>
<li>删除图片上的文字：</li>
</ul>
<ol>
<li>矩形选框选中删除区域，按delete删除键</li>
<li>矩形选中相应模块（盖住文字的部分），再按Ctrl+t（自由变换）推动模块，即可盖住文字</li>
</ol>
<ul>
<li>如何把选中图像变成白色：</li>
</ul>
<ol>
<li>选中要变白的图像并且选中相应图层—将右下角背景调为白色–点击油漆桶工具（位于渐变工具一栏）即可</li>
</ol>
<ul>
<li>图像放大了之后，目的就是要仔细观察细节，图像太大以至于画布装不下了，要拖动滚动条吧太麻烦，这里不用拖动滚动条。按住“空格键”不松手，赶紧观察，发现情况了没有，鼠标变成抓手工具形状了</li>
<li>如果要将图像调整到什么程度，要求图像都能清晰显示窗口–&gt;图层–&gt;智能对象–&gt;图像–&gt;画布大小</li>
<li>将图像改变方向：图像–&gt;图像旋转（180度，90度，90度逆时针等）</li>
</ul>
<blockquote>
<p>切图：实现精确选图：拉出参考线后，选择矩形区域，按住Ctrl键（图像颜色表现有变浅的表现）<br>图层：图层后优先级与后面出现的数字无关，与排列在前面的顺序有关</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
