<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[js常用的正则表达式]]></title>
      <url>http://yoursite.com/2017/05/25/js%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">一、校验数字的表达式</div><div class="line">// 1.数字：</div><div class="line">^[0-9]*$</div><div class="line">//2.n位的数字：</div><div class="line">^\d&#123;n&#125;$</div><div class="line">//3.至少n位的数字：</div><div class="line">^\d&#123;n,&#125;$</div><div class="line">//4.m-n位的数字：</div><div class="line">^\d&#123;m,n&#125;$</div><div class="line">//5.零和非零开头的数字：</div><div class="line">^(0|[1-9][0-9]*)$</div><div class="line">//6.非零开头的最多带两位小数的数字：</div><div class="line">^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</div><div class="line">//7.带1-2位小数的正数或负数：</div><div class="line">^(-)?\d+(.\d&#123;1,2&#125;)?$</div><div class="line">//8.正数、负数、和小数：</div><div class="line">^(-|+)?\d+(.\d+)?$</div><div class="line">//9.有两位小数的正实数：</div><div class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</div><div class="line">//10.有1~3位小数的正实数：</div><div class="line">^[0-9]+(.[0-9]&#123;1,3&#125;)?$</div><div class="line">//11.非零的正整数：</div><div class="line">^[1-9]\d$ 或 ^([1-9][0-9])&#123;1,3&#125;$ 或 ^+?[1-9][0-9]*$</div><div class="line">//12.非零的负整数：</div><div class="line">^-[1-9][]0-9$ 或 ^-[1-9]\d$</div><div class="line">//13.非负整数：</div><div class="line">^\d+$ 或 ^[1-9]\d*|0$</div><div class="line">//14.非正整数：</div><div class="line">^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</div><div class="line">//15.非负浮点数：</div><div class="line">^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$</div><div class="line">//16.非正浮点数：</div><div class="line">^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$</div><div class="line">//17.正浮点数：</div><div class="line">^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$</div><div class="line">//18.负浮点数：</div><div class="line">^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$</div><div class="line">//19.浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$</div><div class="line">二、校验字符的表达式</div><div class="line">//1.汉字：</div><div class="line">^[\u4e00-\u9fa5]&#123;0,&#125;$</div><div class="line">//2.英文和数字：</div><div class="line">^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</div><div class="line">//3.长度为3-20的所有字符：</div><div class="line">^.&#123;3,20&#125;$</div><div class="line">//4.由26个英文字母组成的字符串：</div><div class="line">^[A-Za-z]+$</div><div class="line">//5.由26个大写英文字母组成的字符串：</div><div class="line">^[A-Z]+$</div><div class="line">//6.由26个小写英文字母组成的字符串：</div><div class="line">^[a-z]+$</div><div class="line">//7.由数字和26个英文字母组成的字符串：</div><div class="line">^[A-Za-z0-9]+$</div><div class="line">//8.由数字、26个英文字母或者下划线组成的字符串：</div><div class="line">^\w+$ 或 ^\w&#123;3,20&#125;$</div><div class="line">//9.中文、英文、数字包括下划线：</div><div class="line">^[\u4E00-\u9FA5A-Za-z0-9_]+$</div><div class="line">//10.中文、英文、数字但不包括下划线等符号：</div><div class="line">^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</div><div class="line">//11. 可以输入含有^%&amp;&apos;,;=?$\&quot;等字符：</div><div class="line">//[^%&amp;&apos;,;=?$\x22]+</div><div class="line">//12.禁止输入含有~的字符：</div><div class="line">[^~\x22]+</div><div class="line">三、特殊需求表达式</div><div class="line">//1.Email地址：</div><div class="line">^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$</div><div class="line">//2.域名：</div><div class="line">[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</div><div class="line">//3.InternetURL：</div><div class="line">[a-zA-z]+://[^\s] 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=])?$</div><div class="line">//4.手机号码：</div><div class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</div><div class="line">//5.电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：</div><div class="line">	^((\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</div><div class="line">//6.国内电话号码(0511-4405222、021-87888822)：</div><div class="line">\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</div><div class="line">//7.身份证号(15位、18位数字)：</div><div class="line">^\d&#123;15&#125;|\d&#123;18&#125;$</div><div class="line">//8.短身份证号码(数字、字母x结尾)：</div><div class="line">^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$</div><div class="line">//9.帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</div><div class="line">//10.密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：</div><div class="line">^[a-zA-Z]\w&#123;5,17&#125;$</div><div class="line">//11.强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：</div><div class="line">^(?=.\d)(?=.[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</div><div class="line">//12.日期格式：</div><div class="line">^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</div><div class="line">//13.一年的12个月(01～09和1～12)：</div><div class="line">^(0?[1-9]|1[0-2])$</div><div class="line">//14. 一个月的31天(01～09和1～31)：</div><div class="line">^((0?[1-9])|((1|2)[0-9])|30|31)$</div><div class="line">//15.钱的输入格式：</div><div class="line">//16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：</div><div class="line">^[1-9][0-9]*$</div><div class="line">//17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：</div><div class="line">^(0|[1-9][0-9]*)$</div><div class="line">//18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：</div><div class="line">^(0|-?[1-9][0-9]*)$</div><div class="line">//19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：</div><div class="line">^[0-9]+(.[0-9]+)?$</div><div class="line">//20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：</div><div class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</div><div class="line">//21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：</div><div class="line">^[0-9]+(.[0-9]&#123;1,2&#125;)?$</div><div class="line">//22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：</div><div class="line">^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</div><div class="line">//23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：</div><div class="line">^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</div><div class="line">//24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</div><div class="line">//25 xml文件：</div><div class="line">^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</div><div class="line">//26 中文字符的正则表达式：</div><div class="line">[\u4e00-\u9fa5]</div><div class="line">//27 双字节字符：(包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</div><div class="line">[^\x00-\xff] </div><div class="line">//28 空白行的正则表达式： (可以用来删除空白行)</div><div class="line">\n\s*\r</div><div class="line">//29 HTML标记的正则表达式：(网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</div><div class="line">&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt; </div><div class="line">//30 首尾空白字符的正则表达式：(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</div><div class="line">^\s|\s$或(^\s)|(\s$) </div><div class="line">//31 腾讯QQ号：(腾讯QQ号从10000开始)</div><div class="line">[1-9][0-9]&#123;4,&#125; </div><div class="line">//32 中国邮政编码：(中国邮政编码为6位数字)</div><div class="line">[1-9]\d&#123;5&#125;(?!\d) </div><div class="line">//33 IP地址： (提取IP地址时有用)</div><div class="line">\d+.\d+.\d+.\d+</div><div class="line">//34 IP地址：</div><div class="line">((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[new做了啥？]]></title>
      <url>http://yoursite.com/2017/04/15/new%E5%81%9A%E4%BA%86%E5%95%A5/</url>
      <content type="html"><![CDATA[<p>当代码 new foo(…) 执行时：来自：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="external">MDN</a></p>
<ol>
<li>一个新对象被创建。它继承自foo.prototype.</li>
<li>构造函数 foo 被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo(), 只能用在不传递任何参数的情况。</li>
<li>如果构造函数返回了一个“对象”，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象，ps：一般情况下构造函数不返回任何值，不过用户如果想覆盖这个返回值，可以自己选择返回一个普通对象来覆盖。当然，返回数组也会覆盖，因为数组也是对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Myclass()&#123;  </div><div class="line">    this.a=20;</div><div class="line">&#125;</div><div class="line">var o=new Myclass();  </div><div class="line">console.log(o.a);   //20</div><div class="line"></div><div class="line"></div><div class="line">function Person()&#123;  </div><div class="line">    this.a=20;</div><div class="line">    return &#123;  a: 21&#125;;</div><div class="line">&#125;</div><div class="line">var o=new Person();  </div><div class="line">console.log(o.a);   //21注意返回对象代替整个new出来的o</div></pre></td></tr></table></figure>
</li>
</ol>
<p>举一个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 正常创建一个对象</div><div class="line">function Super() &#123;&#125;;</div><div class="line">var s = new Super();</div></pre></td></tr></table></figure></p>
<p>以上其实等价于3个步骤:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 3个步骤</div><div class="line">var s = &#123;&#125;;</div><div class="line">s.__proto__ = Super.prototype;</div><div class="line">Super.call(s);</div><div class="line"># 注：1.2两步，其实就是Object.create(Super.prototype);</div></pre></td></tr></table></figure></p>
<ol>
<li><p>创建一个空对象{}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var s = &#123;&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造函数的prototype 给 实例对象的 proto</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.__proto__ === Super.prototype</div></pre></td></tr></table></figure>
</li>
<li><p>初始化对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 把s当做Super中的this，做初始化s的操作</div><div class="line">Super.call(s);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># 例如</div><div class="line">function Super() &#123;</div><div class="line">  this.y = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 通过</div><div class="line">Super.call(s);</div><div class="line"></div><div class="line"># 其实就相当于</div><div class="line">Super(_this) &#123;</div><div class="line">    _this.y = 1;</div><div class="line">&#125;</div><div class="line">Super(s);//明白this其实就是new出来那个对象了吧</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript单线程和Event loop]]></title>
      <url>http://yoursite.com/2017/04/07/JavaScript%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="单线程你联想到什么？"><a href="#单线程你联想到什么？" class="headerlink" title="单线程你联想到什么？"></a>单线程你联想到什么？</h2><p>哦！操作系统课上讲过？对</p>
<ol>
<li><p>线程和进程：</p>
<blockquote>
<p>进程和线程都是操作系统的概念。进程是应用程序的执行实例，每一个进程都是由私有的虚拟地址空间、代码、数据和其它系统资源所组成；进程在运行过程中能够申请创建和使用系统资源（如独立的内存区域等），这些资源也会随着进程的终止而被销毁。而线程则是进程内的一个独立执行单元，在不同的线程之间是可以共享进程资源的，所以在多线程的情况下，需要特别注意对临界资源的访问控制。在系统创建进程之后就开始启动执行进程的主线程，而进程的生命周期和这个主线程的生命周期一致，主线程的退出也就意味着进程的终止和销毁。主线程是由系统进程所创建的，同时用户也可以自主创建其它线程，这一系列的线程都会并发地运行于同一个进程中。</p>
</blockquote>
<p>显然，在多线程操作下可以实现应用的并行处理，从而以更高的CPU利用率提高整个应用程序的性能和吞吐量。特别是现在很多语言都支持多核并行处理技术，然而JavaScript却以单线程执行，为什么呢？</p>
</li>
<li>Why？JavaScript单线程<br><code>用途决定：</code><br>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5的Web<br>Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。<h2 id="并发模式与Event-Loop"><a href="#并发模式与Event-Loop" class="headerlink" title="并发模式与Event Loop"></a>并发模式与Event Loop</h2>javaScript 有个基于“Event Loop”并发的模型。<br>啊，并发？不是说 JavaScript是单线程吗？ 没错，的确是单线程，但是并发与并行是有区别的。<br>前者是逻辑上的同时发生，而后者是物理上的同时发生。所以，单核处理器也能实现并发。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170407/190823372.jpg" alt="mark"><br>并行大家都好理解，而所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生。如上图的第一个表，由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。<h2 id="javaScipt怎样实现并发模式呢？"><a href="#javaScipt怎样实现并发模式呢？" class="headerlink" title="javaScipt怎样实现并发模式呢？"></a>javaScipt怎样实现并发模式呢？</h2>答案：JavaScript Runtime<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170407/191910631.jpg" alt="mark"></li>
<li>Stack（栈）<br>这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function f(b)&#123;</div><div class="line">  var a = 12;</div><div class="line">  return a+b+35;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function g(x)&#123;</div><div class="line">  var m = 4;</div><div class="line">  return f(m*x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">g(21);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码调用 g 时，创建栈的第一帧，该帧包含了 g 的参数和局部变量。当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。当 f 返回时，其对应的帧就会出栈。同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）。</p>
<ol>
<li>Heap（堆）<br>一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。</li>
<li>Queue（队列）<br>一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。（Queue的特点是先进先出 First-in First-out (FIFO)）。<br>为了方便描述与理解，作出以下约定：</li>
</ol>
<ul>
<li>Stack栈为主线程</li>
<li>Queue队列为任务队列（等待调度到主线程执行）<br>下图就是主线程和任务队列的示意图。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170407/192257033.jpg" alt="mark"><h2 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h2>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。<br>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。<br>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。<br>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170407/192526312.png" alt="mark"><br>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。<br>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var req = new XMLHttpRequest();</div><div class="line">   req.open(&apos;GET&apos;, url);    </div><div class="line">   req.onload = function ()&#123;&#125;;    </div><div class="line">   req.onerror = function ()&#123;&#125;;    </div><div class="line">   req.send();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var req = new XMLHttpRequest();</div><div class="line">req.open(&apos;GET&apos;, url);</div><div class="line">req.send();</div><div class="line">req.onload = function ()&#123;&#125;;    </div><div class="line">req.onerror = function ()&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>包括setTimeout与setInterval两个方法。它们的第二个参数是指定其回调函数推迟每隔多少毫秒数后执行。<br>对于第二个参数有以下需要注意的地方：</p>
<ul>
<li>当第二个参数缺省时，默认为0；</li>
<li>当指定的值小于4毫秒，则增加到4ms（4ms是HTML5标准指定的，对于2010年及之前的浏览器则是10ms）；<br>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。<br>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。<br>setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(1);</div><div class="line">setTimeout(function()&#123;console.log(2);&#125;,1000);</div><div class="line">console.log(3);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。<br>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;console.log(1);&#125;, 0);</div><div class="line">console.log(2);</div></pre></td></tr></table></figure></p>
<p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。<br>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。<br>参考链接：<br><a href="https://segmentfault.com/a/1190000004276027" target="_blank" rel="external">https://segmentfault.com/a/1190000004276027</a><br><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[__proto_和prototype]]></title>
      <url>http://yoursite.com/2017/03/18/prototype%EF%BC%88%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="prototype（显式原型）"><a href="#prototype（显式原型）" class="headerlink" title="prototype（显式原型）"></a>prototype（显式原型）</h2><p>先让我们看看官方解释：<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5" target="_blank" rel="external">ECMA</a></p>
<blockquote>
<p>The value of the prototype property is used to initialise the [[Prototype]] internal property of a newly created object before the Function object is invoked as a constructor for that newly created object. This property has the attribute { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.<br><code>NOTE</code>  Function objects created using Function.prototype.bind do not have a prototype property.<br>译：<br>在调用Function对象作为新创建的对象的构造函数之前，prototype属性的值用于初始化新创建的对象的[[Prototype]]内部属性。该属性的属性为{[Writable]]：true，[[Enumerable]]：false，[[Configurable]]：false}。 注意使用Function.prototype.bind创建的函数对象不具有prototype属性。</p>
</blockquote>
<ol>
<li>每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 （这也是原型链实现的一部分）<h2 id="proto（隐式原型）"><a href="#proto（隐式原型）" class="headerlink" title="proto（隐式原型）"></a><strong>proto</strong>（隐式原型）</h2>JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<strong>proto</strong>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().<br>Note: Object.prototype这个对象是个例外，它的<strong>proto</strong>值为null<h2 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h2>隐式原型指向创建这个对象的函数(constructor)的prototype<h2 id="有什么作用？"><a href="#有什么作用？" class="headerlink" title="有什么作用？"></a>有什么作用？</h2></li>
<li>显式原型的作用：用来实现基于原型的继承与属性的共享。</li>
<li>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<strong>proto</strong>依次查找。<h2 id="proto的指向"><a href="#proto的指向" class="headerlink" title="proto的指向"></a><strong>proto</strong>的指向</h2><strong>proto</strong>的指向到底如何判断呢？根据ECMA定义 ‘to the value of its constructor’s “prototype” ‘ —-指向创建这个对象的函数的显式原型。所以关键的点在于找到创建这个对象的构造函数，接下来就来看一下JS中对象被创建的方式，一眼看过去似乎有三种方式：（1）对象字面量的方式 （2）new 的方式 （3）ES5中的Object.create() 但是我认为本质上只有一种方式，也就是通过new来创建。为什么这么说呢，首先字面量的方式是一种为了开发人员更方便创建对象的一个语法糖，本质就是 var o = new Object(); o.xx = xx;o.yy=yy; 再来看看Object.create(),这是ES5中新增的方法，在这之前这被称为原型式继承，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line">    function F()&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    return new F()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>所以从实现代码 return new F() 中我们可以看到，这依然是通过new来创建的。不同之处在于由 Object.create() 创建出来的对象没有构造函数，看到这里你是不是要问，没有构造函数我怎么知道它的<strong>proto</strong>指向哪里呢，其实这里说它没有构造函数是指在 Object.create() 函数外部我们不能访问到它的构造函数，然而在函数内部实现中是有的，它短暂地存在了那么一会儿。假设我们现在就在函数内部，可以看到对象的构造函数是F, 现在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//以下是用于验证的伪代码</div><div class="line">var f = new F(); </div><div class="line">//于是有</div><div class="line">f.__proto__ === F.prototype //true</div><div class="line">//又因为</div><div class="line">F.prototype === o;//true</div><div class="line">//所以</div><div class="line">f.__proto__ === o;</div></pre></td></tr></table></figure></p>
<p>因此由Object.create(o)创建出来的对象它的隐式原型指向o。好了，对象的创建方式分析完了，现在你应该能够判断一个对象的<strong>proto</strong>指向谁了。</p>
<h2 id="疑惑栗子"><a href="#疑惑栗子" class="headerlink" title="疑惑栗子"></a>疑惑栗子</h2><ol>
<li>构造函数的显示原型的隐式原型：<br>内建对象：比如Array()，Array.prototype.<strong>proto</strong>指向什么？Array.prototype也是一个对象，对象就是由 Object() 这个构造函数创建的，因此Array.prototype.<strong>proto</strong> === Object.prototype //true，或者也可以这么理解，所有的内建对象都是由Object()创建而来。</li>
<li><p>自定义对象<br>（１） 默认情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> function Foo()&#123;&#125;</div><div class="line">var foo = new Foo()</div><div class="line">Foo.prototype.__proto__ === Object.prototype //true 理由同上</div></pre></td></tr></table></figure>
<p>（２）　其他情况</p>
<ul>
<li><p>继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> function Bar()&#123;&#125;</div><div class="line">//这时我们想让Foo继承Bar</div><div class="line">Foo.prototype = new Bar()</div><div class="line"> Foo.prototype.__proto__ === Bar.prototype //true</div></pre></td></tr></table></figure>
</li>
<li><p>重写原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> //我们不想让Foo继承谁，但是我们要自己重新定义Foo.prototype</div><div class="line">Foo.prototype = &#123;</div><div class="line">  a:10,</div><div class="line">  b:-10</div><div class="line">&#125;</div><div class="line">//这种方式就是用了对象字面量的方式来创建一个对象，根据前文所述 </div><div class="line">Foo.prototype.__proto__ === Object.prototype</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>构造函数的隐式原型<br>既然是构造函数那么它就是Function（）的实例，因此也就指向Function.prototype,比如 Object.<strong>proto</strong> === Function.prototype<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2>instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。它的内部实现原理是这样的： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//设 L instanceof R </div><div class="line">//通过判断</div><div class="line"> L.__proto__.__proto__ ..... === R.prototype ？</div><div class="line">//最终返回true or false</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>也就是沿着L的<strong>proto</strong>一直寻找到原型链末端，直到等于R.prototype为止。知道了这个也就知道为什么以下这些奇怪的表达式为什么会得到相应的值了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Function instanceof Object // true </div><div class="line"> Object instanceof Function // true </div><div class="line"> Function instanceof Function //true</div><div class="line"> Object instanceof Object // true</div><div class="line"> Number instanceof Number //false</div></pre></td></tr></table></figure></p>
<h2 id="最后一张图搞定"><a href="#最后一张图搞定" class="headerlink" title="最后一张图搞定"></a>最后一张图搞定</h2><p><img src="http://obfnbicau.bkt.clouddn.com/blog/20170404/193245058.png" alt="mark"><br>参考链接：<a href="https://www.zhihu.com/question/34183746" target="_blank" rel="external">https://www.zhihu.com/question/34183746</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你的Promise]]></title>
      <url>http://yoursite.com/2017/03/07/%E4%BD%A0%E7%9A%84Promise/</url>
      <content type="html"><![CDATA[<h1 id="你的Promise"><a href="#你的Promise" class="headerlink" title="你的Promise"></a>你的Promise</h1><p>在JavaScript的世界里，所有代码都是单线程执行的。由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。<br><code>js中异步编程主要指的是setTimout/setInterval、DOM事件机制、ajax，通过传入回调函数实现控制反转。异步编程为js带来强大灵活性的同时，也带来了嵌套回调的问题。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function callback() &#123;</div><div class="line">    console.log(&apos;Done&apos;);</div><div class="line">&#125;</div><div class="line">console.log(&apos;before setTimeout()&apos;);</div><div class="line">setTimeout(callback, 1000); // 1秒钟后调用callback函数</div><div class="line">console.log(&apos;after setTimeout()&apos;);</div></pre></td></tr></table></figure>
<h2 id="串行执行若干异步"><a href="#串行执行若干异步" class="headerlink" title="串行执行若干异步"></a>串行执行若干异步</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function ajax(method,url,data)&#123;</div><div class="line">var request=new XMLHttpRequest();</div><div class="line">return new Promise(function(resolve,reject)&#123;</div><div class="line">		if(request.readyState===4)&#123;</div><div class="line">			if(request.status===200)&#123;</div><div class="line">				resolve(request.responseText);</div><div class="line">			&#125;else&#123;</div><div class="line">			reject(request.status);</div><div class="line">		&#125;</div><div class="line">			&#125;</div><div class="line">		request.open(method,url);</div><div class="line">		request.send(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line">var log=document.getElementById(&quot;div&quot;);</div><div class="line">var p=ajax(&apos;GET&apos;,&apos;/api/categories&apos;);</div><div class="line">p.then(function(text)&#123;</div><div class="line">	log.innerText=text;</div><div class="line">&#125;).catch(function(status)&#123;</div><div class="line">	log.innerText=&apos;ERROR:&apos;+status;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Promise还可以并行执行异步任务"><a href="#Promise还可以并行执行异步任务" class="headerlink" title="Promise还可以并行执行异步任务"></a>Promise还可以并行执行异步任务</h2><ol>
<li>Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例<br>var p=Promise.all([p1,p2,p3]);p1,p2,p3都是Promise对象的实例（Promise.all()参数只要是Iterator接口）分两种状态：</li>
</ol>
<ul>
<li>p1,p2,p3三者都是Fulfilled,p的状态才变成Fulfilled</li>
<li>只要p1,p2,p3中有一个被rejected则p就被rejected</li>
</ul>
<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 500, &apos;P1&apos;);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 600, &apos;P2&apos;);</div><div class="line">&#125;);</div><div class="line">// 同时执行p1和p2，并在它们都完成后执行then:</div><div class="line">Promise.all([p1, p2]).then(function (results) &#123;</div><div class="line">    console.log(results); // 获得一个Array: [&apos;P1&apos;, &apos;P2&apos;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>
</blockquote>
<ol>
<li>Promise.race()方法，<br>var Promise.race([p1,p2,p3]);只要p1，p2,p3有一个实例率先改变状态，p的状态就会跟着改变，并且返回改变的那个实例的返回值就给p的回调函数。(而那些后面的返回值仍在执行，但被丢弃)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 500, &apos;P1&apos;);</div><div class="line">&#125;);</div><div class="line">var p2 = new Promise(function (resolve, reject) &#123;</div><div class="line">    setTimeout(resolve, 600, &apos;P2&apos;);</div><div class="line">&#125;);</div><div class="line">Promise.race([p1, p2]).then(function (result) &#123;</div><div class="line">    console.log(result); // &apos;P1&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Promise的附加方法"><a href="#Promise的附加方法" class="headerlink" title="Promise的附加方法"></a>Promise的附加方法</h2><ol>
<li>done()<br>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunc()</div><div class="line">  .then(f1)</div><div class="line">  .catch(r1)</div><div class="line">  .then(f2)</div><div class="line">  .done();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它的实现代码非常简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.done = function (onFulfilled, onRejected) &#123;</div><div class="line">  this.then(onFulfilled, onRejected)</div><div class="line">    .catch(function (reason) &#123;</div><div class="line">      // 抛出一个全局错误</div><div class="line">      setTimeout(() =&gt; &#123; throw reason &#125;, 0);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li>finally()<br>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。<br>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.listen(0)</div><div class="line">  .then(function () &#123;</div><div class="line">    // run test</div><div class="line">  &#125;)</div><div class="line">  .finally(server.stop);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>它的实现也很简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Promise.prototype.finally = function (callback) &#123;</div><div class="line">  let P = this.constructor;</div><div class="line">  return this.then(</div><div class="line">    value  =&gt; P.resolve(callback()).then(() =&gt; value),</div><div class="line">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>参考链接：<br><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000" target="_blank" rel="external">http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS内存泄漏排查方法——Chrome Profiles]]></title>
      <url>http://yoursite.com/2017/03/04/JS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94Chrome%20Profiles/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Google Chrome浏览器提供了非常强大的JS调试工具，Heap Profiling便是其中一个。Heap Profiling可以记录当前的堆内存heap快照，并生成对象的描述文件，该描述文件给出了当时JS运行所用到的所有对象，以及这些对象所占用的内存大小、引用的层级关系等等。这些描述文件为内存泄漏的排查提供了非常有用的信息。</p>
<h2 id="Heap-Profiling"><a href="#Heap-Profiling" class="headerlink" title="Heap Profiling"></a>Heap Profiling</h2><ol>
<li>什么是heap？<br>JS运行的时候，会有栈内存（stack）和堆内存（heap），当我们用new实例化一个类的时候，这个new出来的对象就保存在heap里面，而这个对象的引用则存储在stack里。程序通过stack里的引用找到这个对象。例如var a = [1,2,3];，a是存储在stack里的引用，heap里存储着内容为[1,2,3]的Array对象。</li>
<li>使用<br>打开Chrome浏览器-&gt;按下F12调出调试工具-&gt;点击“Profiles”标签。可以看到下图：<br>[<img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/221623227.jpg" alt="mark">][1]<br>可以看到，该面板可以监控CPU、CSS和内存，选中“Take Heap Snapshot”，点击“Start”按钮，就可以拍下当前JS的heap快照，如下图所示：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/221828288.jpg" alt="mark"><br>右边视图列出了heap里的对象列表。由于游戏大厅使用了Quark游戏库，所以这里可以清楚地看到Quark.XXX之类的类名称（即Function对象的引用名称）。<br>注意：每次拍快照前，都会先自动执行一次GC，所以在视图里的对象都是可及的。<h3 id="视图解释"><a href="#视图解释" class="headerlink" title="视图解释"></a>视图解释</h3></li>
</ol>
<ul>
<li>Constructor — 类名Distance — 估计是对象到根的引用层级距离</li>
<li>Objects Count — 给出了当前有多少个该类的对象</li>
<li>Shallow Size — 对象所占内存（不包含内部引用的其它对象所占的内存）(单位：字节)</li>
<li>Retained Size —对象所占总内存（包含内部引用的其它对象所占的内存）(单位：字节)<br>下面解释一下部分类名称所代表的意思：</li>
<li>(compiled code) — 未知，估计是程序代码区</li>
<li>(closure) — 闭包(array) — 未知</li>
<li>Object — JS对象类型(system) — 未知</li>
<li>(string) — 字符串类型，有时对象里添加了新属性，属性的名称也会出现在这里</li>
<li>Array — JS数组类型cls — 游戏大厅特有的继承类</li>
<li>Window — JS的window对象</li>
<li>Quark.DisplayObjectContainer — Quark引擎的显示容器类</li>
<li>Quark.ImageContainer — Quark引擎的图片类</li>
<li>Quark.Text — Quark引擎的文本类</li>
<li>Quark.ToggleButton — Quark引擎的开关按钮类<br>对于cls这个类名，是由于游戏大厅的继承机制里会使用“cls”这个引用名称，指向新建的继承类，所以凡是使用了该继承机制的类实例化出来的对象，都放在这里。例如程序中有一个类ClassA，继承了Quark.Text，则new出来的对象是放在cls里，不是放在Quark.Text里。<h3 id="查看对象内容"><a href="#查看对象内容" class="headerlink" title="查看对象内容"></a>查看对象内容</h3>点击类名左边的三角形，可以看到所有该类的对象。对象后面的“@70035”表示的是该对象的ID（有人会错认为是内存地址，GC执行后，内存地址是会变的，但对象ID不会）。把鼠标停留在某一个对象上，会显示出该对象的内部属性和当时的值。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222202248.jpg" alt="mark"><h3 id="查看对象的引用关系"><a href="#查看对象的引用关系" class="headerlink" title="查看对象的引用关系"></a>查看对象的引用关系</h3>点击其中一个对象，能看到对象的引用层级关系，如下图:<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222307136.jpg" alt="mark"><br>Object’s retaining tree视图显示出了该对象被哪些对象引用了，以及<br>这个引用的名称。图中的这个对象被5个对象引用了，分别是：</li>
<li>一个cls对象的 _txtContent 变量；</li>
<li>一个闭包函数的context变量；</li>
<li>同一个闭包函数的self变量；</li>
<li>一个数组对象的0位置；</li>
<li>一个Quark.Tween对象的target变量。<br>看到context和self这两个引用，可以知道这个Quark.Text对象使用了JS常用的上下文绑定机制，被一个闭包里的变量引用着，相当于该Quark.Text对象多了两个引用，这种情况比较容易出现内存泄漏，如果闭包函数不释放，这个Quark.Text对象也释放不了。<br>展开_textContent，可以看到下一级的引用：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222505619.jpg" alt="mark"><br>把这个树状图反过来看，可以看到，该对象(ID @70035)其中的一条引用链是这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GameListV       _curV       _gameListV    省略...</div><div class="line">                  \         |        /</div><div class="line">                    \       |       /</div><div class="line">                  _noticeWidget</div><div class="line">                           |</div><div class="line">                     _noticeC</div><div class="line">                           |</div><div class="line">                     _noticeV</div><div class="line">                           |</div><div class="line">                  _txtContent</div><div class="line">                           ||</div><div class="line">             Quark.Text @70035</div></pre></td></tr></table></figure>
</li>
</ul>
<p>内存快照的对比通过快照对比的功能，可以知道程序在运行期间哪些对象变更了。<br>刚才已经拍下了一个快照，接下来再拍一次，如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222617807.jpg" alt="mark"><br>点击图中的黑色实心圆圈按钮，即可得到第二个内存快照：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222654359.jpg" alt="mark"><br>然后点击图中的“Snapshot 2”，视图才会切换到第二次拍的快照<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222725528.jpg" alt="mark"><br>点击图中的“Summary”，可弹出一个列表，选择“Comparison”选项，结果如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222840512.jpg" alt="mark"><br>这个视图列出了当前视图与上一个视图的对象差异。列名字段解释：# New — 新建了多少个对象# Deleted — 回收了多少个对象# Delta — 对象变化值，即新建的对象个数减去回收了的对象个数Size Delta — 变化的内存大小(字节)注意Delta字段，尤其是值大于0的对象。下面以Quark.Tween为例子，展开该对象，可看到如下图所示：<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170402/222918536.jpg" alt="mark"><br>在“# New”列里，如果有“.”，则表示是新建的对象。<br>在“# Deleted”列里，如果有“.”，则表示是回收了的对象。<br>平时排查问题的时候，应该多拍几次快照进行对比，这样有利于找出其中的规律。</p>
<h2 id="内存泄漏的排查"><a href="#内存泄漏的排查" class="headerlink" title="内存泄漏的排查"></a>内存泄漏的排查</h2><p>JS程序的内存溢出后，会使某一段函数体永远失效（取决于当时的JS代码运行到哪一个函数），通常表现为程序突然卡死或程序出现异常。<br>这时我们就要对该JS程序进行内存泄漏的排查，找出哪些对象所占用的内存没有释放。这些对象通常都是开发者以为释放掉了，但事实上仍被某个闭包引用着，或者放在某个数组里面。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OSI七层网络架构]]></title>
      <url>http://yoursite.com/2017/03/03/OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="OSI七层网络架构"><a href="#OSI七层网络架构" class="headerlink" title="OSI七层网络架构"></a>OSI七层网络架构</h2><p>七层模型（OSI，Open System Interconnection参考模型），是参考是国际标准化组织制定的一个用于计算机或通信系统间互联的标准体系。它是一个七层抽象的模型，不仅包括一系列抽象的术语和概念，也包括具体的协议。 经典的描述如下：<br>简述每一层的含义：<br><img src="http://obfnbicau.bkt.clouddn.com/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg" alt="Alt text"></p>
<ol>
<li>物理层（Physical Layer）：建立、维护、断开物理连接。</li>
<li>数据链路层 (Link)：逻辑连接、进行硬件地址寻址、差错校验等。</li>
<li>网络层 (Network)：进行逻辑寻址，实现不同网络之间的路径选择。</li>
<li>传输层 (Transport)：定义传输数据的协议端口号，及流控和差错校验。</li>
<li>会话层（Session Layer）：建立、管理、终止会话。</li>
<li>表示层（Presentation Layer）：数据的表示、安全、压缩。</li>
<li>应用层 (Application)：网络服务与最终用户的一个接口<br>每一层利用下一层提供的服务与对等层通信，每一层使用自己的协议。了解了这些，然并卵。但是，这一模型确实是绝大多数网络编程的基础，作为抽象类存在的，而TCP／IP协议栈只是这一模型的一个具体实现。<h2 id="TCP-IP五层网络架构"><a href="#TCP-IP五层网络架构" class="headerlink" title="TCP/IP五层网络架构"></a>TCP/IP五层网络架构</h2>TCP/IP是Internet的基础，是一组协议的代名词，包括许多协议，组成了TCP/IP协议栈。(<strong>里面包括IP协议、ICMP协议、TCP协议。</strong>)TCP／IP 有四层模型和五层模型之说，区别在于数据链路层是否作为独立的一层存在。<br><img src="http://obfnbicau.bkt.clouddn.com/TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88.jpg" alt="Alt text"><br>数据是如何传递呢？这就要了解网络层和传输层的协议，我们熟知的IP包结构是这样的：<br><img src="http://obfnbicau.bkt.clouddn.com/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt="Alt text"><br>IP协议和IP地址是两个不同的概念，这里没有涉及IPV6的。不关注网络安全的话，对这些结构不必耳熟能详的。传输层使用这样的数据包进行传输，传输层又分为面向连接的可靠传输TCP和数据报UDP。TCP的包结构：<br><img src="http://obfnbicau.bkt.clouddn.com/tcp%E6%95%B0%E6%8D%AE%E6%8A%A5.jpg" alt="Alt text"><br>TCP 连接建立的三次握手肯定是必知必会，在系统调优的时候，内核中关于网络的相关参数与这个图息息相关。UDP是一种无连接的传输层协议，提供的是简单不可靠的信息传输。协议结构相对简单，包括源和目标的端口号，长度以及校验和。基于TCP和UDP的数据封装及解析示例如下：<br><img src="http://obfnbicau.bkt.clouddn.com/TCP%E5%92%8CUDP%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85.jpg" alt="Alt text"></li>
</ol>
<h2 id="TCP协议连接、释放过程"><a href="#TCP协议连接、释放过程" class="headerlink" title="TCP协议连接、释放过程"></a>TCP协议连接、释放过程</h2><p>TCP/IP分层：<br><img src="http://obfnbicau.bkt.clouddn.com/tcp-ip%E5%88%86%E5%B1%82.jpg" alt="Alt text"></p>
<ol>
<li>有几个需要注意的知识点：</li>
</ol>
<ul>
<li>互联网地址：也就是IP地址，一般为网络号+子网号+主机号</li>
<li>域名系统：通俗的来说，就是一个数据库，可以将主机名转换成IP地址</li>
<li>RFC：TCP/IP协议的标准文档</li>
<li>端口号：一个逻辑号码，IP包所带有的标记</li>
<li>Socket：应用编程接口</li>
</ul>
<ol>
<li>数据链路层的工作特性：</li>
</ol>
<ul>
<li>为IP模块发送和接收IP数据报</li>
<li>为ARP模块发送ARP请求和接收ARP应答（ARP：地址解析协议，将IP地址转换成MAC地址）</li>
<li>为RARP发送RARP请求和接收RARP应答</li>
</ul>
<ol>
<li>首先我们先来了解TCP报文段<br><img src="http://obfnbicau.bkt.clouddn.com/tcp%E6%8A%A5%E6%96%87%E6%AE%B5.jpg" alt="Alt text"><br>重要的标志我在图中也有标记，重点了解标志位：</li>
</ol>
<ul>
<li>ACK：确认序号有效</li>
<li>RST：重置连接</li>
<li>SYN：发起了一个新连接</li>
<li>FIN：释放一个连接<br><code>三次握手的过程（客户端我们用A表示，服务器端用B表示）</code><br>前提：A主动打开，B被动打开<br><img src="http://obfnbicau.bkt.clouddn.com/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态</li>
<li>A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态</li>
<li>B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态</li>
<li><p>A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。<br><code>简单来说，</code> 就是:建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认,服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态,客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br><code>四次分手的过程（客户端我们用A表示，服务器端用B表示）</code><br>由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。<br>前提：A主动关闭，B被动关闭<br><img src="http://obfnbicau.bkt.clouddn.com/%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B.jpg" alt="Alt text"><br>有人可能会问，为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？<br>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
</li>
<li><p>A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。</p>
</li>
<li>B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。</li>
<li>B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。</li>
<li>A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序+1，B进入CLOSED状态，完成四次挥手。<br>简单来说就是<br>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。<br>A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？</li>
<li>为了保证A发送的最后一个ACK报文段能够到达B</li>
<li>防止“已失效的连接请求报文段”出现在本连接中<br>OK~是不是很难懂的感觉？那我们来说的“人性化点的”吧<br><code>三次握手流程</code></li>
<li>客户端发个请求“开门呐，我要进来”给服务器</li>
<li>服务器发个“进来吧，我去给你开门”给客户端</li>
<li>客户端有很客气的发个“谢谢，我要进来了”给服务器<br><code>四次挥手流程</code></li>
<li>客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他</li>
<li>服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走</li>
<li>服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）</li>
<li>客户端发个“我知道了，我走了”，之后自己就走了<h2 id="l"><a href="#l" class="headerlink" title="l"></a>l</h2><img src="http://obfnbicau.bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg" alt="Alt text"></li>
<li>CLOSED: 表示初始状态。</li>
<li>LISTEN: 表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li>
<li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li>
<li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>
<li>ESTABLISHED:表示连接已经建立了。</li>
<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li>
<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li>
<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>
<li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>
<li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li>
</ol>
<p>参考链接：<a href="http://blog.jobbole.com/91841/utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="external">http://blog.jobbole.com/91841/utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></p>
<p><a href="http://blog.jobbole.com/110041/" target="_blank" rel="external">http://blog.jobbole.com/110041/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[响应式web设计]]></title>
      <url>http://yoursite.com/2017/03/03/%E5%93%8D%E5%BA%94%E5%BC%8Fweb%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h3 id="什么是响应式web设计"><a href="#什么是响应式web设计" class="headerlink" title="什么是响应式web设计"></a>什么是响应式web设计</h3><p>响应式网页设计（RWD，Responsive Web Design）这个术语，由伊桑·马科特（Ethan<br>Marcotte）提出。将三种已有的开发技巧（弹性网格布局、弹性图片、媒体和媒体查询）整合起来，并命名为响应式网页设计。这个术语还有一堆表示相同意思的其他叫法，如流式设计、弹性布局、塑料布局、流体设计、自适应布局、跨设备设计以及弹性设计<br><img src="http://obfnbicau.bkt.clouddn.com/web%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5.jpg" alt="Alt text"></p>
<h3 id="向下兼容，移动优先"><a href="#向下兼容，移动优先" class="headerlink" title="向下兼容，移动优先"></a>向下兼容，移动优先</h3><p>响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式；我们应当向下兼容、移动优先。<br>首先我们应该遵循移动优先原则，交互&amp;设计应以移动端为主，PC则作为移动端的一个扩展；一个页面需要兼容不同终端，那么有两个关键点是我们需要去做到响应式的：</p>
<ol>
<li>响应式布局</li>
<li>响应式内容（图片、多媒体）</li>
</ol>
<h2 id="桌面浏览器部分"><a href="#桌面浏览器部分" class="headerlink" title="桌面浏览器部分"></a>桌面浏览器部分</h2><ol>
<li>设备像素和CSS像素<br>设备像素其值可以（通常情况下）从screen.width/height属性中读出</li>
</ol>
<ul>
<li>如果你给一个元素设置了width: 128px的属性，并且你的显示器是1024px宽，当你最大化你的浏览器屏幕，这个元素将会在你的显示器上重复显示8次,形式上，元素仍然是128个CSS像素宽，即使它占据了256个设备像素的空间</li>
<li>100%缩放 : 在缩放比例100%的情况下一个CSS像素完全等于一个设备像素。</li>
</ul>
<ol>
<li>屏幕尺寸(screen.width/height)</li>
</ol>
<ul>
<li>意义：用户屏幕的整体大小。</li>
<li>度量单位：设备像素。</li>
<li>浏览器错误：IE8以CSS像素对其进行度量，IE7和IE8模式下都有这个问题。<br><img src="http://obfnbicau.bkt.clouddn.com/screen.width.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>窗口尺寸(window.innerWidth/Height)</li>
</ol>
<ul>
<li>意义：浏览器窗口的整体大小，包括滚动条。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：IE7不支持。Opera以设备像素进行度量<br><img src="http://obfnbicau.bkt.clouddn.com/window.innerWidth.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>滚动距离(window.pageX/YOffset)</li>
</ol>
<ul>
<li>意义：页面滚动的距离。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：无。<br><img src="http://obfnbicau.bkt.clouddn.com/window.pageYOffset.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>度量viewport<br>(document.documentElement.clientWidth/Height)</li>
</ol>
<ul>
<li>意义：Viewport尺寸。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：无。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/viewport.jpg" alt="Alt text"><br>如果你了解DOM，你应该知道document.documentElement实际上指的是<html>元素：即任何HTML文档的根元素。可以说，viewport要比它更高一层；它是包含<html>元素的元素。<br><img src="http://obfnbicau.bkt.clouddn.com/document.documentElement.clientWidth.jpg" alt="Alt text"></html></html></p>
<ol>
<li>度量<html>元素(document.documentElement.offsetWidth/Height)</html></li>
</ol>
<ul>
<li>意义：元素（也就是页面）的尺寸。</li>
<li>度量单位：CSS像素。</li>
<li>浏览器错误：IE度量的是viewport，而不是元素。<br><img src="./document.documentElement.clientWidth.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>事件中的坐标<br>(pageX/Y, clientX/Y, screenX/Y)<br>浏览器错误：IE不支持pageX/Y。IE和Opera以CSS像素为单位计算screenX/Y。</li>
</ol>
<ul>
<li>pageX/Y提供了相对于<html>元素的以CSS像素度量的坐标。<br><img src="http://obfnbicau.bkt.clouddn.com/pageXY.jpg" alt="Alt text"></html></li>
<li>clientX/Y提供了相对于viewport的以CSS像素度量的坐标<br><img src="http://obfnbicau.bkt.clouddn.com/clientXY.jpg" alt="Alt text"></li>
<li>screenX/Y提供了相对于屏幕的以设备像素进行度量的坐标。<br><img src="http://obfnbicau.bkt.clouddn.com/screen.width.jpg" alt="Alt text"></li>
</ul>
<ol>
<li>媒体查询<br>(浏览器错误：IE不支持它们。)</li>
</ol>
<ul>
<li>如果 device-width/height是以CSS像素进行度量的，那么Firefox将会使用screen.width/height的值。</li>
<li>如果width/height是以设备像素进行度量的，那么Safari和Chrome将会使</li>
<li>8.1 documentElement.clientWidth/Height的值。width/height使用和documentElement .clientWidth/Height（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。</li>
<li>8.2 device-width/device-height使用和screen.width/height（换句话说就是屏幕的宽高）一样的值。它工作在设备像素下面。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/media%20query%20width.jpg" alt="Alt text"></p>
<h2 id="移动浏览器部分"><a href="#移动浏览器部分" class="headerlink" title="移动浏览器部分"></a>移动浏览器部分</h2><p>##两个viewport</p>
<h3 id="layout-viewport"><a href="#layout-viewport" class="headerlink" title="layout viewport"></a>layout viewport</h3><p><img src="http://obfnbicau.bkt.clouddn.com/layoutviewport.jpg" alt="Alt text"></p>
<ol>
<li>度量layout viewport<br>我们现在有两个需要度量的viewport。很幸运的是浏览器战争给我们提供了两个属性对。<br>document.documentElement.clientWidth和-Height包含了layout viewport的尺寸。</li>
</ol>
<p>document.documentElement.clientWidth/Height</p>
<ul>
<li>意义：Layout viewport的尺寸</li>
<li>度量单位：CSS像素</li>
<li>完全支持Opera, iPhone, Android, Symbian, Bolt, MicroB, Skyfire, Obigo。</li>
<li>在Iris中Visual viewport有问题</li>
<li>浏览器兼容性问题</li>
</ul>
<p>###visual viewport<br>visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。<br><img src="http://obfnbicau.bkt.clouddn.com/viewport.jpg" alt="Alt text"><br><code>注：</code> 无论怎样，CSS布局，尤其是百分比宽度，是以layout viewport做为参照系来计算的，它被认为要比visual viewport宽。</p>
<ol>
<li>度量visual viewport<br>对于visual viewport，它是通过window.innerWidth/Height来进行度量的。很明显当用户缩小或者放大的时候，度量的尺寸会发生变化，因为屏幕上的CSS像素会增加或者减少。</li>
</ol>
<h3 id="viewport-meta标签（Meta-viewport）"><a href="#viewport-meta标签（Meta-viewport）" class="headerlink" title="viewport meta标签（Meta viewport）"></a>viewport meta标签（Meta viewport）</h3><p><img src="http://obfnbicau.bkt.clouddn.com/Meta%20viewport.jpg" alt="Alt text"></p>
<ul>
<li>意义：设置layout viewport的宽度。</li>
<li>度量单位：CSS像素。</li>
<li>完全支持Opera Mobile，iPhone，Android，Iris，IE，BlackBerry，Obigo。<br>不支持Opera Mini，Symbian，Bolt，Firefox，MicroB，NetFront。</li>
<li>问题：Skyfire不能处理我的测试页面。<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3>弹性的栅格布局，不同尺寸下弹性适应，如以下页面中各模块在不同尺寸下的位置：<br><img src="http://obfnbicau.bkt.clouddn.com/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80.jpg" alt="Alt text"></li>
</ul>
<p>栅格框架推荐:</p>
<ul>
<li>Responsive Grid System</li>
<li>Fluid 960 Grid</li>
<li>Simple Grid<h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3></li>
</ul>
<ol>
<li>什么是响应式图片？<br>根据显示器分辨率，提供多个图片源，在页面上图片的尺寸，或者其它参数的一种方法<br>目前最常用的解决方案：</li>
<li><p>css样式<br>此代码使用 max-width:100% 的设置，以确保图像永远不会超越其父容器的宽度。如果父容器的宽度收缩小于图像的宽度，图像将随之缩小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> img &#123;</div><div class="line">    max-width: 100%;</div><div class="line">    height: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>picture是HTML5一个新的元素</p>
</li>
</ol>
<ul>
<li>创建 picture 标签。</li>
<li>在这些标签内创建一个你想用来执行任何一个特性的 source元素。</li>
<li>添加一个 media 属性，用来包含你想要的特性，如视口的当前高度(viewport height)，宽度( width )，方向(orientation)等。</li>
<li>添加一个 srcset 属性与相应的图像文件名相匹配，进行加载。如果你想提供不同的像素密度，例如Retina显示屏，你可以添加额外的文件名到你的 srcset 属性中，</li>
<li>添加一个回退的 img 元素。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/picture.jpg" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">		(function() &#123;</div><div class="line">  var currentSrc, oldSrc, imgEl;</div><div class="line">  var showPicSrc = function() &#123;</div><div class="line">    oldSrc     = currentSrc;</div><div class="line">    imgEl      = document.getElementById(&apos;picimg&apos;);</div><div class="line">    currentSrc = imgEl.currentSrc || imgEl.src;</div><div class="line">    </div><div class="line">    if (typeof oldSrc === &apos;undefined&apos; || oldSrc !== currentSrc) &#123;</div><div class="line">      document.getElementById(&apos;logger&apos;).innerHTML = currentSrc;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  // You may wish to debounce resize if you have performance concerns</div><div class="line">  window.addEventListener(&apos;resize&apos;, showPicSrc);</div><div class="line">  window.addEventListener(&apos;load&apos;, showPicSrc);</div><div class="line">&#125;)(window);</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">	&lt;picture&gt;</div><div class="line">  &lt;source media=&quot;(min-width: 650px)&quot; srcset=&quot;images/kitten-large.jpg&quot;&gt;</div><div class="line">  &lt;source media=&quot;(min-width: 465px)&quot; srcset=&quot;images/kitten-medium.jpg&quot;&gt;</div><div class="line">  &lt;!-- img tag for browsers that do not support picture element --&gt;</div><div class="line">  &lt;img src=&quot;images/kitten-small.jpg&quot; id=&quot;picimg&quot;&gt;</div><div class="line"> &lt;/picture&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<ol>
<li>Picturefill<br>其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，例如图片加载失败的替代方案。<br><a href="http://scottjehl.github.io/picturefill/" target="_blank" rel="external">http://scottjehl.github.io/picturefill/</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;picture&gt;</div><div class="line">  &lt;!--[if IE 9]&gt;&lt;video style=&quot;display: none;&quot;&gt;&lt;![endif]--&gt;</div><div class="line">  &lt;source srcset=&quot;images/3.jpg&quot; media=&quot;(min-width: 1000px)&quot;&gt;</div><div class="line">  &lt;source srcset=&quot;images/4.jpg&quot; media=&quot;(min-width: 800px)&quot;&gt;</div><div class="line">  &lt;!--[if IE 9]&gt;&lt;/video&gt;&lt;![endif]--&gt;</div><div class="line">  &lt;img srcset=&quot;images/6.jpg&quot; alt=&quot;…&quot;&gt;</div><div class="line">&lt;/picture&gt;</div><div class="line">显示密度描述:</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot; srcset=&quot;cat.jpg, cat-2X.jpg 2x&quot;&gt;</div><div class="line">宽度描述符:</div><div class="line">当图片开始下载时浏览器知道的只有视窗尺寸</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot;  srcset=&quot;cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w&quot;&gt;</div><div class="line">浏览器如何选择正确的sizes:</div><div class="line">&lt;img src=&quot;cat.jpg&quot; alt=&quot;cat&quot;</div><div class="line">  srcset=&quot;cat-160.jpg 160w, cat-320.jpg 320w, cat-640.jpg 640w, cat-1280.jpg 1280w&quot;</div><div class="line">  sizes=&quot;(max-width: 480px) 100vw, (max-width: 900px) 33vw, 254px&quot;&gt;</div><div class="line">Srcset和sizes ＝ 智能浏览器</div></pre></td></tr></table></figure>
<ol>
<li>在一些场景下单独用img可能就够了：</li>
</ol>
<ul>
<li>固定宽度，单一分辨率网页:如果你没有用响应式设计并且不用担心”retina”屏幕，img元素就够了</li>
<li>文件尺寸差别很小:对于有些图片，最大版本和最小版本的尺寸没有很大区别。常见的有logo，图标和其他不需要根据视窗变化的小图片。如果文件尺寸没什么区别，一张图片可能就够了</li>
<li>使用基于矢量的图片例如SVG:如果使用基于矢量的图片格式例如SVG，图片可以自由缩放并不需要多张图片。在这种情况下，可以直接用SVG做为img的图片源。<h3 id="逐渐增强与优雅降级"><a href="#逐渐增强与优雅降级" class="headerlink" title="逐渐增强与优雅降级"></a>逐渐增强与优雅降级</h3></li>
<li>优雅降级：指的是为现代浏览器制作网站，然后保证为某些老版本浏览器提供基本可用的体验。新特性在老版本浏览器中会降级，且一般会有一个分界点，声明不支持那些老掉牙的浏览器。有些时候用户也仅会被警告他们所使用的浏览器有问题，建议其更换</li>
<li>逐渐增强：渐进增强以恪守 Web标准的标签为基础，意味着它在所有浏览器中均可用。然后通过 CSS 样式和必要的 JavaScript 来为更先进的浏览器提供渐进式的增强体验。<h3 id="JavaScript中的shim与polyfill是？"><a href="#JavaScript中的shim与polyfill是？" class="headerlink" title="JavaScript中的shim与polyfill是？"></a>JavaScript中的shim与polyfill是？</h3></li>
<li>shim是指一个库，它将一个新的API引入到一个旧的环境当中，而且仅靠旧的环境中已有的手段实现</li>
<li>一个polyfill就是一个用浏览器API上的shim</li>
<li>我们通常的做法：先检查当前浏览器是否支持某个API，如果<br>不支持的话，就加载对应的polyfill，然后新旧的浏览器就可以使用这个API了</li>
<li>区别：polyfill是shim的一种，<br>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；polyfill 特指 shim 成的 api是遵循标准的，其典型做法是在IE浏览器中增加window.XMLHttpRequest，内部实现使用ActiveXObject。在实际中为了方便做对比，会特指shim的api不是遵循标准的，而是自己设计的。</li>
<li>使用Modernizr检查HTML5和css3浏览器支持功能。<br>Modernizr是一个用于检测浏览器功能的开源JavaScript库。<br><code>注意：</code>Modernizr并不是试图添加老版本浏览器不支持的功能，而是令你通过创建可选风格配置来修改页面设计。它可以通过加载定制的脚本来模拟老版本浏览器不支持的功能。’</li>
</ul>
<p>参考链接：<br>                    <a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="external">http://www.quirksmode.org/mobile/viewports2.html</a><br>                    <a href="http://isux.tencent.com/responsive-web-design.html" target="_blank" rel="external">http://isux.tencent.com/responsive-web-design.html</a><br>                    <a href="http://www.berkeley.edu/" target="_blank" rel="external">http://www.berkeley.edu/</a><br>参考书籍：《响应式web设计》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的源码解读(一)]]></title>
      <url>http://yoursite.com/2016/09/30/jQuery%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="jQuery的整体架构"><a href="#jQuery的整体架构" class="headerlink" title="jQuery的整体架构"></a>jQuery的整体架构</h2><p>对架构有个清晰的认识，才不会一头雾水，漫无目的解读源代码。<br><img src="http://obfnbicau.bkt.clouddn.com/blog/20170406/141929687.png" alt="mark"></p>
<h2 id="jQuery的无new构建"><a href="#jQuery的无new构建" class="headerlink" title="jQuery的无new构建"></a>jQuery的无new构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$().find().css()</div><div class="line">$().hide().html(&apos;....&apos;).hide()</div></pre></td></tr></table></figure>
<p>这里涉及到两个问题（无new构建和链式调用）</p>
<ol>
<li>$(“XXX”)到底是怎样实现的，内部发生了什么使我们能够如此轻易获取到对象。<br>*　$是什么鬼？<br>window 是对象，它有两个属性，分别为 jQuery 和 $，其值是一函数，此函数的名字是 jQuery。在函数<br>的定义实体中，其实是通过 jQuery.fn.init 函数来构造对象的，init 函数才是真正的构造函数。也就是说，  我们通过 ${ … ) 得到的其实就是 jQuery.fn.init 的实例。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var jQuery = window.jQuery = window.$ = function( selector, context ) &#123;  </div><div class="line">    // The jQuery object is actually just the init constructor &apos;enhanced&apos;  </div><div class="line">    return new jQuery.fn.init( selector, context );  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>＊jQuery.fn？fn解释下，其实这个fn没有什么特殊意思，只是jQuery.prototype的引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">理解这几句很重要jQuery.fn.init.prototype = jQuery.fn;</div></pre></td></tr></table></figure></p>
<ul>
<li>首先要明确，使用 $(‘xxx’) 这种实例化方式，其内部调用的是 return new jQuery.fn.init(selector, context, rootjQuery) 这一句话，也就是构造实例是交给了 jQuery.fn.init() 方法去完成。</li>
<li>将 jQuery.fn.init 的 prototype 属性设置为 jQuery.fn，那么使用 new jQuery.fn.init() 生成的对象的原型对象就是 jQuery.fn ，所以挂载到 jQuery.fn 上面的函数就相当于挂载到 jQuery.fn.init() 生成的 jQuery 对象上，所有使用 new jQuery.fn.init() 生成的对象也能够访问到 jQuery.fn 上的所有原型方法。</li>
<li>也就是实例化方法存在这么一个关系链<br>jQuery.fn.init.prototype = jQuery.fn = jQuery.prototype ;<br>new jQuery.fn.init() 相当于 new jQuery() ;<br>jQuery() 返回的是 new jQuery.fn.init()，而 var obj = new jQuery()，所以这 2 者是相当的，所以我们可以无 new 实例化 jQuery 对象。</li>
</ul>
<p><img src="http://obfnbicau.bkt.clouddn.com/blog/20170406/144808352.jpg" alt="mark"></p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>为什么DOM链式调用的处理：</p>
<ul>
<li>节约JS代码.</li>
<li>所返回的都是同一个对象，可以提高代码的效率</li>
<li>实现链式的基本条件：就是实例this的存在，并且是同一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">aQuery.prototype = &#123;</div><div class="line">    init: function() &#123;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    name: function() &#123;</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">--------------</div><div class="line">aQuery().init().name()</div><div class="line"></div><div class="line">分解</div><div class="line">a = aQuery();</div><div class="line">a.init()</div><div class="line">a.name()</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="插件接口"><a href="#插件接口" class="headerlink" title="插件接口"></a>插件接口</h2><ol>
<li>jQuery的主体框架就是这样，但是根据一般设计者的习惯，如果要为jQuery或jQuery prototype添加属性方法，同样如要提供给开发者对方法的扩展，从封装的角度讲是不是应该提供一个接口才对，字面就能看懂是对函数扩展，而不是看上去直接修改prototype.友好的用户接口，<br>jQuery支持自己扩展属性，这个对外提供了一个接口，jQuery.fn.extend()来对对象增加方法<br>从jQuery的源码中可以看到，jQuery.extend和jQuery.fn.extend其实是同指向同一方法的不同引用</li>
<li>jQuery.extend和jQuery.fn.extend区别：</li>
</ol>
<ul>
<li>jQuery.extend(object) 为扩展 jQuery 类本身，为类添加新的静态方法；</li>
<li>jQuery.fn.extend(object) 给 jQuery 对象添加实例方法，也就是通过这个 extend 添加的新方法，实例化的 jQuery 对象都能使用，因为它是挂载在 jQuery.fn 上的方法（上文有提到，jQuery.fn = jQuery.prototype ）。<br>它们的官方解释是：<br>1）jQuery.extend(): 把两个或者更多的对象合并到第一个当中，<br>2）jQuery.fn.extend()：把对象挂载到 jQuery 的 prototype 属性，来扩展一个新的 jQuery 实例方法。</li>
<li>也就是说，使用 jQuery.extend() 拓展的静态方法，我们可以直接使用 $.xxx 进行调用（xxx是拓展的方法名），</li>
<li>而使用 jQuery.fn.extend() 拓展的实例方法，需要使用 $().xxx 调用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery.extend = jQuery.fn.extend = function() &#123;&#125;</div><div class="line">jQuery.extend 对jQuery本身的属性和方法进行了扩展</div><div class="line">jQuery.fn.extend 对jQuery.fn的属性和方法进行了扩展</div></pre></td></tr></table></figure>
<p>通过extend()函数可以方便快速的扩展功能，不会破坏jQuery的原型结构<br>jQuery.extend = jQuery.fn.extend = function(){…}; 这个是连等，也就是2个指向同一个函数，怎么会实现不同的功能呢？这就是this 力量了！<br>针对fn与jQuery其实是2个不同的对象，在之前有讲述：</p>
<ul>
<li>jQuery.extend 调用的时候，this是指向jQuery对象的(jQuery是函数，也是对象！)，所以这里扩展在jQuery上。</li>
<li>而jQuery.fn.extend 调用的时候，this指向fn对象，jQuery.fn 和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象。</li>
<li>这里增加的是原型方法，也就是对象方法了。所以jQuery的api中提供了以上2中扩展函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">// 扩展合并函数</div><div class="line">// 合并两个或更多对象的属性到第一个对象中，jQuery 后续的大部分功能都通过该函数扩展</div><div class="line">// 虽然实现方式一样，但是要注意区分用法的不一样，那么为什么两个方法指向同一个函数实现，但是却实现不同的功能呢,</div><div class="line">// 阅读源码就能发现这归功于 this 的强大力量</div><div class="line">// 如果传入两个或多个对象，所有对象的属性会被添加到第一个对象 target</div><div class="line">// 如果只传入一个对象，则将对象的属性添加到 jQuery 对象中，也就是添加静态方法</div><div class="line">// 用这种方式，我们可以为 jQuery 命名空间增加新的方法，可以用于编写 jQuery 插件</div><div class="line">// 如果不想改变传入的对象，可以传入一个空对象：$.extend(&#123;&#125;, object1, object2);</div><div class="line">// 默认合并操作是不迭代的，即便 target 的某个属性是对象或属性，也会被完全覆盖而不是合并</div><div class="line">// 如果第一个参数是 true，则是深拷贝</div><div class="line">// 从 object 原型继承的属性会被拷贝，值为 undefined 的属性不会被拷贝</div><div class="line">// 因为性能原因，JavaScript 自带类型的属性不会合并</div><div class="line">jQuery.extend = jQuery.fn.extend = function() &#123;</div><div class="line">    var src, copyIsArray, copy, name, options, clone,</div><div class="line">        target = arguments[0] || &#123;&#125;,</div><div class="line">        i = 1,</div><div class="line">        length = arguments.length,</div><div class="line">        deep = false;</div><div class="line"> </div><div class="line">    // Handle a deep copy situation</div><div class="line">    // target 是传入的第一个参数</div><div class="line">    // 如果第一个参数是布尔类型，则表示是否要深递归，</div><div class="line">    if (typeof target === &quot;boolean&quot;) &#123;</div><div class="line">        deep = target;</div><div class="line">        target = arguments[1] || &#123;&#125;;</div><div class="line">        // skip the boolean and the target</div><div class="line">        // 如果传了类型为 boolean 的第一个参数，i 则从 2 开始</div><div class="line">        i = 2;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // Handle case when target is a string or something (possible in deep copy)</div><div class="line">    // 如果传入的第一个参数是 字符串或者其他</div><div class="line">    if (typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target)) &#123;</div><div class="line">        target = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // extend jQuery itself if only one argument is passed</div><div class="line">    // 如果参数的长度为 1 ，表示是 jQuery 静态方法</div><div class="line">    if (length === i) &#123;</div><div class="line">        target = this;</div><div class="line">        --i;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // 可以传入多个复制源</div><div class="line">    // i 是从 1或2 开始的</div><div class="line">    for (; i &lt; length; i++) &#123;</div><div class="line">        // Only deal with non-null/undefined values</div><div class="line">        // 将每个源的属性全部复制到 target 上</div><div class="line">        if ((options = arguments[i]) != null) &#123;</div><div class="line">            // Extend the base object</div><div class="line">            for (name in options) &#123;</div><div class="line">                // src 是源（即本身）的值</div><div class="line">                // copy 是即将要复制过去的值</div><div class="line">                src = target[name];</div><div class="line">                copy = options[name];</div><div class="line"> </div><div class="line">                // Prevent never-ending loop</div><div class="line">                // 防止有环，例如 extend(true, target, &#123;&apos;target&apos;:target&#125;);</div><div class="line">                if (target === copy) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                // Recurse if we&apos;re merging plain objects or arrays</div><div class="line">                // 这里是递归调用，最终都会到下面的 else if 分支</div><div class="line">                // jQuery.isPlainObject 用于测试是否为纯粹的对象</div><div class="line">                // 纯粹的对象指的是 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的</div><div class="line">                // 如果是深复制</div><div class="line">                if (deep &amp;&amp; copy &amp;&amp; (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) &#123;</div><div class="line">                    // 数组</div><div class="line">                    if (copyIsArray) &#123;</div><div class="line">                        copyIsArray = false;</div><div class="line">                        clone = src &amp;&amp; jQuery.isArray(src) ? src : [];</div><div class="line"> </div><div class="line">                        // 对象</div><div class="line">                    &#125; else &#123;</div><div class="line">                        clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;;</div><div class="line">                    &#125;</div><div class="line"> </div><div class="line">                    // Never move original objects, clone them</div><div class="line">                    // 递归</div><div class="line">                    target[name] = jQuery.extend(deep, clone, copy);</div><div class="line"> </div><div class="line">                    // Don&apos;t bring in undefined values</div><div class="line">                    // 最终都会到这条分支</div><div class="line">                    // 简单的值覆盖</div><div class="line">                &#125; else if (copy !== undefined) &#123;</div><div class="line">                    target[name] = copy;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    // Return the modified object</div><div class="line">    // 返回新的 target</div><div class="line">    // 如果 i &lt; length ，是直接返回没经过处理的 target，也就是 arguments[0]</div><div class="line">    // 也就是如果不传需要覆盖的源，调用 $.extend 其实是增加 jQuery 的静态方法</div><div class="line">    return target;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是这一句 jQuery.extend = jQuery.fn.extend = function() {} ，也就是 jQuery.extend 的实现和 jQuery.fn.extend 的实现共用了同一个方法，但是为什么能够实现不同的功能了，这就要归功于 Javascript 强大（怪异？）的 this 了。<br>1）在 jQuery.extend() 中，this 的指向是 jQuery 对象(或者说是 jQuery 类)，所以这里扩展在 jQuery 上；<br>2）在 jQuery.fn.extend() 中，this 的指向是 fn 对象，前面有提到 jQuery.fn = jQuery.prototype ，也就是这里增加的是原型方法，也就是对象方法。</p>
<p>参考链接：<a href="http://www.cnblogs.com/aaronjs/p/3278578.html" target="_blank" rel="external">http://www.cnblogs.com/aaronjs/p/3278578.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSON]]></title>
      <url>http://yoursite.com/2016/09/23/JSON%EF%BC%88JavaScript%20Object%20Notation%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="JSON（JavaScript-Object-Notation）"><a href="#JSON（JavaScript-Object-Notation）" class="headerlink" title="JSON（JavaScript Object Notation）"></a>JSON（JavaScript Object Notation）</h1><p>JSON是JavaScript的一个严格子集，利用一些JavaScript中的一些模式来表示结构化数据，<br><code>注意：</code></p>
<ol>
<li>它是一种数据格式，不是一种编程语言</li>
<li>它并不属于JavaScript，很多编程语言都有应用到它，有针对Json的解析器和序列化器<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2></li>
<li>简单值：使用与js相同的语法，在json中表示，字符串，数值，布尔值，null，但不支持undefined</li>
<li>对象：复杂数据类型，表示的是一组无序的键值对，键值对中可以使简单值，也可以是复杂数据类型</li>
<li><p>数组：复杂数据类型，表示一组有序值的列表，可以通过数组索引来访问其中的值，数组值，可以是简单值，对象，数组<br><code>注意：</code>json不支持变量，函数，对象实例，它就是一种表示结构化数据的格式</p>
<h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p><code>注意：</code>js字符串与json的最大区别：json字符串必须使用双引号（单引号将导致语法错误）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p> js中对象字面量：<br> var person={</p>
<pre><code>name:&quot;Lili&quot;,
age:29
</code></pre><p> }；<br> 或者<br> var Object={</p>
<pre><code>name:&quot;Lili&quot;,
age:29
</code></pre><p> };<br> json中对象表示：<br> {</p>
<pre><code> &quot;name&quot;:&quot;Lili&quot;,
&quot;age&quot;:29
</code></pre><p> }<br><code>两者的区别：</code></p>
<ol>
<li>json对象中没有声明变量的概念</li>
<li>json对象中没有末尾的分号</li>
<li>对象属性必须加上双引号</li>
<li><p>同一个对象中绝对不应该出现两个同名属性</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>js中数组：<br>var values=[25,”h1”,true];<br>json中的数组：<br>[25,”h1”,true]</p>
</li>
</ol>
</li>
</ol>
<p><code>两者的而区别：</code>json数组没有变量和分号</p>
<h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><ol>
<li>eval()函数可以解析，解释并返回js对象和数组</li>
<li>json对象有两个方法：stringify()和parse()<br>stringify()用于把json对象序列化为json字符串<br>parse()用于把字符串解析为原生的js值<br><code>注意：</code></li>
<li>默认情况下，JSON.stringify()输出的字符串不包括任何空格字符或缩进</li>
<li>如过传给JSON.parse()不是有效的json，该方法会报错<h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3>JSON.stringify(序列化对象，过滤器，选项)<br>过滤器：可以使数组，可以是函数<br>选项：表示是否在json中保留缩进</li>
<li><p>过滤结果<br> 过滤器为数组：</p>
<p> var book={</p>
<pre><code>&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 };
var jsonText=JSON.stringify(book,[&quot;title&quot;,&quot;edition&quot;]);
</code></pre><p>过滤器为函数：</p>
</li>
</ol>
<pre><code>var book={
    &quot;title&quot;:&quot;javaScript&quot;;
    &quot;authors&quot;:
    [
    &quot;Hellen&quot;
    ],
    edition:3,
    year:2011 };
    var jsonText=JSON.stringify(book,function(key,value){
    switch(key){
    case &quot;authors&quot;:
    return value.join(&quot;,&quot;);
    case &quot;year&quot;:
    return 5000;
    case &quot;edition&quot;:
    return undefined;
    default:
    return value;
    }
    });
</code></pre><ol>
<li>字符串缩进<br>JSON.stringify()方法的而第三个参数用于结果中的缩进和空白符，如果这个参数是一个数值，那它表示每个级别缩进的空格数<br>var jsonText=JSON.stringify(book,null,4);<br><code>注意：</code> </li>
</ol>
<ul>
<li>只要传入有效的缩进参数，结果字符串就会包含换行符，</li>
<li>最大缩进的而空格数为10，所有大于10的数值都会自动转换为10<br>缩进参数</li>
<li>缩进参数可以为非数值（制表符，两个短横线等任意字符）</li>
</ul>
<ol>
<li>toJSON()方法<br>可以给任何对象添加 toJSON()方法,返回自身的JSON数据格式</li>
</ol>
<pre><code> var book={
&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 
toJSON:function(){
return this.title;
}
};
var jsonText=JSON.stringify(book);
</code></pre><ol>
<li><p>序列化的内部顺序：<br>假设把一个对象传入JSON.stringify()，序列化该对象的顺序如下：<br>（1）如果存在toJSON()而且能通过它取得有效值，则调用该方法，否则返回对象本身<br>（2）如果提供第二个参数，应用这个函数过滤器。传入函数过滤器的值是第（1）步返回的值<br>（3）对第（2）步返回的每一个值进行相应的序列化<br>（4）如果提供第三个参数，执行相应的格式化</p>
<h2 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h2><p>JSON.stringify()方法接收的函数（称替换或过滤函数）<br>JSON.parse()方法可以接收另一个参数（称还原函数）</p>
<p> var book={</p>
<pre><code>&quot;title&quot;:&quot;javaScript&quot;;
&quot;authors&quot;:
[
&quot;Hellen&quot;
],
edition:3,
year:2011 
releaseDate:new Date(2011,11,1)
};
var jsonText=JSON.stringify(book);
var bookCopy=JSON.parse(jsonText,function(key,value){
if(key==&quot;releaseDate&quot;){
return new Date(value);
}else{
return vlaue;
}
});
console.log(bookCopy.releaseDate.getFullYear());
</code></pre></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[this的指向问题]]></title>
      <url>http://yoursite.com/2016/09/22/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h1><ol>
<li>若果一个函数中有this，但是它没有被上级对象所调用，那么this的指向是window<br>(在js不是严格型的情况下)</li>
<li>若一个函数中有this，这个函数有被上一 级对象所调用，那么this的指向就是上一级<br>对象</li>
<li>若一个函数中有this，这个函数中包含多个对象，尽管这个函数是被外层的对象所调用，this的指向也只是它上一级的对象。<blockquote>
<p>知识点补充：</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>在严格版中的默认的this不再是window，而是undefined。</p>
</li>
<li><p>new操作符会改变函数this的指向问题，虽然我们上面讲解过了，但是并没有深入的讨论这个问题，网上也很少说，所以在这里有必要说一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">//this最终指向的是调用它的对象</div><div class="line">function a()&#123;</div><div class="line">	var user=&quot;陈&quot;;</div><div class="line">	console.log(this.user);//undefinded</div><div class="line">	console.log(this);//window</div><div class="line">&#125;</div><div class="line">a();//window对象在调用他</div><div class="line"></div><div class="line">//证明上述观点</div><div class="line">function a()&#123;</div><div class="line">	var user=&quot;陈&quot;;</div><div class="line">	console.log(this.user);//undefined</div><div class="line">	console.log(this);//window</div><div class="line">&#125;</div><div class="line">window.a();</div><div class="line"></div><div class="line">//this的指向在函数创建的时候是决定不了的，在调用的时候才能决定</div><div class="line">var o=&#123;</div><div class="line">	user:&quot;陈&quot;,</div><div class="line">	fn:function()&#123;</div><div class="line">		console.log(this.user);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">o.fn();//陈</div><div class="line"></div><div class="line">//与上面例子作比较</div><div class="line">var o=&#123;</div><div class="line">	user:&quot;陈&quot;,</div><div class="line">	fn:function()&#123;</div><div class="line">		console.log(this.user);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">window.o.fn();//陈</div><div class="line">//this对象的指向问题</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//12</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">o.b.fn();</div><div class="line">//直接调用它的内层对象</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		//a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">o.b.fn();//undefined</div><div class="line">//特殊情况</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//undefined</div><div class="line">			console.log(this);//window</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var j=o.b.fn;</div><div class="line">j();//注意this的指向是最后调用它的 对象，也就是看它执行的时候是谁调用的</div><div class="line">//证明上述观点</div><div class="line">var o=&#123;</div><div class="line">	a:10,</div><div class="line">	b:&#123;</div><div class="line">		a:12,</div><div class="line">		fn:function()&#123;</div><div class="line">			console.log(this.a);//undefined</div><div class="line">			console.log(this);//window</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var j=o.b.fn;</div><div class="line">window.j();</div><div class="line"></div><div class="line">//构造函数版的this</div><div class="line">function Fn()&#123;</div><div class="line">	this.user=&quot;陈&quot;;</div><div class="line">&#125;</div><div class="line">var a=new Fn();</div><div class="line">//a是new出来的一个对象实例</div><div class="line">console.log(a.user);//陈</div><div class="line"></div><div class="line">//当this碰到return的时候</div><div class="line">function fn()&#123;</div><div class="line">	this.user=&quot;陈&quot;;</div><div class="line">	return &#123;&#125;;</div><div class="line">&#125;</div><div class="line">var a=new fn;</div><div class="line">console.log(a.user);//undefined</div><div class="line">//再看一个</div><div class="line">function fn()&#123;</div><div class="line">	this.user=&apos;陈&apos;;</div><div class="line">	return function()&#123;&#125;;</div><div class="line">&#125;</div><div class="line">var a=new fn;</div><div class="line">console.log(a.user);//undefined</div><div class="line">//返回数字</div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return 1;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div><div class="line">//返回undefined</div><div class="line"></div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return undefined;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div><div class="line">// 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</div><div class="line">//还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，</div><div class="line">//因为null比较特殊</div><div class="line">function fn()  </div><div class="line">&#123;  </div><div class="line">    this.user = &apos;追&apos;;  </div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line">var a = new fn;  </div><div class="line">console.log(a.user); //追</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jQuery]]></title>
      <url>http://yoursite.com/2016/09/20/jQuery/</url>
      <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.1.0.js&quot;&gt;&lt;/script&gt;</div><div class="line">	&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			alert(&quot;hello world!&quot;);</div><div class="line">		&#125;);</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			alert(&quot;哇!&quot;);</div><div class="line">		&#125;);</div><div class="line">		$(function()&#123;</div><div class="line">			alert(&quot;哇哦!&quot;);</div><div class="line">		&#125;);</div><div class="line">	&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>##jQuery代码风格</p>
<ol>
<li>链式操作风格</li>
</ol>
<ul>
<li>对于 同一个对象不超过3个操作，可以直接写成一行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;li&quot;).show().unbind(&quot;click&quot;);</div></pre></td></tr></table></figure>
<ul>
<li><p>对于同一个对象的较多操作，建议每行写一个操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(this).removeClass(&quot;mouseout&quot;)</div><div class="line"> .addClass(&quot;mouseover&quot;)</div><div class="line"> .stop()</div><div class="line"> .fadeTo(&quot;fast&quot;.0.6)</div><div class="line"> .fadeTo(&quot;fast&quot;.1)</div></pre></td></tr></table></figure>
</li>
<li><p>对于多个对象的少量操作，每个对象写一行，如果涉及子元素，可以考虑适当缩进</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(this).addClass(&quot;highlight&quot;)</div><div class="line">	.children(&quot;li&quot;).show().end()</div><div class="line">.siblings().removeClass(&quot;highlight&quot;)</div><div class="line">	.children(&quot;li&quot;).hide();</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>为代码添加注释<br>##jQuery对象和DOM对象</li>
<li>DOM对象<br>通过js中的getElementsByTagName或者，getElementById来获取元素节点，像这样的到的就是DOM对象</li>
<li>jQuery对象<br>jQuery对象就是通过jQuery包装DOM对象后产生的对象，jQuery对象是jQuery独有的，如果一个对象是jQuery对象，那么就可以使用jQuery里面的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&quot;#foo&quot;).html();</div><div class="line">等价于</div><div class="line">document.getElementById(&quot;foo&quot;).innerHTML</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>`注意：</code></p>
<ul>
<li>在jQuery对象中无法使用DOM对象的任何方法如：$(#id).innerHTML(错误)</li>
<li>DOM对象也不能使用jQuery里面的方法<br>如：document.getElementById(“id”).html()(错误)<br>###jQuery对象和DOM对象的相互转换</li>
</ul>
<ol>
<li>定义变量的风格</li>
</ol>
<ul>
<li>jQuery对象<br>var  $variable=jQuery对象（在变量前面加上$）</li>
<li>DOM对象<br>var variable=DOM对象</li>
</ul>
<ol>
<li>jQuery对象转化成DOM对象<br>（1）jQuery对象那个是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $cr=$(&quot;#cr&quot;);//jQuery对象</div><div class="line">var cr=$cr[0];//DOM对象</div><div class="line">alert(cr.checked);</div><div class="line">//检测这个checkbox是否被选中了</div></pre></td></tr></table></figure>
</li>
</ol>
<p>（2）还可以通过jQuery本身提供的，通过get(index)方法得到相应的DOM对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $cr=$(&quot;#cr&quot;);//jQuery对象</div><div class="line">var cr=$cr.get(0);//DOM对象</div><div class="line">alert(cr.checked);</div><div class="line">//检测这个checkbox是否被选中了</div></pre></td></tr></table></figure></p>
<ol>
<li>DOM对象转成jQuery对象<br>对于一个DOM对象，只要用$()把DOM对象包装起来，就可以获得一个jQuery对象了。方式为：$(DOM对象)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var cr=document.getElementById(&quot;cr&quot;);</div><div class="line">//DOM对象</div><div class="line">var $cr=$(cr);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>注意：</code></p>
<ul>
<li>转换后可以任意使用jQuery中方法</li>
<li>平时用到的jQuery对象都是通过$ ()函数制造出来的，$ ()函数就是一个jQuery对象的制造厂<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function()&#123;</div><div class="line">			var $cr=$(&quot;#cr&quot;);</div><div class="line">			var cr=$cr[0];</div><div class="line">			$cr.click(function()&#123;</div><div class="line">				if(cr.checked)&#123;</div><div class="line">					alert(&quot;感谢你的支持！你可以继续操作了！&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">//换成jQuery对象完成</div><div class="line">		$(document).ready(function()&#123;</div><div class="line">			var $cr=$(&quot;#cr&quot;);</div><div class="line">			$cr.click(function()&#123;</div><div class="line">				if($cr.is(&quot;:checked&quot;))&#123;</div><div class="line">					alert(&quot;感谢你的支持！你可以继续操作了1！&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##解决jQuery与其他库的冲突<br><code>注意：</code>默认情况下，jQuery用$作为自身的快捷方式</p>
<ol>
<li>jQuery库在其他库之后导入<br>在其他库和jQuery库被加载完毕后，可以在任何时候调用jQuery.noConflict()函数来将变量$的控制权转移给其他js库。</li>
<li>如果jQuery库在其他库之前就导入了，那么可以直接使用“jQuery”来做一些jQuery的工作，同时，可以使用$()方法作为其他库的快捷方式。这里无需jQuery.noConflict()函数。<br>##jQuery选择器</li>
<li>css选择器</li>
<li><p>jQuery选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">		$(&quot;.demo&quot;).click(function()&#123;</div><div class="line">			alert(&quot;jQuery选择器&quot;);</div><div class="line">		&#125;)</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;p class=&quot;demo&quot;&gt;jQuery Demo&lt;/p&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>jQuery选择器的优势</p>
</li>
</ol>
<ul>
<li>$()函数在很多js类库中都被作为一个选择器来使用。$(“#ID”)用来代替document.getElementById()函数。</li>
<li>支持css1到css3选择器</li>
<li>完善的处理机制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if(document.getElementById(&quot;tt&quot;))&#123;</div><div class="line">			document.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">------------------</div><div class="line"></div><div class="line">		$(&apos;#tt&apos;).css(&quot;color&quot;,&quot;red&quot;);</div><div class="line">//这里无需判断$(&apos;#tt&apos;)是否存在</div></pre></td></tr></table></figure>
<p><code>注意：</code>$(“#tt”)获取的永远是对象，即使网页没有此元素。因此当要用jQuery检查某个元素在网页上是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if($(&quot;#tt&quot;))&#123;</div><div class="line">//错误</div><div class="line">&#125;</div><div class="line">应该用获取到元素的长度来判断。</div><div class="line">if($(&quot;#tt&quot;).length&gt;0)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">或者转化成DOM对象来判断</div><div class="line">if($(&quot;#tt&quot;)[0])&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>jQuery基本选择器<br>它通过元素id,class和标签名等来查找DOM元素</li>
</ol>
<p><img src="http://obfnbicau.bkt.clouddn.com/jQuery%E5%9F%BA%E6%9C%AC%E9%80%89%E6%8B%A9%E5%99%A8.PNG" alt="Alt text"></p>
<ol>
<li><p>层次选择器<br>通过DOM元素之间的层次关系来获取特定元素。如：后代元素，子元素，相邻元素和同辈元素。<br>可以使用next()方法来替代$(‘prev+next’)选择器<br>$(‘.one+div’)等价于$(“.one”).next(“div”)<br>$(“#prev~siblings”)等价于$(“#prev”).nextAll(“div”)<br><img src="http://obfnbicau.bkt.clouddn.com/jQuery%E5%B1%82%E6%AC%A1%E9%80%89%E6%8B%A9%E5%99%A8.PNG" alt="Alt text"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//选取#prev之后的所有同辈div元素</div><div class="line">$(&quot;#prev~div&quot;).css(&quot;background&quot;,&quot;#eee&quot;);</div><div class="line">//同上</div><div class="line">$(&quot;#prev&quot;).nextAll(&quot;div&quot;).css(&quot;background&quot;,&quot;eee&quot;);</div><div class="line">//选取#prev所有的同辈div,无论前后位置</div></pre></td></tr></table></figure>
</li>
<li><p>过滤选择器<br>基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器<br>:has(selector)选取含有选择器所匹配的元素的元素。$(“div:has(p)”)选取含有</p><p>元素的<div>元素</div></p>
</li>
</ol>
<ul>
<li>基本过滤</li>
<li>内容过滤</li>
<li>可见性过滤</li>
<li>属性过滤</li>
<li>子元素过滤</li>
<li>表单对象属性过滤选择器<h2 id="选择器中含有特殊的符号的注意事项"><a href="#选择器中含有特殊的符号的注意事项" class="headerlink" title="选择器中含有特殊的符号的注意事项"></a>选择器中含有特殊的符号的注意事项</h2></li>
</ul>
<ol>
<li><p>选择器中含有”.”  ,”#”  ,”(“ ,”]”等特殊的字符<br>直接使用会出错，应该使用转义符转义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;id#b&quot;&gt;bbb&lt;/div&gt;</div><div class="line">&lt;div id=&quot;id[1]&quot;&gt;ccc&lt;/div&gt;</div><div class="line">普通方式获取：</div><div class="line">$(&quot;#id#b&quot;);</div><div class="line">$(&quot;#id[1]&quot;)</div><div class="line">以上错误</div><div class="line"></div><div class="line">$(&quot;#id\\#b&quot;);</div><div class="line">$(&quot;#id\\[1\\]&quot;);</div><div class="line">以上正确</div></pre></td></tr></table></figure>
</li>
<li><p>属性选择器的@符号问题<br>jQuery在1.3.1版本中彻底放弃了1.1.0版本遗留下来的@符号，如果使用1.3.1以上版本，则不需要在属性签添加@符号<br>如：<br>$(“div[@title=’test’]”);<br>正确写法是去除@符号<br>$(“div[title=’test’]”);</p>
</li>
<li>选择器中含有空格的注意事项<br>多一个空格或者少一个空格也许会得到截然不同的结果。</li>
</ol>
<p>filter(expr):筛选出与指定表达式匹配的元素集合，其中expr可以是多个选择器的组合。<br>与find()的区别：find()会在匀速内寻找匹配的元素，而filter()则是筛选元素。一个是对它的子集操作，一个是对自身集合元素进行筛选。</p>
<p>##jQuery其他选择器</p>
<ol>
<li>jQuery提供的选择器扩展</li>
</ol>
<ul>
<li>MoreSelectors for jQuery</li>
<li>Basic XPath</li>
</ul>
<ol>
<li>其他使用css选择器的方法</li>
</ol>
<ul>
<li>document.getElementBySelector()</li>
<li>cssQuery()</li>
<li>querySelectorAll()<br>##jQuery中的DOM操作</li>
</ul>
<p>DOM是一种与浏览器，平台，语言无关的接口，使用该接口可以轻松的访问页面中所有的而标准组件。</p>
<p>###DOM操作分类</p>
<ol>
<li>DOM Core(核心)<br>它并不专属于js</li>
<li>HTML-DOM</li>
<li>CSS-DOM<h3 id="jQuery中的DOM操作"><a href="#jQuery中的DOM操作" class="headerlink" title="jQuery中的DOM操作"></a>jQuery中的DOM操作</h3>一. 查找节点</li>
<li><p>查找元素节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var $li=$(&quot;ul li:eq(1)&quot;);</div><div class="line">//获取&lt;ul&gt;里面的第2个&lt;li&gt;节点</div><div class="line">var li_txt=$li.text();</div><div class="line">//获取元素节点的文本内容</div><div class="line">console.log(li_txt);</div></pre></td></tr></table></figure>
</li>
<li><p>查找属性节点<br>attr()方法：当参数是一个时，则是要查找的属性的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var $para=$(&quot;p&quot;);</div><div class="line">var p_txt=$para.attr(&quot;title&quot;);</div><div class="line">console.log(p_txt);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>二. 创建节点</p>
<ol>
<li>创建元素节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><code>注意：</code></p>
<ul>
<li>动态的创建的的新元素节点不会被自动添加到文档中，而是要用方法插入到文档中</li>
<li>可以用 $(“&lt; /p&gt;”)或者 $(“&lt; p&gt; &lt; /p&gt;”)不能使用$(“<p>“)或者$(“&lt;  /P&gt;”)</p></li>
</ul>
<ol>
<li><p>创建文本节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div></pre></td></tr></table></figure>
</li>
<li><p>创建属性节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var $li_1=$(&quot;&lt;li title=&quot;标题1&quot;&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">var $li_2=$(&quot;&lt;li title=&quot;标题2&quot;&gt;文本节点&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div><div class="line">``` </div><div class="line">三.插入节点</div><div class="line">各种方法</div><div class="line">* append()/appendTo()</div><div class="line">* prepend()/prependTo()</div><div class="line">* after()/insertAfter()</div><div class="line">* before()/insertBefore()</div><div class="line">四. 删除节点</div><div class="line">1. remove()方法</div><div class="line">作用：是从DOM中删除所有匹配的元素，传入的参数是用于根据jQuery表达式来筛选元素</div></pre></td></tr></table></figure>
</li>
</ol>
<p>$(“ul li:eq(1)”).remove();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`注意:`当某个节点用remove()删除后，该节点所包含的所有后代节点将同时被删除，这个方法的``返回值是一个指向已被删除节点的引用`</div></pre></td></tr></table></figure></p>
<p>var $li=$(“ul li:eq(1)”).remove();<br>//将第2个<li>从网页中删除<br>$li.appendTo(“ul”);<br>//把刚才删除的节点又重新添加到<ul>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">可以使用appendTo()的特性来简化以上代码</div></pre></td></tr></table></figure></ul></li></p>
<p>$(“ul li:eq(1)”).appendTo(“ul”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">remove()方法可以通过传递参数来选择性的删除元素</div></pre></td></tr></table></figure></p>
<p>$(“ul li”).remove(“li[title!=菠萝]”);<br>//删除title不为菠萝的li<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. detach()方法</div><div class="line">与remove()的区别：detach()不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同，所有绑定的事件，附加的数据等都会保留下来</div></pre></td></tr></table></figure></p>
<p>var $li=$(“ul li:eq(1)”).detach();<br>//将第2个<li>从网页中删除<br>$li.appendTo(“ul”);<br>//重新追加此元素，发现它之前的绑定的事件还在，如果使用remove（），那么它之前的绑定事件将失效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. empty()方法</div><div class="line">严格来讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点。</div></pre></td></tr></table></figure></li></p>
<p>$(“ul li:eq(1)”).empty();<br>//清空第2个li里的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">五.复制节点</div><div class="line">clone()方法</div><div class="line">在其中传入true，它的含义是复制元素的同时复制元素中所绑定的事件。因此该元素的副本也同样具有复制功能</div></pre></td></tr></table></figure></p>
<p>$(“ul li”).click(function(){<br>    $(this).clone().appendTo(“ul”)</p>
<p>});</p>
<p>$(this).clone(true).appendTo(“body”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">六.替换节点</div><div class="line">1. replaceWith()</div><div class="line">作用：是将所有匹配的元素替换成指定的HTML或者DOM元素。</div></pre></td></tr></table></figure>
<p>哈哈</p><br>$(“p”).replaceWith(“<strong>嗯嗯</strong>“);<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. replaceAll()</div><div class="line">作用与replaceWith()一样，只是颠倒了操作</div></pre></td></tr></table></figure><br><br>$(“<strong>嗯嗯</strong>“).replaceAll(“p”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">`注意：`如果在替换之前，已经为元素绑定了事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定事件</div><div class="line">七. 包裹节点</div><div class="line">1. wrap()方法：对于需要在文档中插入额外的结构化标记非常有用，而且它不会破坏原始文档的语义。</div></pre></td></tr></table></figure><br><br>$(“strong”).wrap(“<b></b>“);<br>得到如下：<br><b><strong></strong></b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. wrapAll()方法</div><div class="line">该方法是将所有匹配的元素用一个元素来包裹起来。</div></pre></td></tr></table></figure><br><br>wrap():<br>$(“strong”).wrap(“<b></b>“);<br>得到如下：<br><b><strong>1111</strong></b><br><b><strong>2222</strong></b><br>wrapAll():<br>$(“strong”).wrapAll(“<b></b>“);<br>得到如下：<br><b><br><strong>1111</strong><br><strong>2222</strong><br></b><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">`注意：`如果被包裹的多个元素间有其他元素，其他元素会被放在包裹元素之后</div><div class="line">3. wrapInner()方法</div><div class="line">该方法将每一个匹配的元素的子内容（包括文本节点）用其他结构化的标记包裹起来。</div></pre></td></tr></table></figure><br><br>$(“strong”).wrapInner(“<b></b>“);<br>结果如下：<br><strong title="选择你喜欢的水果"><b>你喜欢的水果是？</b></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 属性操作</div><div class="line">1. 获取属性和设置属性</div></pre></td></tr></table></figure><br><br>获取属性：<br>var $para=$(“p”);<br>var p_txt=$para.attr(“title”);<br>设置属性：(注意传递两个参数)<br>$(“p”).attr({“title”:”your title”,”name”:”test”});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`注意：`jQuery中有很多的方法都是一个函数同时实现获取和设置的功能（只是传入的参数不同而已）如：html(),text(),height(),width(),val()和css()方法。</div><div class="line">2. 删除属性</div></pre></td></tr></table></figure><br><br>$(“p”).removeAttr(“title”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(jQuery1.6中新增prop()和removeProp()方法)</div><div class="line">### 样式操作</div><div class="line">1. 获取样式和设置样式</div></pre></td></tr></table></figure><br><br><p class="myClass" title="你最喜欢的水果"></p><br>$(“p”).attr(“class”,”high”);<br>变为：<br><p class="high" title="你最喜欢的水果"></p>

<p>追加class用addCalss()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 追加样式</div><div class="line">addClass()方法</div></pre></td></tr></table></figure></p>
<p>$(“p”).addClass(“another”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 移除样式</div></pre></td></tr></table></figure>
<p>删除class=”high”<br>$(“p”).removeClass(“high”);<br>删除多个class<br>$(“p”).removeClass(“high another”);<br>删除全部class<br>$(“p”).removeClass();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">4. 切换样式</div><div class="line">* toggle()方法主要是控制行为上的重复切换</div><div class="line">* toggleClass()方法控制样式上的重复切换，如果类名存在则删除它，不在，就添加它</div></pre></td></tr></table></figure>
<p>$(“p”).toggleClass(“another”)<br>原样式与另一样式之间进行切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">5. 判断是否含有某个样式</div><div class="line">hasClass()可以用来判断元素中是否含有某个class</div><div class="line">，如果有则返回true，否则返回false</div><div class="line">`注意：`hasClass()是为了增强代码可读性而产生的，在jQuery内部实际上调用is()方法完成的。</div><div class="line"></div><div class="line">###设置和获取HTML，文本和值</div><div class="line">1. html()方法</div><div class="line">类似JavaScript中的innerHTML方法，可以用来读取或者设置某个元素中的HTML内容</div><div class="line">2. text()方法</div><div class="line">类似与JavaScript中的innerText属性，可以用来读取或者设置某个元素中的文本内容。</div><div class="line">3. val()方法</div><div class="line">类似JavaScript中的value属性，可以用来设置和获取元素的值。无论元素是文本框，下拉列表还是单选框。它都可以返回元素的值。如果元素为多选，则返回一个包含所有选择的值的数组。</div><div class="line">this指向当前的“文本框”，this.defaultValue就是当前“文本框”的默认值</div><div class="line">还有一种用法：</div><div class="line">它能使select，checkbox，radio相应的选项被选中。</div></pre></td></tr></table></figure></p>
<p>$(“single”).val(“选择2号”);<br>$(“#multiple”).val([“选择2号”,”选择3号”);<br>$(“:checkbox”).val([“check2”,”check3”]);<br>$(“:radio”).val([“radio”]);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">###遍历节点</div><div class="line">1. children()方法，只考虑子元素而不考虑其他后代元素</div><div class="line">2. next()方法</div><div class="line">用于取得匹配元素后面紧邻的同辈元素</div><div class="line">3. prev()方法</div><div class="line">用于取得匹配元素前面紧邻的同辈元素</div><div class="line">4. siblings()方法</div><div class="line">该方法用于取得匹配元素前后所有的同辈元素</div><div class="line">5. closest()</div><div class="line">该方法用于取得最近的匹配的元素，首先检查当前元素是否匹配，如果匹配则返回元素本身。如果不匹配则向上查找父级，逐级向上直到找到匹配的选择器的元素，若什么都没找到，则返回一个jQuery空对象。</div><div class="line">6. parent(),parents(),closest()的区别</div><div class="line">## CSS-DOM操作</div><div class="line">css()方法设置和获取样式</div><div class="line">`注意：`</div><div class="line">* 如果值是数字，将会被自动转化为像素值</div><div class="line">* 在css()方法中，如果属相中带有&quot;-&quot;符号，</div><div class="line">例如：font-size和background-color属性</div><div class="line">如果在设置这些属性的值的时候不带引号，那么就要用驼峰式写法，例如：</div><div class="line">$(&quot;p&quot;).css(&#123;fontSize:&quot;30px&quot;,backgroundColor:&quot;#888&quot;&#125;)</div><div class="line">1. height()方法</div><div class="line">2. width()方法</div></pre></td></tr></table></figure></p>
<p>$(“p”).width();<br>//获取</p><p>元素的宽度值<br>$(“p”).width(“400px”);<br>//设置</p><p>元素的宽度值为400px<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. offset()方法</div><div class="line">获取元素在当前视窗的相对偏移，其中返回的对象包含两个属性，即top和left，它只对可见元素有效。</div></pre></td></tr></table></figure></p>
<p>var offset=$(“p”).offset();<br>var left=offset.left;<br>vat top=offset.top;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2. position()方法</div><div class="line">它的作用是获取元素相对于最近一个position样式属性设置为relative或者absolute的祖父节点的相对偏移。与offset()一样，它返回的对象（top和left）</div><div class="line">3. scrollTop()方法和scrollLeft()方法</div><div class="line">可以为这两个方法指定一个参数，控制元素的滚动到指定的位置。</div></pre></td></tr></table></figure></p>
<p>var $p=$(“p”);<br>var scrollTop=$p.scrollTop();<br>var scrollLeft=$p.scrollLeft();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">##jQuery中的事件和动画</div><div class="line">###jQuery中的事件</div><div class="line">1. 加载DOM</div><div class="line">$(document).ready()方法来代替window.onload方法，使用该方法可以在DOM载入就绪时就对其进行操作并执行它所绑定的函数。</div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/$%28document%29.ready%28%29%E4%B8%8Ewindow.onload%E6%96%B9%E6%B3%95.PNG)</div><div class="line">2. 事件绑定</div><div class="line">bind()方法来对匹配元素进行特定事件的绑定。</div><div class="line">bind(type [. data] . fn);</div><div class="line">第一参数：blur,focus,load,resize……等，也可以自定义名称。</div><div class="line">第二参数：为可选参数，作为event.data属性值传递给事件对象的额外数据对象。</div><div class="line">第三参数：用来绑定的处理函数。</div><div class="line"></div><div class="line">3. 合成事件</div><div class="line">jQuery有两个合成事件----hover()方法和toggle()方法</div><div class="line">* hover()方法</div><div class="line">hover(enter,leave)方法用于模拟光标悬停事件。当鼠标移动到元素上时，会触发指定的`第一个函数(enter)`;当鼠标移出这个元素时，会触发指定的`第二个函数(leave)`。</div><div class="line">* toggle()方法</div><div class="line">toggle(fn1,fn2,fn3,fn4……,fnN)</div><div class="line">用于模拟鼠标连续单击事件。</div><div class="line">toggle()方法在jQuery中还有另一个作用：切换元素的可见状态。如果元素是可见的，单击切换后则为隐藏。如果元素是隐藏的，单击切换后则为可见的。</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>    $(“#panel h5.head”).toggle(function(){<br>$(this).addClass(“highlight”);<br>$(this).next().show();</p>
<p>},function(){<br>$(this).removeClass(“highlight”);<br>$(this).next().hide();<br>});<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">###事件冒泡</div><div class="line">1. 什么是事件冒泡</div><div class="line">在页面上可以有多个事件，也可以多个元素响应同一个事件。假设网页上有两个元素，其中一个元素嵌套在另一个元素里，并且都被绑定了click是事件，同时&lt;body&gt;元素上也绑定了click事件。</div><div class="line">2. 事件对象</div><div class="line">事件对象就被创建了，这个事件对象只有事件处理函数才能访问到，事件处理函数执行后，事件对象就被销毁。</div><div class="line">3. 停止事件冒泡</div><div class="line">停止事件冒泡可以阻止事件中其他的事件函数被执行。jQuery中提供了stopPropagation()方法来停止事件冒泡。</div></pre></td></tr></table></figure></p>
<p>$(‘span’).bind(“click”,function(event){<br>                var txt=$(‘#msg’).html()+”</p><p>内层span元素被单击</p>“;<br>                $(“#msg”).html(txt);<br>    event.stopPropagation();<br>    //停止事件冒泡<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 阻止默认行为</div><div class="line">网页中的元素有自己的默认行为。如：单击超链接后会跳转，单击提交按钮后表单会提交，有时需要阻止这些默认行为。用preventDefault()方法来阻止元素的默认行为。</div></pre></td></tr></table></figure><p></p>
<p>event.preventDefault();<br>//阻止默认行为                event.stopPropagation();<br>//停止事件的冒泡<br>// return false;(对上述阻止行为的简写)<br>//同时阻止默认行为,停止事件的冒泡<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">5. 事件捕获</div><div class="line">与事件冒泡相反，jQuery不支持事件捕获</div><div class="line">6. 事件对象的属性</div><div class="line">* event.type</div></pre></td></tr></table></figure></p>
<pre><code>$(&quot;a&quot;).click(function(event){
        alert(event.type);
        return false;
    });
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* event.preventDefault()方法</div><div class="line">* event.stopPropagation()方法</div><div class="line">* event.target</div><div class="line">作用：是获取到触发事件的元素</div></pre></td></tr></table></figure>
<p>$(“a[href=’<a href="http://google.com&#39;]).click(function(event){" target="_blank" rel="external">http://google.com&#39;]).click(function(event){</a><br>    var tg=event.target;<br>    alert(tg.href);<br>    //<a href="http://google.com" target="_blank" rel="external">http://google.com</a><br>    return false;<br>});</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*  event.relatedTarget</div><div class="line">*  event.pageX和event.pageY</div><div class="line">作用：获取到光标相对于页面的x坐标，y坐标。</div><div class="line">* event.which</div><div class="line">该方法的作用是在鼠标单击事件中获取到鼠标左，中，右键；在键盘事件中获取键盘的按键。</div></pre></td></tr></table></figure>
<p>$(“a”).mousedown(function(e){<br>                console.log(e.which);<br>                return false;<br>        });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* event.metaKey</div><div class="line">jQuery规定event.metaKey为键盘事件中获取&lt;ctrl&gt;按键</div><div class="line">###移除事件</div><div class="line">1. 移除按钮元素上以前注册的事件</div><div class="line">`unbind([type],[data]);方法`</div><div class="line">第一个参数事件类型，第二个参数是将要移除的函数。</div><div class="line">（1）如果没有参数，则删除所有的绑定事件</div><div class="line">（2）如果提供了事件类型作为参数，则只删除该类型的绑定事件</div><div class="line">（3）如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。</div></pre></td></tr></table></figure></p>
<p>$(“#delAll”).click(function(){<br>                $(“#btn”).unbind(“click”);<br>            });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 移除&lt;button&gt;元素的其中一个事件</div><div class="line">（首先需要为这些匿名函数指定一个变量）</div></pre></td></tr></table></figure>
<p>$(‘#btn’).bind(“click”,myFun1=function(){<br>$(‘#test’).append(“</p><p>我的绑定函数1</p>“);<br>            }).bind(“click”,myFun2=function(){<br>$(‘#test’).append(“<p>我的绑定函数2</p>“);            }).bind(“click”,myFun3=function(){<br>$(‘#test’).append(“<p>我的绑定函数3</p>“);<br>    });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">`one()方法`</div><div class="line">one()对于只需要触发一次，随后就要立即解除绑定情况。one()方法可以为元素绑定处理函数。当处理函数触发一次后，立即 被删除，即每个对象上，事件处理函数只会被执行一次。</div><div class="line">one(type,[data],fn)</div><div class="line">###模拟操作</div><div class="line">如：当用户进入页面后，就会触发click事件，而非不需要用户去主动单击；</div><div class="line">1. 常用模拟</div><div class="line">* $(&apos;#btn&apos;).trigger(&quot;click&quot;);</div><div class="line">* $(&apos;#btn&apos;).click();</div><div class="line">2. 触发自定义事件</div><div class="line">trigger()方法不仅能触发浏览器支持的具有相同名称的事件，也可以触发自定义名称事件。</div></pre></td></tr></table></figure><p></p>
<p>$(function(){                $(‘#btn’).bind(“myClick”,function(){<br>$(‘#test’).append(“</p><p>我的自定义事件</p>“);<br>    });<br>                $(‘#btn’).trigger(“myClick”);<br>});<p></p>
<p><button id="btn">单击我</button></p>
<p><div id="test"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 传递数据</div><div class="line">trigger(type,[data])方法有两个参数，第一个参数是要触发的事件类型，第二个参数是要传递给事件处理函数的附加数据，以数组的形式传递，通常可以通过传递一个参数给回调函数来区别这次事件是代码触发的还是用户触发的。。</div></pre></td></tr></table></figure></p>
<p>$(function(){        $(‘#btn’).bind(“myClick”,function(event,message1,message2){<br>$(‘#test’).append(“</p><p>“+message1+message2+”</p>“);<br>});<br>            $(‘#btn’).trigger(“myClick”,[“我的”,”梦想”]);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 执行默认操作</div><div class="line">trigger()方法触发事件后，会执行浏览器默认操作。</div></pre></td></tr></table></figure><p></p>
<p>$(“input”).trigger(“focus”);<br>//以上代码不仅会触发<input>元素绑定的focus事件，也会使<input>元素本身得到焦点（这是浏览器的默认操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">如果只想触发绑定的focus是事件，而不想执行浏览器默认操作，可以使用jQuery的triggerHandler(&quot;focus&quot;);</div><div class="line">* 使用triggerHandler()只是触发元素上绑定的事件，不会得到焦点。</div><div class="line">###其他用法</div><div class="line">1. 绑定多个事件类型</div><div class="line">bind()方法绑定多个事件。</div></pre></td></tr></table></figure></p>
<pre><code>$(function(){
</code></pre><p>$(“.bg”).bind(“mouseover mouseout”,function(){<br>        $(this).toggleClass(“over”);<br>            });<br>        });<br>        相当与下面代码：<br>$(function(){<br>            $(“.bg”).bind(“mouseover”,function(){<br>                $(this).toggleClass(“over”);<br>            }).bind(“mouseout”,function(){<br>                $(this).toggleClass(“over”);<br>            });<br>        });<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 添加事件命名空间，便于管理</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>            $(“div”).bind(“click.plugin”,function(){<br>                $(“body”).append(“</p><p>click事件</p>“);<br>            });<br>            $(“div”).bind(“mouseover.plugin”,function(){<br>                $(“body”).append(“<p>mouseover事件</p>“);<br>            });<br>            $(“div”).bind(“dbclick.plugin”,function(){<br>                $(“body”).append(“<p>dbclick事件</p>“);<br>            });<br>            $(“button”).click(function(){<br>                $(“div”).unbind(“.plugin”);<br>            });<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 相同事件名称，不同命名空间执行方法</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“div”).bind(“click”,function(){<br>                $(“body”).append(“</p><p>click事件</p>“);<br>            });<br>            $(“div”).bind(“click.plugin”,function(){<br>                $(“body”).append(“<p>click.plugin事件</p>“);<br>            });<br>            $(“button”).click(function(){<br>                $(“div”).trigger(“click!”);<br>            })<br>        });<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`注意：`trigger(&quot;click&quot;)后面的！感叹号的作用是匹配所有不包含在命名空间中的click方法</div><div class="line">## jQuery中的动画</div><div class="line">###show()方法和hide()方法</div><div class="line">1. show()方法和hide()方法</div><div class="line">在HTML文档里，为一个元素调用hide()方法，会将该元素的display样式改为&quot;none&quot;</div></pre></td></tr></table></figure>
<p>$(“element”).hide();<br>等价于：<br>$(“element”).css(“display”,”none”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">`注意：`用jQuery做动画效果要求在`标准模式`下，否则可能会引起动画抖动。</div><div class="line">2. show()方法和hide()方法让元素动起来</div><div class="line">上述两个方法在不带任何参数的情况下，相当于</div><div class="line">css(&quot;display&quot;,&quot;none/block/inline&quot;),不会有任何动画。</div><div class="line">&gt;可以为指定一个速度参数（&quot;slow&quot;表示速度为600毫秒，&quot;normal&quot;表示400毫秒，&quot;fast&quot;表示200毫秒），$ (&quot;element&quot;).show(&quot;fast&quot;)&gt;也可以显示速度为一个数字，单位为毫秒，$ (&quot;element&quot;).show(1000);</div><div class="line"></div><div class="line">&gt;hide()方法会同时减少“内容”的高，宽，和不透明度，直至这3个属性的值都为0</div><div class="line">###fadeIn()方法和fadeOut()方法</div><div class="line">只改变元素的不透明度</div><div class="line">###slideUp方法和slideDown()方法</div><div class="line">只改变元素的高度，如果一个元素的display属性值为&quot;none&quot;，当调用slideDown()方法时，这个元素将由上至下延伸。</div><div class="line">###自定义动画方法</div><div class="line">animate(params,speed,callback);</div><div class="line">* params:一个包含样式属性及值的映射，如：</div><div class="line">&#123;property1:&quot;value1&quot;,property2:&quot;value2&quot;..........&#125;</div><div class="line">* speed:速度参数，可选</div><div class="line">* callback:在动画完成时执行的函数，可选</div><div class="line">1. 自定义简单动画</div></pre></td></tr></table></figure></p>
<p>$(function(){<br>            $(“#panel”).mouseover(function(){<br>                $(this).animate({left:”500px”},3000);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2. 累加，累减动画</div><div class="line">在value值前面加上&quot;+=&quot;或&quot;-=&quot;符号表示在当前位置累加或者累减。</div></pre></td></tr></table></figure>
<p>$(this).animate({left:”+=500px”},3000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3. 多重动画</div><div class="line">* 同时执行多个动画</div></pre></td></tr></table></figure></p>
<p>$(“div”).click(function(){<br> $(this).animate({left:”500px”,height:”200px”},3000);<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* 按顺序执行多个动画(动画队列)</div></pre></td></tr></table></figure></p>
<p>$(this).animate({left:”500px”},3000);<br>$(this).animate({height:”500px”},3000);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">4. 动画回调函数</div><div class="line">`注意：`callback回调函数适合用于jQuery的所有动画效果</div></pre></td></tr></table></figure></p>
<p>$(“#panel”).css(“opacity”,”0.5”);<br>            $(“#panel”).click(function(){<br>                $(this).animate({left:”400px”,height:”200px”,opacity:”1”},3000)<br>                    .animate({top:”200px”,width:”200px”},3000,function(){<br>                        $(this).css(“border”,”5px solid green”);<br>                    })<br>                    // .fadeOut(“slow”);<br>                    //让元素最后隐藏消失<br>                    // .css(“border”,”5px solid green”);<br>                    //一开始动画就执行了，需要用回调函数，将css()放在动画队列里面</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">###停止动画和判断是否处于动画状态</div><div class="line">1. 停止元素的动画</div><div class="line">stop()方法，stop([clearQueue],[gotoEnd]);</div><div class="line">clearQueue和gotoEnd都是可选的参数，为Boolean值（true或false）</div><div class="line">2. 判断元素是否处于动画状态</div></pre></td></tr></table></figure>
<p>if(!$(element).is(“:animated”)){<br>//判断元素是否处于动画状态<br>//如果当前没有进行动画，则添加新动画<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">3. 延迟动画</div><div class="line">delay()方法</div><div class="line">4.其他动画方法</div><div class="line">* toggle(speed,[callback])</div><div class="line">* slideToggle(speed,[easing],[callback])</div><div class="line">* fadeTo(speed,opacity,[callback])</div><div class="line">* fadeToggle(speed,[easing],[callback])</div><div class="line"></div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/%E5%8A%A8%E7%94%BB%E6%96%B9%E6%B3%95.PNG)</div><div class="line">5. 动画队列</div><div class="line">（1）一组元素上的动画效果</div><div class="line">* 当在一个animate()方法中应用多个属性时，动画是同时发生的</div><div class="line">* 当以链式的写法应用动画方法时，动画是按照顺序发生的</div><div class="line">（2）多组元素上的动画效果</div><div class="line">* 默认情况下，动画都是同时发生的</div><div class="line">* 当以回调的形式应用动画时，动画是按照回调顺序的发生的</div><div class="line">`注意：`在动画方法中，要注意其他非动画方法会插队，如：css()方法要使非动画方法也按照顺序执行，需要把这些方法写在动画方法的回调函数。</div><div class="line">##jQuery对表单，表格的操作及其更多的应用</div><div class="line">###表单的应用</div><div class="line">（1）表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法</div><div class="line">（2）表单域：包含文本框，密码框，隐藏域，复选框，单选框，下拉选择框和文件上传框等</div><div class="line">（3）表单按钮：包括提交按钮，复位按钮和一般按钮，用于数据传送到服务器上或者取消传送，还可以用来控制其他处理脚本的处理工作</div><div class="line">1. 单行文本框的应用</div><div class="line">* 获取和失去焦点改变样式</div></pre></td></tr></table></figure></p>
<p>/*input:focus,textarea:focus{<br>            border: 2px solid #f00;<br>            background: #fcc;</p>
<pre><code>}*/
</code></pre><hr>
<pre><code>/*解决IE6不支持:focus伪类情况*/
.focus{
    border: 2px solid #f00;
    background: #fcc;
}
</code></pre><p>$(function(){<br>            $(“:input”).focus(function(){<br>                $(this).addClass(“focus”);<br>            }).blur(function(){<br>                $(this).removeClass(“focus”);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 多行文本框的应用</div></pre></td></tr></table></figure>
<p>// $(function(){<br>        //     var $comment=$(“#comment”);<br>        //     $(“.bigger”).click(function(){<br>        //         if($comment.height()<500){ $comment.height($comment.height()+50);="" }="" });="" $(".smaller").click(function(){="" if($comment.height()="">50){<br>        //             $comment.height($comment.height()-50);<br>        //         }<br>        //     });</500){></p>
<pre><code>// });
//使用animate()有一种缓冲效果比起height()

$(function(){
    var $comment=$(&quot;#comment&quot;);
    $(&quot;.bigger&quot;).click(function(){
        if(!$comment.is(&quot;:animated&quot;)){
            if($comment.height()&lt;500){
                $comment.animate({height:&quot;+=50&quot;},400);
            }
        }
    });
    $(&quot;.smaller&quot;).click(function(){
        if(!$comment.is(&quot;:animated&quot;)){
            if($comment.height()&gt;50){
                $comment.animate({height:&quot;-=50&quot;},400);
            }
        }
    });
});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3. 复选框的应用</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“#checkAll”).click(function(){<br>                $(‘[name=items]:checkbox’).attr(‘checked’,true);<br>            });<br>            $(“#checkNo”).click(function(){<br>                $(‘[name=items]:checkbox’).attr(‘checked’,false);<br>            });<br>            $(“#checkRev”).click(function(){<br>                $(‘[name=items]:checkbox’).each(function(){<br>                    // $(this).attr(“checked”,!$(this).attr(“checked”));<br>                    this.checked=!this.checked;<br>                });<br>            });<br>            $(“#send”).click(function(){<br>                var str=”你选中的是：\r\n”;<br>                $(‘[name=items]:checkbox:checked’).each(function(){<br>                    str+=$(this).val()+”\r\n”;<br>                });<br>                alert(str);<br>            });<br>        });</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">把全选和不全选改为复选框：</div></pre></td></tr></table></figure>
<p>$(function(){<br>        //     $(‘[name=items]:checkbox’).click(function(){<br>        //     var flag=true;<br>        //     $(‘[name=items]:checkbox’).each(function(){<br>        //         if(!this.checked){<br>        //             flag=false;<br>        //         }<br>        //     });<br>        //     $(‘#checkedAll’).attr(‘checked’,flag);<br>        // });<br>//另一种方法：判断复选框的总数是否与选中的复选框数量相等</p>
<p>$(‘[name=items]:checkbox’).click(function(){<br>    //定义一个临时变量，避免重复使用同一个选择器选择页面中的元素，提高程序效率<br>    var $tmp=$(‘[name=items]:checkbox’);<br>    //用filter()方法选出选中的复选框，直接给checkedAll赋值<br>    $(‘#checkedAll’).attr(‘checked’,$tmp.length==$tmp.filter(‘:checked’).length);<br>});</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">`注意：`哪些属性该用attr()访问，哪些应该用prop()访问？</div><div class="line">第一个原则：只添加属性名称该属性就会生效应该使用prop()</div><div class="line">第二个原则：只存在true/false的属性应该使用prop()</div><div class="line">按照官方的说明：如果是设置disabled和checked这些属性，应该使用prop()方法，而不是使用attr()方法。</div><div class="line">4. 下拉框的应用</div></pre></td></tr></table></figure>
<p>$(function(){<br>            //从左到右<br>            $(‘#add’).click(function(){<br>                var $options=$(‘#select1 option:selected’);<br>                // var $remove=$options.remove();<br>                // $remove.appendTo(‘#select2’);<br>                //删除和追加可以直接用appendTo()方法完成<br>                $options.appendTo(‘#select2’);<br>            });<br>            $(‘#add_all’).click(function(){<br>                var $options=$(‘#select1 option’);<br>                $options.appendTo(‘#select2’);<br>            });<br>            $(‘#select1’).dblclick(function(){<br>                var $options=$(“option:selected”,this);<br>                $options.appendTo(‘#select2’);<br>            });<br>            //右到左<br>            $(‘#remove’).click(function(){<br>                var $options=$(‘#select2 option:selected’);<br>                // var $remove=$options.remove();<br>                // $remove.appendTo(‘#select2’);<br>                //删除和追加可以直接用appendTo()方法完成<br>                $options.appendTo(‘#select1’);<br>            });<br>            $(‘#remove_all’).click(function(){<br>                var $options=$(‘#select2 option’);<br>                $options.appendTo(‘#select1’);<br>            });<br>            $(‘#select2’).dblclick(function(){<br>                var $options=$(“option:selected”,this);<br>                $options.appendTo(‘#select1’);<br>            });</p>
<pre><code>});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">5. 表单验证</div><div class="line">###表格的应用</div><div class="line">（1）普通的隔行变色</div></pre></td></tr></table></figure>
<p><style><br>        .even{<br>            background: red;<br>            /<em>偶数行样式
</em>/<br>        }<br>        .odd{<br>            background: green;<br>            /<em>奇数行样式</em>/<br>        }<br>    </style></p>
<script>
        $(function(){
            $("tr:odd").addClass("odd");
            $("tr:even").addClass("even");
        });
    </script>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">`注意：`$(&quot;tr:odd&quot;)和$(&quot;tr:even&quot;)选择器中索引是从0开始，因此第一行是偶数。</div><div class="line">&gt;单选按钮控制表格变色：</div></pre></td></tr></table></figure>
<p>$(function(){<br>            // $(“tr:odd”).addClass(“odd”);<br>            // $(“tr:even”).addClass(“even”);<br>            // 除去表头的隔行变色<br>            $(“tbody&gt;tr:odd”).addClass(“odd”);<br>            $(“tbody&gt;tr:even”).addClass(“even”);<br>            //某一行高亮显示<br>            // $(“tr:contains(‘张珊5’)”).addClass(‘selected’);<br>            //单击单选按钮，进行高亮显示<br>        $(‘tbody&gt;tr’).click(function(){<br>            $(this)<br>                .addClass(‘selected’)<br>                .siblings().removeClass(‘selected’)<br>                .end()<br>                //使用end()后.find(‘:radio’)就是$(this).find(‘:radio’)<br>                .find(‘:radio’).attr(‘checked’,true);<br>        });<br>        $(‘table :radio:checked’).parent().parent().addClass(‘selected’);<br>        //注意$(‘table :radio:checked’)中table与:radio间一定要有空格</p>
<pre><code>//用parents()方法简化
$(&apos;table :radio:checked&apos;).parents(&quot;tr&quot;)addClass(&apos;selected&apos;);
//has()方法进一步简化代码
$(&apos;tbody&gt;tr:has(:checked)&apos;).addClass(&quot;selected&quot;);
});
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#jQuery与Ajax的应用</div><div class="line">1. Ajax的优势</div><div class="line">* 不需要插件支持</div><div class="line">* 优秀的用户体验</div><div class="line">* 提高Web程序的性能</div><div class="line">* 减轻服务器和宽带的负担</div><div class="line">2. Ajax的不足</div><div class="line">* 浏览器对XMLHttpRequest对象的支持度不足</div><div class="line">* 破坏浏览器前进，“后退”按钮的正常功能</div><div class="line">* 对搜索引擎的支持不足</div><div class="line">* 开发和调试工具缺乏</div><div class="line">3. Ajax的XMLHttpRequest对象</div><div class="line">XMLHttpRequest对象是AJAX的核心——发送异步请求，接受响应及执行回调都是通过 它来完成的</div><div class="line">4. 安装Web环境——AppServ</div><div class="line">&gt;下载地址http://www.appservnetwork.com</div><div class="line">5. load()方法</div><div class="line">(1)载入HTML文档</div><div class="line">load(url [,data] [,callback])</div><div class="line"></div><div class="line">![Alt text](./load方法.PNG)</div></pre></td></tr></table></figure>
<p>$(function(){<br>            $(“#send”).click(function(){<br>                $(“#resText”).load(“test.html”);<br>            });<br>        });</p>
<p><input type="button" id="send" value="Ajax获取"><br>    <div class="comment">已有评论</div><br>    <div id="resText"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（2）筛选载入的HTML文档</div></pre></td></tr></table></figure></p>
<p>//只加载test.html页面中的class为para的内容<br>                $(“#resText”).load(“test.html .para”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（3）传递方式</div><div class="line">load()方法的传递方式根据参数data来自动指定，如果没有参数传递，则采用GET方式传递，反之，则会自动转换为post方式</div></pre></td></tr></table></figure></p>
<p>//无参数传递，则是get方式<br>$(“$resText”).load(“test.php”,function(){<br>});<br>//有参数传递，则是；post方式<br>$(“#resText”).load(“test.php”,{name:”rain”,age:”22” },function(){<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（4）回调参数</div><div class="line">对于 必须在加载完成后才能继续的操作，load()方法提供了回调函数（callback），该函数有3个参数分别代表请求返回的内容，请求状态，和XMLHttpRequeat对象。</div></pre></td></tr></table></figure></p>
<p>$(“#resText”).load(“test.php”,function(responseText,textStatus,XMLHttpRequest){<br>//responseText请求返回的内容<br>//textStatus请求返回的状态<br>//XMLHttpRequest：XMLHttpRequest对象<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">6.  $.get()方法和 $ . post()方法</div><div class="line">（1）$.get()方法</div><div class="line">使用get方式来进行异步请求</div><div class="line">$.get(url [,data] [,callback][,type])</div><div class="line">![Alt text](http://obfnbicau.bkt.clouddn.com/$get%28%29%E6%96%B9%E6%B3%95.PNG)</div><div class="line">（2）$.post()方法</div><div class="line">&gt;GET与POST方式的区别</div><div class="line">* get请求会将参数跟在URL后进行传递，而post请求则是作为http消息的实体内容发送Web服务器，当然在ajax请求中，这种区别是对用户不可见的</div><div class="line">* get方式对传输的数据有大小限制（一般不大于2kb）而使用post方式传递的数据量比get大（一般不受限制）</div><div class="line">* get方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据（账号，密码等），而post方式不会</div><div class="line">* get方式和post方式传递的数据在服务器端的获取也不相同。在PHP中get的数据可以用 $_ GET[]获取，而post方式可以用$_post[]获取,两种可以用$_REQUEST[]来获取</div><div class="line">7. $.getScript()方法和$.getJson()方法</div><div class="line">&gt;JSONP(JavaScript with Padding )是一个</div><div class="line">8. $.ajax(options)该方法只有一个参数</div><div class="line">###序列化元素</div><div class="line">1. serialize()方法</div><div class="line">2. serializeArray()方法</div><div class="line">该方法不是返回字符串，而是将，DOM元素序列化之后，返回json格式的数据</div><div class="line">3. $.param()方法</div><div class="line">它是serialize()方法的hexin，用来对一个数组或者一个对象按照key/value进行序列化。</div><div class="line">```var obj=&#123;a:1,b:2,c:3&#125;;</div><div class="line">	var k=$.param(obj);</div><div class="line">   console.log(k);</div><div class="line">   //a=1&amp;b=2&amp;c=3</div></pre></td></tr></table></figure></p>
<p>###禁用缓存<br>问题：数据已经更新了，但传递的还是以前的数据<br>解决：应该禁用缓存<br>如果是$.post方法获取的数据，那么默认就是禁用缓存的，如果是$.get()方法，可以设置时间戳来避免缓存，可以在URL的后面加上+(+new Date)<br>(+new Date)的等价于new Date().getTime()<br>不用随机数的原因：因为随机数对于一台电脑来说，在大量使用之后出现重复的概率会很大，而时间戳不会。<br>如果是使用了$.ajax()方法来获取数据，只需要设置cache:false即可，<code>注意：</code>false是布尔值，而不是字符串。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的基础知识]]></title>
      <url>http://yoursite.com/2016/09/18/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="JavaScript实现继承"><a href="#JavaScript实现继承" class="headerlink" title="JavaScript实现继承"></a>JavaScript实现继承</h1><ol>
<li>原型链</li>
</ol>
<ul>
<li>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>构造函数，原型和实例三者之间的关系：每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针（constructor属性，这个属性包含一个指向prototype属性所在的函数指针，而实例都包含一个指向原型对象的内部指针）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//原型链</div><div class="line">	function SuperType()&#123;</div><div class="line">		this.property=true;</div><div class="line">	&#125;</div><div class="line">	SuperType.prototype.getSuperValue=function()&#123;</div><div class="line">		return this.property;</div><div class="line">	&#125;;</div><div class="line">	function SubType()&#123;</div><div class="line">		this.subproperty=false;</div><div class="line">	&#125;</div><div class="line">	SubType.prototype=new SuperType();</div><div class="line">	SubType.prototype.getSubValue=function()&#123;</div><div class="line">		return this.subproperty;</div><div class="line">	&#125;</div><div class="line">	var instance=new SubType();</div><div class="line">	console.log(instance.getSuperValue());</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>借用构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">借用构造函数</div><div class="line">	function SuperType()&#123;</div><div class="line">		this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">	&#125;</div><div class="line">	function Subtype()&#123;</div><div class="line">		SuperType.call(this);</div><div class="line">		//实现继承</div><div class="line">	&#125;</div><div class="line">	var instance1=new Subtype();</div><div class="line">	instance1.colors.push(&quot;black&quot;);</div><div class="line">	console.log(instance1.colors);</div><div class="line">	//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line">	var instance2=new Subtype();</div><div class="line">	console.log(instance2.colors);</div><div class="line">	[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</div></pre></td></tr></table></figure>
</li>
<li><p>借用构造函数传递参数的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">传递参数</div><div class="line">function SuperType(name)&#123;</div><div class="line"> this.name=name;	</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">	SuperType.call(this,&quot;chenyu&quot;);</div><div class="line">	this.age=29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance=new SubType();</div><div class="line">console.log(instance.name);</div><div class="line">//chenyu</div><div class="line">console.log(instance.age);</div><div class="line">29</div></pre></td></tr></table></figure>
</li>
<li><p>组合继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">组合继承</div><div class="line">function SuperType(name)&#123;</div><div class="line">	this.name=name;</div><div class="line">	this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName=function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">function SubType(name,age)&#123;</div><div class="line">	SuperType.call(this,name);</div><div class="line">	this.age=age;</div><div class="line">&#125;</div><div class="line">//继承方法</div><div class="line">SubType.prototype=new SuperType();</div><div class="line">SubType.prototype.constructor=SubType;</div><div class="line">SubType.prototype.sayAge=function()&#123;</div><div class="line">	console.log(this.age);</div><div class="line">&#125;</div><div class="line">var instance1=new SubType(&quot;chenyu&quot;,20);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">console.log(instance1.colors);</div><div class="line">//&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</div><div class="line">instance1.sayName();</div><div class="line">//chenyu</div><div class="line">instance1.sayAge();</div><div class="line">//20</div></pre></td></tr></table></figure>
</li>
<li><p>寄生式继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">寄生式继承</div><div class="line">function object(o)&#123;</div><div class="line">	function F()&#123;&#125;//临时性的构造函数</div><div class="line">	F.prototype=o;//吧传入的参数给构造函数的原型</div><div class="line">	return new F();//返回函数创造的新实例</div><div class="line"></div><div class="line">&#125;</div><div class="line">var person=&#123;</div><div class="line">	name:&quot;chenyu&quot;,</div><div class="line">	friends:[&quot;haha&quot;,&quot;enen&quot;,&quot;yeye&quot;]</div><div class="line">&#125;</div><div class="line">//创建两个person的副本对其对象进行修改</div><div class="line">var anotherPerson=object(person);</div><div class="line">anotherPerson.name=&quot;chenyu&quot;;</div><div class="line">anotherPerson.friends.push(&quot;bob&quot;);</div><div class="line">var anotherPerson1=object(person);</div><div class="line">anotherPerson1.name=&quot;chenqian&quot;;</div><div class="line">anotherPerson1.friends.push(&quot;fighting&quot;);</div><div class="line">console.log(person.friends);</div><div class="line">//[&quot;haha&quot;, &quot;enen&quot;, &quot;yeye&quot;, &quot;bob&quot;, &quot;fighting&quot;]</div><div class="line"></div><div class="line">&gt; //es5的Object.creat()方法实现寄生式继承。原理与object()方法的效果一样</div><div class="line">var person=&#123;</div><div class="line">	name:&quot;chenyu&quot;,</div><div class="line">	friends:[&quot;yulin&quot;,&quot;langxiaoju&quot;,&quot;wnagju&quot;,&quot;chenzihan&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson=Object.create(person);</div><div class="line">anotherPerson.name=&quot;a&quot;;</div><div class="line">anotherPerson.friends.push(&quot;zeze&quot;);</div><div class="line">console.log(person.friends);</div><div class="line"></div><div class="line">var anotherPerson1=Object.create(person);</div><div class="line">anotherPerson1.name=&quot;b&quot;;</div><div class="line">anotherPerson1.friends.push(&quot;enen&quot;);</div><div class="line">console.log(person.friends);</div><div class="line">console.log(person.name);</div><div class="line">console.log(anotherPerson1.name);</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解http知识总结]]></title>
      <url>http://yoursite.com/2016/09/10/%E5%9B%BE%E8%A7%A3http%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="图解http知识总结"><a href="#图解http知识总结" class="headerlink" title="图解http知识总结"></a>图解http知识总结</h1><p>[TOC]</p>
<h2 id="HTTP-1-1虽然是无状态协议，"><a href="#HTTP-1-1虽然是无状态协议，" class="headerlink" title="HTTP/1.1虽然是无状态协议，"></a>HTTP/1.1虽然是无状态协议，</h2><p>但为了实现期望的保持状态功能，于是引入了Cookie技术。有cookie再用http协议通信，就可以管理状态了。</p>
<h2 id="HTTP-1-1的使用方法："><a href="#HTTP-1-1的使用方法：" class="headerlink" title="HTTP/1.1的使用方法："></a>HTTP/1.1的使用方法：</h2><ul>
<li>GET:获取资源<br>GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是如果是请求的资源的是文本，那就保持原样返回。如果是CGI（通用网关接口）那样的程序，那返回经过执行后的输出结果。</li>
<li>POST：传输实体主体<br>post方法用来传输实体的主体<br>虽然用get方法也可以传输实体的主体。但一般不用get方法进行传输。而是用post方法，虽说post的功能与get很相似，但post的主要目的并不是获取响应的主体内容。</li>
</ul>
<blockquote>
<p>GET与POST方式的区别：<br>ＧＥＴ与ＰＯＳＴ请求提交方式<br>从性能上来讲post请求比get请求消耗更多一些，用相同数据比较，get最多比post快两倍</p>
<ol>
<li>在web程序上，get一般是URL提交请求如：demo.php?name=lee&amp;age=100<br>post 一般是web表单提交 如：<form method="post"><input type="text" name="name" value="bob"><input type="password" name="passqord"></form><br>两种头信息：查看方式：firebug-》网络</li>
<li>响应头信息：服务器返回的信息，客户端可以获取，但不可以设置</li>
<li>请求头信息：客户端发送的信息，客户端可以设置，但不可以获取<br>1-1解决中文乱码问题，ajax返回的数据其实是utf-8的，最简单解决措施，全部设置为utf-8<br>1-2特殊字符，需要通过encodeURLComponent来编码解决</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//get方式</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt; </div><div class="line"> addEvent(document,&apos;click&apos;,function()&#123;</div><div class="line">      var xhr=creatXHR();</div><div class="line">      var url=&apos;demo.php?rand=&apos;+Math.random();</div><div class="line">      url=params(url,&apos;name&apos;,&apos;lee&apos;);</div><div class="line">        url=params(url,&apos;age&apos;,100);</div><div class="line">        alert(url);</div><div class="line">      xhr.onreadystatechange=function()&#123;</div><div class="line">         if(xhr.readyState==4)&#123;</div><div class="line">       if(xhr.status==200)&#123;</div><div class="line">       //alert(xhr.getAllResponseHeaders()) ;//获取全部响应头信息</div><div class="line">       //alert(xhr.getResponseHeader(&apos;Content-Type&apos;));//获取单个响应头信息       </div><div class="line">               alert(xhr.responseText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;else&#123;</div><div class="line">   alert(&apos;获取数据错误！错误代号：&apos;+xhr.status+&apos;,错误信息：&apos;+xhr.statusText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line"></div><div class="line">      &#125;;</div><div class="line">    xhr.open(&apos;get&apos;,url+Math.random(),true);</div><div class="line">    xhr.send(null);</div><div class="line">    xhr.about();//取消异步请求，放在send（）之前会报错，放在responseText（）之前会得到一个空值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">   function params(url,name,value)&#123;</div><div class="line">     url+=url.indexOf==-1?&apos;?&apos;:&apos;&amp;&apos;;</div><div class="line">     url+=encodeURLComponent(name)+&apos;=&apos;+encodeURLComponent(value);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line"></div><div class="line">//post方式</div><div class="line"></div><div class="line">addEvent(document,&apos;click&apos;,function()&#123;</div><div class="line">      var xhr=creatXHR();</div><div class="line">      var url=&apos;demo.php?rand=&apos;+Math.random();</div><div class="line">      url=params(url,&apos;name&apos;,&apos;lee&apos;);</div><div class="line">        url=params(url,&apos;age&apos;,100);</div><div class="line">        alert(url);</div><div class="line">      xhr.onreadystatechange=function()&#123;</div><div class="line">         if(xhr.readyState==4)&#123;</div><div class="line">       if(xhr.status==200)&#123;</div><div class="line">       //alert(xhr.getAllResponseHeaders()) ;//获取全部响应头信息</div><div class="line">       //alert(xhr.getResponseHeader(&apos;Content-Type&apos;));//获取单个响应头信息       </div><div class="line">               alert(xhr.responseText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;else&#123;</div><div class="line">   alert(&apos;获取数据错误！错误代号：&apos;+xhr.status+&apos;,错误信息：&apos;+xhr.statusText);</div><div class="line"></div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line"></div><div class="line">      &#125;;</div><div class="line">    xhr.open(&apos;post&apos;,url,true);//第一步改为post</div><div class="line">    xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);//第三步模仿表单提交</div><div class="line">    xhr.send(&apos;name=Lee&amp;age=100&apos;);//第二步将名值放入send（）方法里</div><div class="line">    xhr.about();//取消异步请求，放在send（）之前会报错，放在responseText（）之前会得到一个空值</div><div class="line">&#125;);</div><div class="line"></div><div class="line">   function params(url,name,value)&#123;</div><div class="line">     url+=url.indexOf==-1?&apos;?&apos;:&apos;&amp;&apos;;</div><div class="line">     url+=encodeURLComponent(name)+&apos;=&apos;+encodeURLComponent(value);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>PUT:传输文件</li>
<li>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在URI指定的位置。（存在安全性）</li>
<li>HEAD:获取报文首部<br>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性以及资源的更新的日期时间等。</li>
<li>DELETE：删除文件<br>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。</li>
<li>OPTIONS:询问支持的方法<br>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</li>
<li>TRACE:追踪路径<br>TRACE方法是让WEB服务器端将之前的请求通信环回给客户端的方法</li>
<li>CONNECT:要求用隧道协议链接代理<br>CONNECT方法要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络隧道进行传输。<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2>HTTP是无状态的协议，它不对之前发生过得请求和响应的状态进行管理，也就是说，无法根据之前的状态进行本次的请求处理。<br>（假设要求登录认证的Web页面本身无法进行状态的管理即不记录已登录的状态，那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态）<br>Cookie会根据从服务器端发送的响应报文中写入Cookie信息来控制客户端的状态。</li>
</ul>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>缓存是指代理服务器或客服端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。</p>
<ol>
<li>缓存的有效时期</li>
<li>客户端的缓存<br>##为Cookie服务的首部字段<br>Cookie的工作机制用户识别以及状态管理。</li>
<li>为Cookie服务的首部字段 </li>
</ol>
<ul>
<li>Set-Cookie（响应首部字段 ）:开始状态管理所使用的Cookie信息</li>
<li>Cookie（请求首部字段）:服务器接受到的Cookie信息</li>
</ul>
<ol>
<li>Set-Cookie字段的属性</li>
</ol>
<ul>
<li>expires属性（=DATE）Cookie的有效日期（若不明确指定则默认为浏览器关闭前为止）<br><code>注意：</code>一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显示删除Cookie的方法。但可以通过覆盖已过期的Cookie，实现对客户端的Cookie的实质性的删除操作。<br>＊path属性（=PATH）将服务器上的文件目录作为Cookie的适用对象（若不能指定则默认为文档所在的而文件目录）</li>
<li>domain（=域名）作为Cookie适用对象的域名，（若不指定则默认为常见Cookie的服务器的域名）<br>（不指定域名显得更加安全）</li>
<li><p>secure属性（只写上secure即可）仅在HTTPS安全通信时才会发送Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=value;secure</div></pre></td></tr></table></figure>
</li>
<li><p>HttpOnly属性，其主要目的是为防止跨站脚本攻击（XSS）对Cookie的信息窃取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=value;HttpOnly</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭到篡改</li>
<li>窃听：对于收集互联网上的流动数据包（帧）解析工作，可交给抓包（Packet Capture）或者嗅探器（Sniffer）工具，如常见的：Wireshark</li>
</ul>
<ol>
<li>通信加密：HTTP协议没有加密机制，但可以通过SSL（安全套接层）或者TLS（安全层传输协议）的组合使用，加密HTTP的通信内容。（HTTP与SSL的组合使用被称为HTTPS（HTTP Secure），超文本传输安全协议）</li>
<li>HTTP+加密+认证+完整性保护=HTTPS<h2 id="为什么不一直使用HTTPS"><a href="#为什么不一直使用HTTPS" class="headerlink" title="为什么不一直使用HTTPS"></a>为什么不一直使用HTTPS</h2>原因：与纯文本通信相比，加密通信会消耗更多的资源（购买证书等）<h2 id="基于HTTP的功能的追加协议"><a href="#基于HTTP的功能的追加协议" class="headerlink" title="基于HTTP的功能的追加协议"></a>基于HTTP的功能的追加协议</h2></li>
<li>Ajax的解决办法<br>是一种有效利用js和DOM的操作，以达到Web页面替换加载的异步通信手段。只更新页面的部分内容。</li>
<li>Comet的解决办法<br>一旦服务器端有内容更新，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客服端推送的功能。</li>
<li>使用浏览器进行全双工通信的WebSocket<h2 id="与Web服务器及程序协作的CGI"><a href="#与Web服务器及程序协作的CGI" class="headerlink" title="与Web服务器及程序协作的CGI"></a>与Web服务器及程序协作的CGI</h2>CGI（通用网关接口）是指Web服务器在接受到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出相应的动作，使用CGI的程序叫做CGI程序，通常用Perl,php,ruby和c等编程语言编写而成。<h2 id="因Java而普及的Servlet"><a href="#因Java而普及的Servlet" class="headerlink" title="因Java而普及的Servlet"></a>因Java而普及的Servlet</h2>（Servlet=Server+Applet）表示轻量服务程序<br>Servlet是一种能子服务器上创建动态内容的程序。Servlet是用Java语言实现的一个接口，属于企业级Java（JavaEE，JavaEnterprise Edition）的一部分<br>（Servlet常驻内存，因此每次请求的时，可启动相对进程级别更为轻量的Servlet，程序的执行效率从而变的更高）<h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2>对Web应用的攻击模式有两种：主动攻击，被动攻击</li>
<li>以服务器为目标的主动攻击<br>主动攻击：是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。</li>
<li>以服务器为目标的被动攻击<br>被动攻击：指利用圈套策略执行攻击代码的攻击模式。在被动攻击的过程中，攻击者不直接对目标Web应用访问发起攻击。</li>
<li>因输出值转义不完全引发的安全漏洞<br>实施Web应用的安全对策课分为两个部分。</li>
</ol>
<ul>
<li>客户端的验证</li>
<li>Web应用端（服务器端）的验证</li>
<li>输入值验证</li>
<li>输出值转义</li>
</ul>
<ol>
<li>跨站脚本攻击（XSS）指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或js进行的一种攻击。<br>影响：</li>
</ol>
<ul>
<li>利用虚假输入表单骗取用户的个人信息</li>
<li>利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li>
<li>显示伪造的文章或图片</li>
</ul>
<ol>
<li>对用户Cookie的窃取攻击</li>
<li>SOL注入攻击<br>（1）会执行非法SQL的SQL注入攻击<br>影响:</li>
</ol>
<ul>
<li>非法查看或篡改数据库内的数据</li>
<li>规避认证</li>
<li>执行和数据库服务器业务关联的程序等</li>
<li>SQL注入攻击破坏SQL语句结构的案例</li>
</ul>
<ol>
<li>OS命令注入攻击<br>指通过Web应用，执行非法的操作系统命令达到攻击目的。只要在能调用Shell函数的地方就有存在被攻击的风险。</li>
<li>HTTP首部注入攻击<br>是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或者主体的一种攻击。属于被动攻击模式。 向首部主题内添加内容的攻击称为HTTP响应截断攻击。<br>影响：</li>
</ol>
<ul>
<li>设置任何Cookie信息</li>
<li>重定向至任意URL</li>
<li>显示任意的主体（HTTP响应截断攻击）</li>
</ul>
<ol>
<li>HTTP响应截断攻击</li>
<li>邮件首部注入攻击</li>
<li>目录遍历攻击</li>
<li>远程文件包含漏洞</li>
<li>因设置或设计上的缺陷引发的安全漏洞</li>
<li>不正确的错误消息处理</li>
<li>开放重定向</li>
<li>因会话管理疏忽引发的安全漏洞</li>
<li>会话固定攻击</li>
<li>跨站点请求伪造（CSRF）</li>
<li>其他安全漏洞</li>
</ol>
<ul>
<li>密码破解（穷举法/暴力破解法，字典攻击）</li>
<li>点击劫持</li>
</ul>
<ol>
<li>DoS攻击<br>DoS攻击是一种让运行中的服务呈停止状态的攻击，有时也叫做服务停止攻击或者拒绝服务攻击。<br>DoS攻击方式：</li>
</ol>
<ul>
<li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也呈停止状态。</li>
<li>通过攻击安全漏洞使服务停止</li>
</ul>
<ol>
<li>后台程序</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[清除浮动]]></title>
      <url>http://yoursite.com/2016/09/02/%E8%B0%88%E8%B0%88%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>##浮动的原理<br>css样式中的浮动（float）属性主要有none，left<br>   和right 这三个属性值：</p>
<ul>
<li><blockquote>
<p>float：none；设置页面中的元素对象不浮动，主要是将已经设置为浮动的元素改变为非浮动的元素</p>
</blockquote>
</li>
<li><blockquote>
<p>float:left将页面中的元素对象设置为左浮动。如果多个元素同时设置了该属性，那么将会形成一个从右到左的页面布局形式</p>
</blockquote>
</li>
<li><blockquote>
<p>float:right将页面中元素设置为右浮动，如果多个元素同时设置了该属性，那么将会形成一个从右到左的页面布局形式</p>
<h2 id="清除浮动的方式："><a href="#清除浮动的方式：" class="headerlink" title="清除浮动的方式："></a>清除浮动的方式：</h2><ol>
<li>利用br标签中的clear属性清除浮动<br><code>&lt;div class=&quot;float_box&quot;&gt;
&lt;div class=&quot;float_left&quot;&gt;左浮动元素&lt;/div&gt;
&lt;div class=&quot;float_right&quot;&gt;右浮动元素&lt;/div&gt;
&lt;/div&gt;
&lt;br clear=&quot;all&quot;/&gt;
&lt;div class=&quot;no_float&quot;&gt;测试因为浮动导致该容器所处的位置&lt;/div&gt;</code><br>（出现问题：在FF浏览器中我们看到类名为float_box的div标签已经有背景色了，在IE浏览器中并非如此）<br>解决办法：<br><code>.float_box{
background-color:#AAA;
**zoom:1;**</code> <em>解决IE浏览器中haslayout的问题</em><br>}</li>
<li>利用cs样式中的clear属性清除浮动<br>即把前面代码:<br class="clear_float"><br>改为<br class="clear_float"><br>对应css代码为：.clear_float{<br><strong>clear:both;</strong><br>}<br>可能出现问题与前面一样，解决办法相同设置：<strong>zoom：1</strong></li>
<li>利用css样式中的overflow属性清除浮动<br><code>.float_box{
overflow:hidden;
background:#AAA;
zoom:1;
}</code></li>
</ol>
<ul>
<li>overflow：visible；时，清除浮动只对IE有效</li>
<li>overflow：hidden;虽然能解决清除浮动问题，<br>但可能会因为hidden的属性值将溢出的部分隐藏</li>
<li>overflow：auto</li>
</ul>
<ol>
<li>利用css样式中的display：table清除浮动<br><code>.float_box{
display:table;
background-color:#666;
}</code><br>(不推荐使用)</li>
<li>采用伪类：after后续控制的高度为0的为伪类层清除浮动<br><code>.float_box:after{
clear:both;*清除伪类层以上的浮动*
display:block;
visibility:hidden;*设置伪类层内容为块元素且可见*
height:0；
line-height:0;*设置伪类层中的高度和行高为0*
content:&quot;&quot;;*将伪类层中的内容清空*
}</code></li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[作用域，作用域链，域解析]]></title>
      <url>http://yoursite.com/2016/08/18/%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%8C%E5%9F%9F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="作用域，作用域链，域解析"><a href="#作用域，作用域链，域解析" class="headerlink" title="作用域，作用域链，域解析"></a>作用域，作用域链，域解析</h1><h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>JavaScript执行环境，也叫作JavaScript执行上下文（我百度翻译的(＾－＾)，英文名叫做execution context）<br><code>执行环境：</code>JavaScript代码都是在执行环境中被执行的。执行环境是一个概念，一种机制，用来完成JavaScript运行时在作用域、生命周期等方面的处理，<code>它定义了变量或函数是否有权访问其他数据，决定各自行为。</code></p>
<blockquote>
<p>而且每个执行环境都会有一个就是变量对象VO（variable object），环境中<code>变量和函数声明保存在VO中。</code><br><code>注意</code>，函数表达式（与函数声明相对）不包含在变量对象之中。，在代码执行开始，会进入不同的执行环境，这些执行环境共同构成了一个执行环境栈。<br>如果这个环境是函数，则将其活动对象AO(activation object)作为变量对象,活动对象最开始的两个属性是arguments和this<br><img src="http://obfnbicau.bkt.clouddn.com/ec-stack.png" alt="Alt text"></p>
</blockquote>
<p>在下个图中，拥有一些函数上下文EC1和全局上下文Global EC，当EC1进入和退出全局上下文的时候下面的栈将会发生变化：<br><img src="http://obfnbicau.bkt.clouddn.com/ec-stack-changes.png" alt="Alt text"></p>
<p>JS中一共有三种执行环境：</p>
<ol>
<li><p>全局执行环境（Global code）   JS代码开始运行时默认的<br>即全局的、不在任何函数里面的代码，例如：一个js文件、嵌入在HTML页面中的js代码等<br><code>注意：</code></p>
<ul>
<li>保存在全局执行环境中的所有变量和函数，当其应用程序退出，如：关闭网页或浏览器时被销毁</li>
</ul>
<ul>
<li>全局执行环境是window的对象（所有全局函数和变量都是作为window的属性和方法创建的）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">         var a=2;</div><div class="line">function setB()&#123;</div><div class="line">	return 123;</div><div class="line">&#125;</div><div class="line">console.log(a);</div><div class="line">console.log(setB());</div><div class="line">console.log(window.a);</div><div class="line">console.log(window.setB());</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数执行环境（Function code） 代码进入了一个函数<br>每个函数有自己的执行环境，有相应的执行栈</p>
</li>
</ol>
<ul>
<li><p>函数里的局部作用域里的变量替换全局变量，但作用域仅限在函数体内的这个环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">            var a=&apos;哈哈哈~&apos;;</div><div class="line">function setB()&#123;</div><div class="line">	a=&apos;啧啧&apos;;</div><div class="line">&#125;</div><div class="line">setB();</div><div class="line">console.log(a);</div></pre></td></tr></table></figure>
</li>
<li><p>通过传参，可以替换函数体内的局部变量，但作用域仅限在函数体内的这个环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">           var a=&apos;哈哈哈~&apos;;</div><div class="line">function setB(a)&#123;</div><div class="line">	console.log(a);</div><div class="line">&#125;</div><div class="line">setB(&apos;嗯嗯&apos;);</div><div class="line">console.log(a);</div></pre></td></tr></table></figure>
</li>
<li><p>函数体内还包含有函数，只有通过外层函数，才能访问内层函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">      var a=1;</div><div class="line">function setA()&#123;</div><div class="line">	function setB()&#123;</div><div class="line">		var b=2;</div><div class="line">		console.log(a);</div><div class="line">		console.log(b);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	setB()</div><div class="line">&#125;</div><div class="line">setA();</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>eval()方法执行代码<br>eval()就像是一个完整的ECMAScript解析器，只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval(&quot;console.log(&apos;哈哈&apos;)&quot;);</div><div class="line">等价于</div><div class="line">console.log(&apos;哈哈&apos;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eval(&quot;function sayHi()&#123;console.log(&apos;hi&apos;);&#125;&quot;);</div><div class="line">sayHi();</div></pre></td></tr></table></figure></p>
<p>严格模式下，访问不到eval()中创建的任何变量和函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">eval(&quot;function sayHi()&#123;console.log(&apos;hi&apos;);&#125;&quot;);</div><div class="line">sayHi();</div></pre></td></tr></table></figure></p>
<p>应用：JSON解析器<br>危险：代码注入！！！（用户输入数据）</p>
<p>[TOC]</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>域：</code>空间，范围，区域…<br><code>作用：</code>读，写<br>作用域（scope）。在很多语言中（C++，C#，Java），作用域都是通过代码块（由{}包起来的代码）来决定的，但是，在JavaScript作用域是跟函数相关的，也可以说成是function-based。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">      function test(o)&#123;</div><div class="line">	var i=0;</div><div class="line">	if(typeof o==&quot;object&quot;)&#123;</div><div class="line"></div><div class="line">		var j=0;</div><div class="line">		for(var k=0;k&lt;10;k++)&#123;</div><div class="line">			console.log(k);</div><div class="line">		&#125;</div><div class="line">		console.log(k);		</div><div class="line">	&#125;</div><div class="line">	console.log(j);</div><div class="line">&#125;</div><div class="line">var obj=new Object();</div><div class="line">	test(obj);</div></pre></td></tr></table></figure></p>
<ol>
<li>全局作用域中的对象可以在代码的任何地方访问，一般来说，下面情况的对象会在全局作用域中： <ul>
<li>最外层函数和在最外层函数外面定义的变量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 最外层函数和在最外层函数外面定义的变量  </div><div class="line">  		var a = &quot;out&quot;; //最外层变量</div><div class="line">		function outFn() &#123; //最外层函数</div><div class="line">      	var b = &quot;in&quot;;</div><div class="line">    	function inFn() &#123; //内层函数</div><div class="line">        console.log(b);</div><div class="line">    	&#125;</div><div class="line">   		 inFn();</div><div class="line">		&#125;</div><div class="line">		console.log(a); //我是最外层变量</div><div class="line">		outFn(); </div><div class="line">		console.log(b); //in is not defined</div><div class="line">		inFn(); //inFn is not defined</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>没有通过关键字”var”声明的变量 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outFn2() &#123;</div><div class="line">   		a = &quot;未定义&quot;;</div><div class="line">    	var  a1 = &quot;内层变量2&quot;;</div><div class="line">		&#125;</div><div class="line">		outFn2();</div><div class="line">		//要先执行这个函数，否则根本不知道里面是啥</div><div class="line">		console.log(a); //未定义直接赋值的变量</div><div class="line">		console.log(a1); //inVariable2 is not defined</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>浏览器中，window对象的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window对象的内置属性都拥有全局作用域，</div><div class="line">如: window.name、window.location、window.top 等</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>局部作用域(函数作用域)所有的变量和函数只能在作用域内部使用。函数在声明它们的函数体以及这个函数体嵌套的任意函数内都是有定义的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo = 1; </div><div class="line">window.bar = 2;</div><div class="line">function baz()&#123; a = 3; var b = 4; &#125; </div><div class="line">// Global scope: foo, bar, baz, a</div><div class="line">// Local scope: b</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>函数声明提前：<br>js的函数作用域是指在函数内声明的所有变量在函数内始终都是可以见，意味着变量在声明之前就可以使用了，这个特性被非正式命名为<code>声明提前</code>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">         var a=1;</div><div class="line">function fn1()&#123;</div><div class="line">	console.log(a);//???</div><div class="line">	var a=2;</div><div class="line">	console.log(a);</div><div class="line">&#125;</div><div class="line">fn1();</div><div class="line">console.log(a);</div><div class="line">-------------------------------------------------</div><div class="line">         var a=1</div><div class="line">function fn1()&#123;</div><div class="line">var a;//在函数顶部声明了局部变量</div><div class="line">console.log(a);//变量存在，但其值是&quot;undefined&quot;</div><div class="line">a=2;</div><div class="line">console.log(a);</div><div class="line">&#125;</div><div class="line">fn1();</div><div class="line">console.log(a);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>[TOC]</p>
<h2 id="作用域链-scope-chain"><a href="#作用域链-scope-chain" class="headerlink" title="作用域链(scope chain)"></a>作用域链(scope chain)</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（是保证对执行环境有权访问的的所有变量和函数的<code>有序访问</code>），<code>这个作用域链是一个对象列表或者链表，这组对象定义了代码“作用域”中的变量</code><br><code>创建规则：</code><br>作用域链的前端，始终都是当前执行的代码<br>作用域链中的下一个变量对象，来自包含（外部环境）<br>而再下一个对象来自下一个包含环境<br>一直延续到全局执行环境（全局执行坏境的对象始终都是作用域链中的最后一个对象）</p>
<p> 一个函数创建时，javascript后台(引擎)会默认创建一个仅供后台使用的内部属性[[Scope]]，此属性存储函数的作用域链，如果是全局函数，此时则包含一个变量对象(全局变量)，如果是嵌套函数(闭包)，作用域链还加上了父函数的变量对象。例如下面的这个全局函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add(num1,num2)&#123;</div><div class="line">   var sum = num1 + num2;</div><div class="line">   return sum;</div><div class="line">&#125;</div><div class="line">var total=add(5,10);</div><div class="line">console.log(total);</div></pre></td></tr></table></figure></p>
<p><img src="http://obfnbicau.bkt.clouddn.com/r_%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.jpg" alt="Alt text"></p>
<p>b) 函数被调用时–add(5,10)，javascript后台会创建一个内部对象(execution context)–“执行环境”或“运行期上下文”，活动对象作为函数执行期的一个变量对象，包含所有局部变量(在函数内定义的)、命名参数、arguments、this，它会被推入到执行环境作用域链的前端(如下图)。每执行一次函数都会创建一个新的执行环境，当函数执行完毕执行环境就会被销毁。</p>
<p><img src="http://obfnbicau.bkt.clouddn.com/2012061700395832.jpg" alt="Alt text"></p>
<p>图中矩形表示特定的环境。其中内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部变量环境中的任何变量和函数。这些环境之间的联系是线性的，有次序的。每个环境变量都可以向上搜索作用域链，以查询变量和函数名；反之则是不行。<code>注意:</code>函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<p><img src="http://obfnbicau.bkt.clouddn.com/scope_chain.jpg" alt="Alt text"></p>
<blockquote>
<p>查询标识符(标识符指的是：变量名称，函数声明，形参，等等。)：标示符的解析是沿着作用域链一级一级的搜索标示符的过程，搜索过程都是从作用域链的前端开始，然后逐级向后回溯，直到找到标识符为止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var color=&quot;blue&quot;;</div><div class="line">function getColor()&#123;</div><div class="line">return color;</div><div class="line">&#125;</div><div class="line">console.log(getColor());//&quot;blue&quot;</div></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="http://obfnbicau.bkt.clouddn.com/%E6%A0%87%E7%A4%BA%E7%AC%A6.jpg" alt="Alt text"></p>
<p>[TOC]</p>
<h2 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h2><p>try-catch语句的catch块<br>with语句<br>  这两个语句都会在原本的作用域链的前端添加一个变量对象。对于with语句来说，新添加的变量对象包含着with括号中指定对象的所有属性和方法所作的变量声明。对于catch来说，当try块发生错误时，代码执行流程自动转入到catch块，并将异常对象推入到作用域链的前端。catch块执行完毕后，作用域链就会返回原来的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function initUI()&#123;</div><div class="line">   with(document)&#123;</div><div class="line">        var bd = body,</div><div class="line">        links =  getElementsByTagName(&quot;a&quot;),</div><div class="line">        i = 0,</div><div class="line">        len = links.length;</div><div class="line">        while(i&lt;len)&#123;</div><div class="line">              update(links[i++]);</div><div class="line">        &#125;</div><div class="line">        getElementById(&quot;go-btn&quot;).onclick = function()&#123;</div><div class="line">              start();</div><div class="line">        &#125;;</div><div class="line">        bd.className = &quot;active&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当代码流执行到一个with表达式时，执行环境的作用域链会被临时改变，此时with的变量对象会被创建添加到作用域链的前端，这就意味着此时函数的所有局部变量都被推入到第二个作用域链中的变量对象，如下图：<br><img src="http://obfnbicau.bkt.clouddn.com/2012061812093041.gif" alt="Alt text"></p>
<p><code>注意：</code>在执行with语句时，访问局部变量的代价更高了。所以尽可能避免使用with语句，可以使用局部变量代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var doc = document; // 代替with(document)&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>[TOC]</p>
<p>##域解析<br>浏览器：</p>
<ol>
<li><p>预解析：<br>“js解析器”<br>“找一些东西”：var， function<br>，参数<br>a=未定义<br>所有的变量，在正式运行代码之前，都提前赋了一个值（未定义）<br>fn1=function fn1(){console.log(1);}<br>所有的函数，在正式运行代码之前，都是<code>整个函数块</code><br><code>注意：</code>遇到重名，变量和函数重名，就留下函数，与上下文没有关系，注只先找var ，function声明的，函数重名，则采用覆盖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">console.log(a);</div><div class="line">var a=2;</div><div class="line">function fn1()&#123;</div><div class="line">console.log(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>逐行解读代码<br>表达式：= + -* / ++ –！ 参数</p>
</li>
</ol>
<ul>
<li>表达式可以修改预解析的值！</li>
<li>函数调用：<br>同理函数作用域也发生：<br>1.预解析和2.逐行解读代码<br>函数：由里到外（作用域链）<br>如：var a=1;改预解析里面的<br>a=function fn1(){console.log(a);}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log(a);//不会从下面取值，直接从预解析的仓库里取出undefined</div><div class="line">var a=2;</div><div class="line">console.log(a);</div><div class="line">function fn1()&#123;</div><div class="line">console.log(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考链接：<br><a href="http://www.cnblogs.com/leolai/archive/2012/06/17/2552326.html" target="_blank" rel="external">https://gaohaoyang.github.io/2015/05/20/scope/</a></p>
<p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context" target="_blank" rel="external">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/#execution-context</a></p>
<p>参考资料：<br>javaScript高级程序设计<br>javaScript权威指南</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是盒子模型]]></title>
      <url>http://yoursite.com/2015/09/03/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h1><p>盒模型就是指css布局中的每个元素，在浏览器的解释中，都会被当做一个盒模型，浏览器通过这些盒状物的大小和浮动方式来判断下一个盒状物的贴近显示，还是下一行显示，还是其他方式显示，任何一个css布局的网页，都是由许多不同大小盒子构成。渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。<br>对盒模型的形象化表述盒模型形象化表述：<br>将页面中的任何一个元素形容成邮局的每一个邮包 </p>
<ul>
<li>邮寄的物品—-页面中的元素内容 </li>
<li>塞入的海绵—-内边距padding </li>
<li>邮局的纸盒邮包—-边框border </li>
<li>邮包堆积之间的间距—–外边距margin<br><code>注意：</code> 盒模型类似于邮局纸盒邮包情况，却又不等同于，<br>但IE在某种情况下，却又完全等同于纸盒邮包情形（邮局的纸盒中无论塞入多少海绵保护邮寄物品，邮局的纸盒邮包的大小是不会变的，而页面中元素不同，padding属性值越大，那么所占用的空间也就越大）<br>DOCTYPE类型声明影响IE浏览器对标准的理解：<br>IE浏览器存在两种渲染方式： </li>
</ul>
<ol>
<li>Quirks(怪异模式)：以一种比较宽松的向后兼容的方式显示<br>触发怪异模式使IE浏览器计算盒模型的方式有所变化（至于怎么触发怪异模式：如：在DOCTYPE类型前加一个字符，或者将它直接删除了）<br>计算方式的改变就是：<br>将盒模型的border和padding的数值归入到<br>盒模型的宽度width及高度height<br>盒模型宽=margin-left+width+margin-right<br>盒模型高=margin-top+height+margin-bottom </li>
<li>Standard(标准模式)：浏览器根据规范表现页面<br>cmd-markdown-logo<br>盒模型的细节：<br>盒模型差异<br>IE6/IE7/Firefox的最终宽度=左外边距+左边框宽+左内边距+宽度+右外边距+右边框宽+右内边距<br>IE5的最终宽度=左外边距+宽度+右外边距<br>（1）上下margin叠加问题<br>.a{<br>Width:100px;<br>Height:100px;<br>Background-color:#eeffee;<br>Border:1px solid #bbb;<br>Margin:10px;<br>}<br>.b{<br>Width:100px;<br>Height:100px;<br>Background-color:#ccc;<br>Border:1px solid #ddd;<br>Margin:10px;<br>}<br>空白边叠加时，结果以最大者为准<br>解决办法：把相应元素设为float属性，它们将不会发生空白叠加问题了<br>（2）左右margin叠加问题<br>当盒对象为浮动状态时，IE6中，盒模型的左右margin会加倍<br>解决办法：display:inline;</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ps的基础知识]]></title>
      <url>http://yoursite.com/2015/09/02/%E5%85%B3%E4%BA%8Eps%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>##前端ps基础技能需求：<strong>切图</strong>，<strong>修图</strong>，<strong>测量</strong></p>
<p> <strong>前端常用 ps工具：</strong><br> 移动工具，矩形选框工具，裁切工具，吸管工具，横排文字工具，手抓，缩放，标尺，自由变换<br> <strong>ps快捷键：</strong><br>窗口（历史记录，信息（F8），图层（F7））<br>视图（参考线设置）<br>图像（图像大小（alt+ctrl+i），画布大小（alt+ctrl+c），剪裁，剪切）<br>文件（存储为web和设备所用格式（alt+shift+ctrl+c））<br>左侧工具栏的使用（移动工具，矩形选框工具，吸管工具，横排文字工具，抓手工具，放大/缩小工具）<br>Ctrl+/ctrl-放大、缩小  Ctrl+R标尺 shift+tab调板  Ctrl+h 参考线</p>
<blockquote>
<p>图片的导出格式：<br>保存文件格式:</p>
<ol>
<li>psd（源文件：没办法直接使用）</li>
<li>JPG：不支持透明半透明，所有空白区域填充白色（应用：网页中的大图，高清图（体积大））</li>
<li>GIF（png8：小图标）：支持透明，不支持半透明（小图标（动画图片）</li>
<li>png24：支持透明，也支持半透明（图像中存在半透明效果的图片）</li>
</ol>
</blockquote>
<p>  <em>psd测量注意事项：</em><br>文字右方和下方会有1像素的默认间隙 </p>
<p>ps一些基本操作：</p>
<ul>
<li>删除图片上的文字：</li>
</ul>
<ol>
<li>矩形选框选中删除区域，按delete删除键</li>
<li>矩形选中相应模块（盖住文字的部分），再按Ctrl+t（自由变换）推动模块，即可盖住文字</li>
</ol>
<ul>
<li>如何把选中图像变成白色：</li>
</ul>
<ol>
<li>选中要变白的图像并且选中相应图层—将右下角背景调为白色–点击油漆桶工具（位于渐变工具一栏）即可</li>
</ol>
<ul>
<li>图像放大了之后，目的就是要仔细观察细节，图像太大以至于画布装不下了，要拖动滚动条吧太麻烦，这里不用拖动滚动条。按住“空格键”不松手，赶紧观察，发现情况了没有，鼠标变成抓手工具形状了</li>
<li>如果要将图像调整到什么程度，要求图像都能清晰显示窗口–&gt;图层–&gt;智能对象–&gt;图像–&gt;画布大小</li>
<li>将图像改变方向：图像–&gt;图像旋转（180度，90度，90度逆时针等）</li>
</ul>
<blockquote>
<p>切图：实现精确选图：拉出参考线后，选择矩形区域，按住Ctrl键（图像颜色表现有变浅的表现）<br>图层：图层后优先级与后面出现的数字无关，与排列在前面的顺序有关</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
